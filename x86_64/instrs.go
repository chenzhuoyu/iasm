// Code generated by "mkasm_amd64.py", DO NOT EDIT.

package x86_64

// Instructions maps all the instruction name to it's encoder function.
var Instructions = map[string]func(*Program, ...interface{}) *Instruction {
    "addb"       : (*Program).ADDB,
    "addl"       : (*Program).ADDL,
    "addpd"      : (*Program).ADDPD,
    "addps"      : (*Program).ADDPS,
    "addq"       : (*Program).ADDQ,
    "addsd"      : (*Program).ADDSD,
    "addss"      : (*Program).ADDSS,
    "addsubpd"   : (*Program).ADDSUBPD,
    "addsubps"   : (*Program).ADDSUBPS,
    "addw"       : (*Program).ADDW,
    "ja"         : (*Program).JA,
    "jae"        : (*Program).JAE,
    "jb"         : (*Program).JB,
    "jbe"        : (*Program).JBE,
    "jc"         : (*Program).JC,
    "je"         : (*Program).JE,
    "jecxz"      : (*Program).JECXZ,
    "jg"         : (*Program).JG,
    "jge"        : (*Program).JGE,
    "jl"         : (*Program).JL,
    "jle"        : (*Program).JLE,
    "jmp"        : (*Program).JMP,
    "jmpq"       : (*Program).JMPQ,
    "jna"        : (*Program).JNA,
    "jnae"       : (*Program).JNAE,
    "jnb"        : (*Program).JNB,
    "jnbe"       : (*Program).JNBE,
    "jnc"        : (*Program).JNC,
    "jne"        : (*Program).JNE,
    "jng"        : (*Program).JNG,
    "jnge"       : (*Program).JNGE,
    "jnl"        : (*Program).JNL,
    "jnle"       : (*Program).JNLE,
    "jno"        : (*Program).JNO,
    "jnp"        : (*Program).JNP,
    "jns"        : (*Program).JNS,
    "jnz"        : (*Program).JNZ,
    "jo"         : (*Program).JO,
    "jp"         : (*Program).JP,
    "jpe"        : (*Program).JPE,
    "jpo"        : (*Program).JPO,
    "jrcxz"      : (*Program).JRCXZ,
    "js"         : (*Program).JS,
    "jz"         : (*Program).JZ,
    "vzeroupper" : (*Program).VZEROUPPER,
}

// ADDB performs "Add".
//
// Mnemonic        : ADD
// Supported forms : (6 forms)
//
//    * ADDB imm8, al
//    * ADDB imm8, r8
//    * ADDB r8, r8
//    * ADDB m8, r8
//    * ADDB imm8, m8
//    * ADDB r8, m8
//
func (self *Program) ADDB(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDB imm8, al
    if len(args) == 2 && isImm8(args[0]) && args[1] == AL {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x04)
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDB imm8, r8
    if len(args) == 2 && isImm8(args[0]) && isReg8(args[1]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(0, v[1], isReg8REX(v[1]))
            m.emit(0x80)
            m.emit(0xc0 | lcode(v[1]))
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDB r8, r8
    if len(args) == 2 && isReg8(args[0]) && isReg8(args[1]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[0]), v[1], isReg8REX(v[0]) || isReg8REX(v[1]))
            m.emit(0x00)
            m.emit(0xc0 | lcode(v[0]) << 3 | lcode(v[1]))
        })
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[1]), v[0], isReg8REX(v[0]) || isReg8REX(v[1]))
            m.emit(0x02)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDB m8, r8
    if len(args) == 2 && isM8(args[0]) && isReg8(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[1]), addr(v[0]), isReg8REX(v[1]))
            m.emit(0x02)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    // ADDB imm8, m8
    if len(args) == 2 && isImm8(args[0]) && isM8(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(0, addr(v[1]), false)
            m.emit(0x80)
            m.mrsd(0, addr(v[1]), 1)
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDB r8, m8
    if len(args) == 2 && isReg8(args[0]) && isM8(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[0]), addr(v[1]), isReg8REX(v[0]))
            m.emit(0x00)
            m.mrsd(lcode(v[0]), addr(v[1]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDB")
    }
    return p
}

// ADDL performs "Add".
//
// Mnemonic        : ADD
// Supported forms : (8 forms)
//
//    * ADDL imm32, eax
//    * ADDL imm8, r32
//    * ADDL imm32, r32
//    * ADDL r32, r32
//    * ADDL m32, r32
//    * ADDL imm8, m32
//    * ADDL imm32, m32
//    * ADDL r32, m32
//
func (self *Program) ADDL(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDL imm32, eax
    if len(args) == 2 && isImm32(args[0]) && args[1] == EAX {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x05)
            m.imm4(toImmAny(v[0]))
        })
    }
    // ADDL imm8, r32
    if len(args) == 2 && isImm8Ext(args[0], 4) && isReg32(args[1]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(0, v[1], false)
            m.emit(0x83)
            m.emit(0xc0 | lcode(v[1]))
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDL imm32, r32
    if len(args) == 2 && isImm32(args[0]) && isReg32(args[1]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(0, v[1], false)
            m.emit(0x81)
            m.emit(0xc0 | lcode(v[1]))
            m.imm4(toImmAny(v[0]))
        })
    }
    // ADDL r32, r32
    if len(args) == 2 && isReg32(args[0]) && isReg32(args[1]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[0]), v[1], false)
            m.emit(0x01)
            m.emit(0xc0 | lcode(v[0]) << 3 | lcode(v[1]))
        })
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[1]), v[0], false)
            m.emit(0x03)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDL m32, r32
    if len(args) == 2 && isM32(args[0]) && isReg32(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[1]), addr(v[0]), false)
            m.emit(0x03)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    // ADDL imm8, m32
    if len(args) == 2 && isImm8Ext(args[0], 4) && isM32(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(0, addr(v[1]), false)
            m.emit(0x83)
            m.mrsd(0, addr(v[1]), 1)
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDL imm32, m32
    if len(args) == 2 && isImm32(args[0]) && isM32(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(0, addr(v[1]), false)
            m.emit(0x81)
            m.mrsd(0, addr(v[1]), 1)
            m.imm4(toImmAny(v[0]))
        })
    }
    // ADDL r32, m32
    if len(args) == 2 && isReg32(args[0]) && isM32(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[0]), addr(v[1]), false)
            m.emit(0x01)
            m.mrsd(lcode(v[0]), addr(v[1]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDL")
    }
    return p
}

// ADDPD performs "Add Packed Double-Precision Floating-Point Values".
//
// Mnemonic        : ADDPD
// Supported forms : (2 forms)
//
//    * ADDPD xmm, xmm
//    * ADDPD m128, xmm
//
func (self *Program) ADDPD(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDPD xmm, xmm
    if len(args) == 2 && isXMM(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE2)
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(hcode(v[1]), v[0], false)
            m.emit(0x0f)
            m.emit(0x58)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDPD m128, xmm
    if len(args) == 2 && isM128(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE2)
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(hcode(v[1]), addr(v[0]), false)
            m.emit(0x0f)
            m.emit(0x58)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDPD")
    }
    return p
}

// ADDPS performs "Add Packed Single-Precision Floating-Point Values".
//
// Mnemonic        : ADDPS
// Supported forms : (2 forms)
//
//    * ADDPS xmm, xmm
//    * ADDPS m128, xmm
//
func (self *Program) ADDPS(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDPS xmm, xmm
    if len(args) == 2 && isXMM(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE)
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[1]), v[0], false)
            m.emit(0x0f)
            m.emit(0x58)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDPS m128, xmm
    if len(args) == 2 && isM128(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE)
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(hcode(v[1]), addr(v[0]), false)
            m.emit(0x0f)
            m.emit(0x58)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDPS")
    }
    return p
}

// ADDQ performs "Add".
//
// Mnemonic        : ADD
// Supported forms : (8 forms)
//
//    * ADDQ imm32, rax
//    * ADDQ imm8, r64
//    * ADDQ imm32, r64
//    * ADDQ r64, r64
//    * ADDQ m64, r64
//    * ADDQ imm8, m64
//    * ADDQ imm32, m64
//    * ADDQ r64, m64
//
func (self *Program) ADDQ(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDQ imm32, rax
    if len(args) == 2 && isImm32(args[0]) && args[1] == RAX {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x48)
            m.emit(0x05)
            m.imm4(toImmAny(v[0]))
        })
    }
    // ADDQ imm8, r64
    if len(args) == 2 && isImm8Ext(args[0], 8) && isReg64(args[1]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x48 | hcode(v[1]))
            m.emit(0x83)
            m.emit(0xc0 | lcode(v[1]))
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDQ imm32, r64
    if len(args) == 2 && isImm32Ext(args[0], 8) && isReg64(args[1]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x48 | hcode(v[1]))
            m.emit(0x81)
            m.emit(0xc0 | lcode(v[1]))
            m.imm4(toImmAny(v[0]))
        })
    }
    // ADDQ r64, r64
    if len(args) == 2 && isReg64(args[0]) && isReg64(args[1]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x48 | hcode(v[0]) << 2 | hcode(v[1]))
            m.emit(0x01)
            m.emit(0xc0 | lcode(v[0]) << 3 | lcode(v[1]))
        })
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x48 | hcode(v[1]) << 2 | hcode(v[0]))
            m.emit(0x03)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDQ m64, r64
    if len(args) == 2 && isM64(args[0]) && isReg64(args[1]) {
        p.add(_MRSD, func(m *_Encoding, v []interface{}) {
            m.rexm(1, hcode(v[1]), addr(v[0]))
            m.emit(0x03)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    // ADDQ imm8, m64
    if len(args) == 2 && isImm8Ext(args[0], 8) && isM64(args[1]) {
        p.add(_MRSD, func(m *_Encoding, v []interface{}) {
            m.rexm(1, 0, addr(v[1]))
            m.emit(0x83)
            m.mrsd(0, addr(v[1]), 1)
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDQ imm32, m64
    if len(args) == 2 && isImm32Ext(args[0], 8) && isM64(args[1]) {
        p.add(_MRSD, func(m *_Encoding, v []interface{}) {
            m.rexm(1, 0, addr(v[1]))
            m.emit(0x81)
            m.mrsd(0, addr(v[1]), 1)
            m.imm4(toImmAny(v[0]))
        })
    }
    // ADDQ r64, m64
    if len(args) == 2 && isReg64(args[0]) && isM64(args[1]) {
        p.add(_MRSD, func(m *_Encoding, v []interface{}) {
            m.rexm(1, hcode(v[0]), addr(v[1]))
            m.emit(0x01)
            m.mrsd(lcode(v[0]), addr(v[1]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDQ")
    }
    return p
}

// ADDSD performs "Add Scalar Double-Precision Floating-Point Values".
//
// Mnemonic        : ADDSD
// Supported forms : (2 forms)
//
//    * ADDSD xmm, xmm
//    * ADDSD m64, xmm
//
func (self *Program) ADDSD(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDSD xmm, xmm
    if len(args) == 2 && isXMM(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE2)
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0xf2)
            m.rexo(hcode(v[1]), v[0], false)
            m.emit(0x0f)
            m.emit(0x58)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDSD m64, xmm
    if len(args) == 2 && isM64(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE2)
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0xf2)
            m.rexo(hcode(v[1]), addr(v[0]), false)
            m.emit(0x0f)
            m.emit(0x58)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDSD")
    }
    return p
}

// ADDSS performs "Add Scalar Single-Precision Floating-Point Values".
//
// Mnemonic        : ADDSS
// Supported forms : (2 forms)
//
//    * ADDSS xmm, xmm
//    * ADDSS m32, xmm
//
func (self *Program) ADDSS(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDSS xmm, xmm
    if len(args) == 2 && isXMM(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE)
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0xf3)
            m.rexo(hcode(v[1]), v[0], false)
            m.emit(0x0f)
            m.emit(0x58)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDSS m32, xmm
    if len(args) == 2 && isM32(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE)
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0xf3)
            m.rexo(hcode(v[1]), addr(v[0]), false)
            m.emit(0x0f)
            m.emit(0x58)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDSS")
    }
    return p
}

// ADDSUBPD performs "Packed Double-FP Add/Subtract".
//
// Mnemonic        : ADDSUBPD
// Supported forms : (2 forms)
//
//    * ADDSUBPD xmm, xmm
//    * ADDSUBPD m128, xmm
//
func (self *Program) ADDSUBPD(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDSUBPD xmm, xmm
    if len(args) == 2 && isXMM(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE3)
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(hcode(v[1]), v[0], false)
            m.emit(0x0f)
            m.emit(0xd0)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDSUBPD m128, xmm
    if len(args) == 2 && isM128(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE3)
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(hcode(v[1]), addr(v[0]), false)
            m.emit(0x0f)
            m.emit(0xd0)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDSUBPD")
    }
    return p
}

// ADDSUBPS performs "Packed Single-FP Add/Subtract".
//
// Mnemonic        : ADDSUBPS
// Supported forms : (2 forms)
//
//    * ADDSUBPS xmm, xmm
//    * ADDSUBPS m128, xmm
//
func (self *Program) ADDSUBPS(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDSUBPS xmm, xmm
    if len(args) == 2 && isXMM(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE3)
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0xf2)
            m.rexo(hcode(v[1]), v[0], false)
            m.emit(0x0f)
            m.emit(0xd0)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDSUBPS m128, xmm
    if len(args) == 2 && isM128(args[0]) && isXMM(args[1]) {
        self.require(ISA_SSE3)
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0xf2)
            m.rexo(hcode(v[1]), addr(v[0]), false)
            m.emit(0x0f)
            m.emit(0xd0)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDSUBPS")
    }
    return p
}

// ADDW performs "Add".
//
// Mnemonic        : ADD
// Supported forms : (8 forms)
//
//    * ADDW imm16, ax
//    * ADDW imm8, r16
//    * ADDW imm16, r16
//    * ADDW r16, r16
//    * ADDW m16, r16
//    * ADDW imm8, m16
//    * ADDW imm16, m16
//    * ADDW r16, m16
//
func (self *Program) ADDW(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // ADDW imm16, ax
    if len(args) == 2 && isImm16(args[0]) && args[1] == AX {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.emit(0x05)
            m.imm2(toImmAny(v[0]))
        })
    }
    // ADDW imm8, r16
    if len(args) == 2 && isImm8Ext(args[0], 2) && isReg16(args[1]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(0, v[1], false)
            m.emit(0x83)
            m.emit(0xc0 | lcode(v[1]))
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDW imm16, r16
    if len(args) == 2 && isImm16(args[0]) && isReg16(args[1]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(0, v[1], false)
            m.emit(0x81)
            m.emit(0xc0 | lcode(v[1]))
            m.imm2(toImmAny(v[0]))
        })
    }
    // ADDW r16, r16
    if len(args) == 2 && isReg16(args[0]) && isReg16(args[1]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(hcode(v[0]), v[1], false)
            m.emit(0x01)
            m.emit(0xc0 | lcode(v[0]) << 3 | lcode(v[1]))
        })
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(hcode(v[1]), v[0], false)
            m.emit(0x03)
            m.emit(0xc0 | lcode(v[1]) << 3 | lcode(v[0]))
        })
    }
    // ADDW m16, r16
    if len(args) == 2 && isM16(args[0]) && isReg16(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(hcode(v[1]), addr(v[0]), false)
            m.emit(0x03)
            m.mrsd(lcode(v[1]), addr(v[0]), 1)
        })
    }
    // ADDW imm8, m16
    if len(args) == 2 && isImm8Ext(args[0], 2) && isM16(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(0, addr(v[1]), false)
            m.emit(0x83)
            m.mrsd(0, addr(v[1]), 1)
            m.imm1(toImmAny(v[0]))
        })
    }
    // ADDW imm16, m16
    if len(args) == 2 && isImm16(args[0]) && isM16(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(0, addr(v[1]), false)
            m.emit(0x81)
            m.mrsd(0, addr(v[1]), 1)
            m.imm2(toImmAny(v[0]))
        })
    }
    // ADDW r16, m16
    if len(args) == 2 && isReg16(args[0]) && isM16(args[1]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.emit(0x66)
            m.rexo(hcode(v[0]), addr(v[1]), false)
            m.emit(0x01)
            m.mrsd(lcode(v[0]), addr(v[1]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for ADDW")
    }
    return p
}

// JA performs "Jump if above (CF == 0 and ZF == 0)".
//
// Mnemonic        : JA
// Supported forms : (2 forms)
//
//    * JA rel8
//    * JA rel32
//
func (self *Program) JA(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JA rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x77)
            m.imm1(offs(v[0]))
        })
    }
    // JA rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x87)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JA")
    }
    return p
}

// JAE performs "Jump if above or equal (CF == 0)".
//
// Mnemonic        : JAE
// Supported forms : (2 forms)
//
//    * JAE rel8
//    * JAE rel32
//
func (self *Program) JAE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JAE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x73)
            m.imm1(offs(v[0]))
        })
    }
    // JAE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x83)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JAE")
    }
    return p
}

// JB performs "Jump if below (CF == 1)".
//
// Mnemonic        : JB
// Supported forms : (2 forms)
//
//    * JB rel8
//    * JB rel32
//
func (self *Program) JB(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JB rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x72)
            m.imm1(offs(v[0]))
        })
    }
    // JB rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x82)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JB")
    }
    return p
}

// JBE performs "Jump if below or equal (CF == 1 or ZF == 1)".
//
// Mnemonic        : JBE
// Supported forms : (2 forms)
//
//    * JBE rel8
//    * JBE rel32
//
func (self *Program) JBE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JBE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x76)
            m.imm1(offs(v[0]))
        })
    }
    // JBE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x86)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JBE")
    }
    return p
}

// JC performs "Jump if carry (CF == 1)".
//
// Mnemonic        : JC
// Supported forms : (2 forms)
//
//    * JC rel8
//    * JC rel32
//
func (self *Program) JC(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JC rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x72)
            m.imm1(offs(v[0]))
        })
    }
    // JC rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x82)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JC")
    }
    return p
}

// JE performs "Jump if equal (ZF == 1)".
//
// Mnemonic        : JE
// Supported forms : (2 forms)
//
//    * JE rel8
//    * JE rel32
//
func (self *Program) JE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x74)
            m.imm1(offs(v[0]))
        })
    }
    // JE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x84)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JE")
    }
    return p
}

// JECXZ performs "Jump if ECX register is 0".
//
// Mnemonic        : JECXZ
// Supported forms : (1 form)
//
//    * JECXZ rel8
//
func (self *Program) JECXZ(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JECXZ rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0xe3)
            m.imm1(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JECXZ")
    }
    return p
}

// JG performs "Jump if greater (ZF == 0 and SF == OF)".
//
// Mnemonic        : JG
// Supported forms : (2 forms)
//
//    * JG rel8
//    * JG rel32
//
func (self *Program) JG(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JG rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7f)
            m.imm1(offs(v[0]))
        })
    }
    // JG rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8f)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JG")
    }
    return p
}

// JGE performs "Jump if greater or equal (SF == OF)".
//
// Mnemonic        : JGE
// Supported forms : (2 forms)
//
//    * JGE rel8
//    * JGE rel32
//
func (self *Program) JGE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JGE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7d)
            m.imm1(offs(v[0]))
        })
    }
    // JGE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8d)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JGE")
    }
    return p
}

// JL performs "Jump if less (SF != OF)".
//
// Mnemonic        : JL
// Supported forms : (2 forms)
//
//    * JL rel8
//    * JL rel32
//
func (self *Program) JL(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JL rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7c)
            m.imm1(offs(v[0]))
        })
    }
    // JL rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8c)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JL")
    }
    return p
}

// JLE performs "Jump if less or equal (ZF == 1 or SF != OF)".
//
// Mnemonic        : JLE
// Supported forms : (2 forms)
//
//    * JLE rel8
//    * JLE rel32
//
func (self *Program) JLE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JLE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7e)
            m.imm1(offs(v[0]))
        })
    }
    // JLE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8e)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JLE")
    }
    return p
}

// JMP performs "Jump Unconditionally".
//
// Mnemonic        : JMP
// Supported forms : (2 forms)
//
//    * JMP rel8
//    * JMP rel32
//
func (self *Program) JMP(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JMP rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0xeb)
            m.imm1(offs(v[0]))
        })
    }
    // JMP rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0xe9)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JMP")
    }
    return p
}

// JMPQ performs "Jump Unconditionally".
//
// Mnemonic        : JMP
// Supported forms : (2 forms)
//
//    * JMPQ r64
//    * JMPQ m64
//
func (self *Program) JMPQ(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JMPQ r64
    if len(args) == 1 && isReg64(args[0]) {
        p.add(_OREX, func(m *_Encoding, v []interface{}) {
            m.rexo(0, v[0], false)
            m.emit(0xff)
            m.emit(0xe0 | lcode(v[0]))
        })
    }
    // JMPQ m64
    if len(args) == 1 && isM64(args[0]) {
        p.add(_OREX | _MRSD, func(m *_Encoding, v []interface{}) {
            m.rexo(0, addr(v[0]), false)
            m.emit(0xff)
            m.mrsd(4, addr(v[0]), 1)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JMPQ")
    }
    return p
}

// JNA performs "Jump if not above (CF == 1 or ZF == 1)".
//
// Mnemonic        : JNA
// Supported forms : (2 forms)
//
//    * JNA rel8
//    * JNA rel32
//
func (self *Program) JNA(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNA rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x76)
            m.imm1(offs(v[0]))
        })
    }
    // JNA rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x86)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNA")
    }
    return p
}

// JNAE performs "Jump if not above or equal (CF == 1)".
//
// Mnemonic        : JNAE
// Supported forms : (2 forms)
//
//    * JNAE rel8
//    * JNAE rel32
//
func (self *Program) JNAE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNAE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x72)
            m.imm1(offs(v[0]))
        })
    }
    // JNAE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x82)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNAE")
    }
    return p
}

// JNB performs "Jump if not below (CF == 0)".
//
// Mnemonic        : JNB
// Supported forms : (2 forms)
//
//    * JNB rel8
//    * JNB rel32
//
func (self *Program) JNB(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNB rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x73)
            m.imm1(offs(v[0]))
        })
    }
    // JNB rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x83)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNB")
    }
    return p
}

// JNBE performs "Jump if not below or equal (CF == 0 and ZF == 0)".
//
// Mnemonic        : JNBE
// Supported forms : (2 forms)
//
//    * JNBE rel8
//    * JNBE rel32
//
func (self *Program) JNBE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNBE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x77)
            m.imm1(offs(v[0]))
        })
    }
    // JNBE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x87)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNBE")
    }
    return p
}

// JNC performs "Jump if not carry (CF == 0)".
//
// Mnemonic        : JNC
// Supported forms : (2 forms)
//
//    * JNC rel8
//    * JNC rel32
//
func (self *Program) JNC(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNC rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x73)
            m.imm1(offs(v[0]))
        })
    }
    // JNC rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x83)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNC")
    }
    return p
}

// JNE performs "Jump if not equal (ZF == 0)".
//
// Mnemonic        : JNE
// Supported forms : (2 forms)
//
//    * JNE rel8
//    * JNE rel32
//
func (self *Program) JNE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x75)
            m.imm1(offs(v[0]))
        })
    }
    // JNE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x85)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNE")
    }
    return p
}

// JNG performs "Jump if not greater (ZF == 1 or SF != OF)".
//
// Mnemonic        : JNG
// Supported forms : (2 forms)
//
//    * JNG rel8
//    * JNG rel32
//
func (self *Program) JNG(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNG rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7e)
            m.imm1(offs(v[0]))
        })
    }
    // JNG rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8e)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNG")
    }
    return p
}

// JNGE performs "Jump if not greater or equal (SF != OF)".
//
// Mnemonic        : JNGE
// Supported forms : (2 forms)
//
//    * JNGE rel8
//    * JNGE rel32
//
func (self *Program) JNGE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNGE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7c)
            m.imm1(offs(v[0]))
        })
    }
    // JNGE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8c)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNGE")
    }
    return p
}

// JNL performs "Jump if not less (SF == OF)".
//
// Mnemonic        : JNL
// Supported forms : (2 forms)
//
//    * JNL rel8
//    * JNL rel32
//
func (self *Program) JNL(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNL rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7d)
            m.imm1(offs(v[0]))
        })
    }
    // JNL rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8d)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNL")
    }
    return p
}

// JNLE performs "Jump if not less or equal (ZF == 0 and SF == OF)".
//
// Mnemonic        : JNLE
// Supported forms : (2 forms)
//
//    * JNLE rel8
//    * JNLE rel32
//
func (self *Program) JNLE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNLE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7f)
            m.imm1(offs(v[0]))
        })
    }
    // JNLE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8f)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNLE")
    }
    return p
}

// JNO performs "Jump if not overflow (OF == 0)".
//
// Mnemonic        : JNO
// Supported forms : (2 forms)
//
//    * JNO rel8
//    * JNO rel32
//
func (self *Program) JNO(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNO rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x71)
            m.imm1(offs(v[0]))
        })
    }
    // JNO rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x81)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNO")
    }
    return p
}

// JNP performs "Jump if not parity (PF == 0)".
//
// Mnemonic        : JNP
// Supported forms : (2 forms)
//
//    * JNP rel8
//    * JNP rel32
//
func (self *Program) JNP(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNP rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7b)
            m.imm1(offs(v[0]))
        })
    }
    // JNP rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8b)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNP")
    }
    return p
}

// JNS performs "Jump if not sign (SF == 0)".
//
// Mnemonic        : JNS
// Supported forms : (2 forms)
//
//    * JNS rel8
//    * JNS rel32
//
func (self *Program) JNS(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNS rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x79)
            m.imm1(offs(v[0]))
        })
    }
    // JNS rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x89)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNS")
    }
    return p
}

// JNZ performs "Jump if not zero (ZF == 0)".
//
// Mnemonic        : JNZ
// Supported forms : (2 forms)
//
//    * JNZ rel8
//    * JNZ rel32
//
func (self *Program) JNZ(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JNZ rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x75)
            m.imm1(offs(v[0]))
        })
    }
    // JNZ rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x85)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JNZ")
    }
    return p
}

// JO performs "Jump if overflow (OF == 1)".
//
// Mnemonic        : JO
// Supported forms : (2 forms)
//
//    * JO rel8
//    * JO rel32
//
func (self *Program) JO(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JO rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x70)
            m.imm1(offs(v[0]))
        })
    }
    // JO rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x80)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JO")
    }
    return p
}

// JP performs "Jump if parity (PF == 1)".
//
// Mnemonic        : JP
// Supported forms : (2 forms)
//
//    * JP rel8
//    * JP rel32
//
func (self *Program) JP(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JP rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7a)
            m.imm1(offs(v[0]))
        })
    }
    // JP rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8a)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JP")
    }
    return p
}

// JPE performs "Jump if parity even (PF == 1)".
//
// Mnemonic        : JPE
// Supported forms : (2 forms)
//
//    * JPE rel8
//    * JPE rel32
//
func (self *Program) JPE(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JPE rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7a)
            m.imm1(offs(v[0]))
        })
    }
    // JPE rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8a)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JPE")
    }
    return p
}

// JPO performs "Jump if parity odd (PF == 0)".
//
// Mnemonic        : JPO
// Supported forms : (2 forms)
//
//    * JPO rel8
//    * JPO rel32
//
func (self *Program) JPO(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JPO rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x7b)
            m.imm1(offs(v[0]))
        })
    }
    // JPO rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x8b)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JPO")
    }
    return p
}

// JRCXZ performs "Jump if RCX register is 0".
//
// Mnemonic        : JRCXZ
// Supported forms : (1 form)
//
//    * JRCXZ rel8
//
func (self *Program) JRCXZ(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JRCXZ rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0xe3)
            m.imm1(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JRCXZ")
    }
    return p
}

// JS performs "Jump if sign (SF == 1)".
//
// Mnemonic        : JS
// Supported forms : (2 forms)
//
//    * JS rel8
//    * JS rel32
//
func (self *Program) JS(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JS rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x78)
            m.imm1(offs(v[0]))
        })
    }
    // JS rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x88)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JS")
    }
    return p
}

// JZ performs "Jump if zero (ZF == 1)".
//
// Mnemonic        : JZ
// Supported forms : (2 forms)
//
//    * JZ rel8
//    * JZ rel32
//
func (self *Program) JZ(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // JZ rel8
    if len(args) == 1 && isRel8(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x74)
            m.imm1(offs(v[0]))
        })
    }
    // JZ rel32
    if len(args) == 1 && isRel32(args[0]) {
        p.add(0, func(m *_Encoding, v []interface{}) {
            m.emit(0x0f)
            m.emit(0x84)
            m.imm4(offs(v[0]))
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for JZ")
    }
    return p
}

// VZEROUPPER performs "Zero Upper Bits of YMM Registers".
//
// Mnemonic        : VZEROUPPER
// Supported forms : (1 form)
//
//    * VZEROUPPER
//
func (self *Program) VZEROUPPER(args ...interface{}) *Instruction {
    p := self.alloc(args)
    // VZEROUPPER
    if len(args) == 0 {
        self.require(ISA_AVX)
        p.add(_VEX2, func(m *_Encoding, v []interface{}) {
            m.vex2(0, 0, nil, 0)
            m.emit(0x77)
        })
    }
    if len(p.buf) == 0 {
        panic("invalid operands for VZEROUPPER")
    }
    return p
}
