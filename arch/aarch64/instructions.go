// Code generated by "mkasm_aarch64.py", DO NOT EDIT.

package aarch64

import (
    `github.com/chenzhuoyu/iasm/asm`
)

const (
    _N_args = 4
)

// AND instruction have a 5 forms:
//
//   * AND  <Wd|WSP>, <Wn>, #<imm>
//   * AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
//   * AND  <Xd|SP>, <Xn>, #<imm>
//   * AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}
//   * AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
//
func (self *Program) AND(v0, v1, v2 interface{}, vv ...interface{}) *Instruction {
    var p *Instruction
    switch len(vv) {
        case 0  : p = self.alloc("AND", 3, Operands { v0, v1, v2 })
        case 1  : p = self.alloc("AND", 4, Operands { v0, v1, v2, vv[0] })
        default : panic("instruction AND takes 3 or 4 operands")
    }
    // AND  <Wd|WSP>, <Wn>, #<imm>
    if isWrOrWSP(v0) && isWr(v1) && isMask32(v2) {
        wd_wsp := uint32(v0.(asm.Register).ID())
        wn := uint32(v1.(asm.Register).ID())
        imm := asMaskImm(v2)
        p.setins(log_imm(0, 0, 0, (imm >> 6) & 0b111111, imm & 0b111111, wn, wd_wsp))
    }
    // AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
    if isWr(v0) && isWr(v1) && isWr(v2) && (len(vv) == 0 || isShift(vv[0])) {
        var amount uint32
        var shift uint32
        wd := uint32(v0.(asm.Register).ID())
        wn := uint32(v1.(asm.Register).ID())
        wm := uint32(v2.(asm.Register).ID())
        if len(vv) > 0 {
            shift = uint32(vv[0].(ShiftType).ShiftType())
            amount = uint32(vv[0].(Modifier).Amount())
        }
        p.setins(log_shift(0, 0, shift, 0, wm, amount, wn, wd))
    }
    // AND  <Xd|SP>, <Xn>, #<imm>
    if isXrOrSP(v0) && isXr(v1) && isMask64(v2) {
        xd_sp := uint32(v0.(asm.Register).ID())
        xn := uint32(v1.(asm.Register).ID())
        imm_1 := asMaskImm(v2)
        p.setins(log_imm(1, 0, (imm_1 >> 12) & 0b1, (imm_1 >> 6) & 0b111111, imm_1 & 0b111111, xn, xd_sp))
    }
    // AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}
    if isXr(v0) && isXr(v1) && isXr(v2) && (len(vv) == 0 || isShift(vv[0])) {
        var amount_1 uint32
        var shift uint32
        xd := uint32(v0.(asm.Register).ID())
        xn := uint32(v1.(asm.Register).ID())
        xm := uint32(v2.(asm.Register).ID())
        if len(vv) > 0 {
            shift = uint32(vv[0].(ShiftType).ShiftType())
            amount_1 = uint32(vv[0].(Modifier).Amount())
        }
        p.setins(log_shift(1, 0, shift, 0, xm, amount_1, xn, xd))
    }
    // AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
    if isVr(v0) && isVr(v1) && isVr(v2) && isSameSize(v0, v1) && isSameSize(v1, v2) {
        var t uint32
        vd := uint32(v0.(asm.Register).ID())
        switch vfmt(v0) {
            case Vec16B: t = 0b1
            case Vec8B: t = 0b0
            default: panic("aarch64: invalid vector arrangement for AND")
        }
        vn := uint32(v1.(asm.Register).ID())
        vm := uint32(v2.(asm.Register).ID())
        p.setins(asimdsame(t, 0, 0, vm, 3, vn, vd))
    }
    if !p.isvalid {
        panic("aarch64: invalid combination of operands for AND")
    }
    return p
}

// EOR instruction have a 5 forms:
//
//   * EOR  <Wd|WSP>, <Wn>, #<imm>
//   * EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
//   * EOR  <Xd|SP>, <Xn>, #<imm>
//   * EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}
//   * EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
//
func (self *Program) EOR(v0, v1, v2 interface{}, vv ...interface{}) *Instruction {
    var p *Instruction
    switch len(vv) {
        case 0  : p = self.alloc("EOR", 3, Operands { v0, v1, v2 })
        case 1  : p = self.alloc("EOR", 4, Operands { v0, v1, v2, vv[0] })
        default : panic("instruction EOR takes 3 or 4 operands")
    }
    // EOR  <Wd|WSP>, <Wn>, #<imm>
    if isWrOrWSP(v0) && isWr(v1) && isMask32(v2) {
        wd_wsp := uint32(v0.(asm.Register).ID())
        wn := uint32(v1.(asm.Register).ID())
        imm := asMaskImm(v2)
        p.setins(log_imm(0, 2, 0, (imm >> 6) & 0b111111, imm & 0b111111, wn, wd_wsp))
    }
    // EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
    if isWr(v0) && isWr(v1) && isWr(v2) && (len(vv) == 0 || isShift(vv[0])) {
        var amount uint32
        var shift uint32
        wd := uint32(v0.(asm.Register).ID())
        wn := uint32(v1.(asm.Register).ID())
        wm := uint32(v2.(asm.Register).ID())
        if len(vv) > 0 {
            shift = uint32(vv[0].(ShiftType).ShiftType())
            amount = uint32(vv[0].(Modifier).Amount())
        }
        p.setins(log_shift(0, 2, shift, 0, wm, amount, wn, wd))
    }
    // EOR  <Xd|SP>, <Xn>, #<imm>
    if isXrOrSP(v0) && isXr(v1) && isMask64(v2) {
        xd_sp := uint32(v0.(asm.Register).ID())
        xn := uint32(v1.(asm.Register).ID())
        imm_1 := asMaskImm(v2)
        p.setins(log_imm(1, 2, (imm_1 >> 12) & 0b1, (imm_1 >> 6) & 0b111111, imm_1 & 0b111111, xn, xd_sp))
    }
    // EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}
    if isXr(v0) && isXr(v1) && isXr(v2) && (len(vv) == 0 || isShift(vv[0])) {
        var amount_1 uint32
        var shift uint32
        xd := uint32(v0.(asm.Register).ID())
        xn := uint32(v1.(asm.Register).ID())
        xm := uint32(v2.(asm.Register).ID())
        if len(vv) > 0 {
            shift = uint32(vv[0].(ShiftType).ShiftType())
            amount_1 = uint32(vv[0].(Modifier).Amount())
        }
        p.setins(log_shift(1, 2, shift, 0, xm, amount_1, xn, xd))
    }
    // EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
    if isVr(v0) && isVr(v1) && isVr(v2) && isSameSize(v0, v1) && isSameSize(v1, v2) {
        var t uint32
        vd := uint32(v0.(asm.Register).ID())
        switch vfmt(v0) {
            case Vec16B: t = 0b1
            case Vec8B: t = 0b0
            default: panic("aarch64: invalid vector arrangement for EOR")
        }
        vn := uint32(v1.(asm.Register).ID())
        vm := uint32(v2.(asm.Register).ID())
        p.setins(asimdsame(t, 1, 0, vm, 3, vn, vd))
    }
    if !p.isvalid {
        panic("aarch64: invalid combination of operands for EOR")
    }
    return p
}

// ORN instruction have a 3 forms:
//
//   * ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
//   * ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}
//   * ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
//
func (self *Program) ORN(v0, v1, v2 interface{}, vv ...interface{}) *Instruction {
    var p *Instruction
    switch len(vv) {
        case 0  : p = self.alloc("ORN", 3, Operands { v0, v1, v2 })
        case 1  : p = self.alloc("ORN", 4, Operands { v0, v1, v2, vv[0] })
        default : panic("instruction ORN takes 3 or 4 operands")
    }
    // ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}
    if isWr(v0) && isWr(v1) && isWr(v2) && (len(vv) == 0 || isShift(vv[0])) {
        var amount uint32
        var shift uint32
        wd := uint32(v0.(asm.Register).ID())
        wn := uint32(v1.(asm.Register).ID())
        wm := uint32(v2.(asm.Register).ID())
        if len(vv) > 0 {
            shift = uint32(vv[0].(ShiftType).ShiftType())
            amount = uint32(vv[0].(Modifier).Amount())
        }
        p.setins(log_shift(0, 1, shift, 1, wm, amount, wn, wd))
    }
    // ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}
    if isXr(v0) && isXr(v1) && isXr(v2) && (len(vv) == 0 || isShift(vv[0])) {
        var amount_1 uint32
        var shift uint32
        xd := uint32(v0.(asm.Register).ID())
        xn := uint32(v1.(asm.Register).ID())
        xm := uint32(v2.(asm.Register).ID())
        if len(vv) > 0 {
            shift = uint32(vv[0].(ShiftType).ShiftType())
            amount_1 = uint32(vv[0].(Modifier).Amount())
        }
        p.setins(log_shift(1, 1, shift, 1, xm, amount_1, xn, xd))
    }
    // ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>
    if isVr(v0) && isVr(v1) && isVr(v2) && isSameSize(v0, v1) && isSameSize(v1, v2) {
        var t uint32
        vd := uint32(v0.(asm.Register).ID())
        switch vfmt(v0) {
            case Vec16B: t = 0b1
            case Vec8B: t = 0b0
            default: panic("aarch64: invalid vector arrangement for ORN")
        }
        vn := uint32(v1.(asm.Register).ID())
        vm := uint32(v2.(asm.Register).ID())
        p.setins(asimdsame(t, 0, 3, vm, 3, vn, vd))
    }
    if !p.isvalid {
        panic("aarch64: invalid combination of operands for ORN")
    }
    return p
}
