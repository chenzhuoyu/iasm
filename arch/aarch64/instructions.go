// Code generated by "mkasm_aarch64.py", DO NOT EDIT.

package aarch64

import (
    `github.com/chenzhuoyu/iasm/asm`
)

const (
    _N_args = 2
)

// DUP instruction have one single form:
//
//   * DUP  <Vd>.<T>, <R><n>
//
func (self *Program) DUP(v0, v1 interface{}) *Instruction {
    p := self.alloc("DUP", 2, Operands { v0, v1 })
    if isVr(v0) && isVfmt(v0, Vec8B, Vec16B, Vec4H, Vec8H, Vec2S, Vec4S, Vec2D) && isWrOrXr(v1) {
        var sa_r [3]uint32
        var sa_r__bit_mask [3]uint32
        var sa_t uint32
        var sa_t__bit_mask uint32
        sa_vd := uint32(v0.(asm.Register).ID())
        switch vfmt(v0) {
            case Vec8B: sa_t = 0b000010
            case Vec16B: sa_t = 0b000011
            case Vec4H: sa_t = 0b000100
            case Vec8H: sa_t = 0b000101
            case Vec2S: sa_t = 0b001000
            case Vec4S: sa_t = 0b001001
            case Vec2D: sa_t = 0b010001
            default: panic("aarch64: unreachable")
        }
        switch vfmt(v0) {
            case Vec8B: sa_t__bit_mask = 0b000011
            case Vec16B: sa_t__bit_mask = 0b000011
            case Vec4H: sa_t__bit_mask = 0b000111
            case Vec8H: sa_t__bit_mask = 0b000111
            case Vec2S: sa_t__bit_mask = 0b001111
            case Vec4S: sa_t__bit_mask = 0b001111
            case Vec2D: sa_t__bit_mask = 0b011111
            default: panic("aarch64: unreachable")
        }
        sa_n := uint32(v1.(asm.Register).ID())
        switch true {
            case isWr(v1): sa_r = [3]uint32{0b00100, 0b00010, 0b00001}
            case isXr(v1): sa_r = [3]uint32{0b01000}
            default: panic("aarch64: unreachable")
        }
        switch true {
            case isWr(v1): sa_r__bit_mask = [3]uint32{0b00111, 0b00011, 0b00001}
            case isXr(v1): sa_r__bit_mask = [3]uint32{0b01111}
            default: panic("aarch64: unreachable")
        }
        if sa_r & ((sa_t__bit_mask >> 1) & 0x1f) != (sa_t >> 1) & 0x1f {
            panic("aarch64: invalid combination of operands for DUP")
        }
        return p.setins(asimdins(sa_t & 0x1, 0, (sa_t >> 1) & 0x1f, 1, sa_n, sa_vd))
    }
    p.Free()
    panic("aarch64: invalid combination of operands for DUP")
}
