// Code generated by "mkasm_aarch64.py", DO NOT EDIT.

package aarch64

type (
    _InstructionEncoder func(*Program, ...interface{}) *Instruction
)

// Instructions maps all the instruction name to it's encoder function.
var Instructions = map[string]_InstructionEncoder {
    "ABS"        : __asm_proxy_ABS__,
    "ADC"        : __asm_proxy_ADC__,
    "ADCS"       : __asm_proxy_ADCS__,
    "ADD"        : __asm_proxy_ADD__,
    "ADDG"       : __asm_proxy_ADDG__,
    "ADDHN"      : __asm_proxy_ADDHN__,
    "ADDHN2"     : __asm_proxy_ADDHN2__,
    "ADDP"       : __asm_proxy_ADDP__,
    "ADDS"       : __asm_proxy_ADDS__,
    "ADDV"       : __asm_proxy_ADDV__,
    "ADR"        : __asm_proxy_ADR__,
    "ADRP"       : __asm_proxy_ADRP__,
    "AESD"       : __asm_proxy_AESD__,
    "AESE"       : __asm_proxy_AESE__,
    "AESIMC"     : __asm_proxy_AESIMC__,
    "AESMC"      : __asm_proxy_AESMC__,
    "AND"        : __asm_proxy_AND__,
    "ANDS"       : __asm_proxy_ANDS__,
    "ASR"        : __asm_proxy_ASR__,
    "ASRV"       : __asm_proxy_ASRV__,
    "AT"         : __asm_proxy_AT__,
    "AUTDA"      : __asm_proxy_AUTDA__,
    "AUTDB"      : __asm_proxy_AUTDB__,
    "AUTDZA"     : __asm_proxy_AUTDZA__,
    "AUTDZB"     : __asm_proxy_AUTDZB__,
    "AUTIA"      : __asm_proxy_AUTIA__,
    "AUTIA1716"  : __asm_proxy_AUTIA1716__,
    "AUTIASP"    : __asm_proxy_AUTIASP__,
    "AUTIAZ"     : __asm_proxy_AUTIAZ__,
    "AUTIB"      : __asm_proxy_AUTIB__,
    "AUTIB1716"  : __asm_proxy_AUTIB1716__,
    "AUTIBSP"    : __asm_proxy_AUTIBSP__,
    "AUTIBZ"     : __asm_proxy_AUTIBZ__,
    "AUTIZA"     : __asm_proxy_AUTIZA__,
    "AUTIZB"     : __asm_proxy_AUTIZB__,
    "AXFLAG"     : __asm_proxy_AXFLAG__,
    "B"          : __asm_proxy_B__,
    "BEQ"        : __asm_proxy_BEQ__,
    "BNE"        : __asm_proxy_BNE__,
    "BCS"        : __asm_proxy_BCS__,
    "BHS"        : __asm_proxy_BHS__,
    "BCC"        : __asm_proxy_BCC__,
    "BLO"        : __asm_proxy_BLO__,
    "BMI"        : __asm_proxy_BMI__,
    "BPL"        : __asm_proxy_BPL__,
    "BVS"        : __asm_proxy_BVS__,
    "BVC"        : __asm_proxy_BVC__,
    "BHI"        : __asm_proxy_BHI__,
    "BLS"        : __asm_proxy_BLS__,
    "BGE"        : __asm_proxy_BGE__,
    "BLT"        : __asm_proxy_BLT__,
    "BGT"        : __asm_proxy_BGT__,
    "BLE"        : __asm_proxy_BLE__,
    "BAL"        : __asm_proxy_BAL__,
    "BCEQ"       : __asm_proxy_BCEQ__,
    "BCNE"       : __asm_proxy_BCNE__,
    "BCCS"       : __asm_proxy_BCCS__,
    "BCHS"       : __asm_proxy_BCHS__,
    "BCCC"       : __asm_proxy_BCCC__,
    "BCLO"       : __asm_proxy_BCLO__,
    "BCMI"       : __asm_proxy_BCMI__,
    "BCPL"       : __asm_proxy_BCPL__,
    "BCVS"       : __asm_proxy_BCVS__,
    "BCVC"       : __asm_proxy_BCVC__,
    "BCHI"       : __asm_proxy_BCHI__,
    "BCLS"       : __asm_proxy_BCLS__,
    "BCGE"       : __asm_proxy_BCGE__,
    "BCLT"       : __asm_proxy_BCLT__,
    "BCGT"       : __asm_proxy_BCGT__,
    "BCLE"       : __asm_proxy_BCLE__,
    "BCAL"       : __asm_proxy_BCAL__,
    "BCAX"       : __asm_proxy_BCAX__,
    "BFC"        : __asm_proxy_BFC__,
    "BFCVT"      : __asm_proxy_BFCVT__,
    "BFCVTN"     : __asm_proxy_BFCVTN__,
    "BFCVTN2"    : __asm_proxy_BFCVTN2__,
    "BFDOT"      : __asm_proxy_BFDOT__,
    "BFI"        : __asm_proxy_BFI__,
    "BFM"        : __asm_proxy_BFM__,
    "BFMLALB"    : __asm_proxy_BFMLALB__,
    "BFMLALT"    : __asm_proxy_BFMLALT__,
    "BFMMLA"     : __asm_proxy_BFMMLA__,
    "BFXIL"      : __asm_proxy_BFXIL__,
    "BIC"        : __asm_proxy_BIC__,
    "BICS"       : __asm_proxy_BICS__,
    "BIF"        : __asm_proxy_BIF__,
    "BIT"        : __asm_proxy_BIT__,
    "BL"         : __asm_proxy_BL__,
    "BLR"        : __asm_proxy_BLR__,
    "BLRAA"      : __asm_proxy_BLRAA__,
    "BLRAAZ"     : __asm_proxy_BLRAAZ__,
    "BLRAB"      : __asm_proxy_BLRAB__,
    "BLRABZ"     : __asm_proxy_BLRABZ__,
    "BR"         : __asm_proxy_BR__,
    "BRAA"       : __asm_proxy_BRAA__,
    "BRAAZ"      : __asm_proxy_BRAAZ__,
    "BRAB"       : __asm_proxy_BRAB__,
    "BRABZ"      : __asm_proxy_BRABZ__,
    "BRB"        : __asm_proxy_BRB__,
    "BRK"        : __asm_proxy_BRK__,
    "BSL"        : __asm_proxy_BSL__,
    "BTI"        : __asm_proxy_BTI__,
    "CAS"        : __asm_proxy_CAS__,
    "CASA"       : __asm_proxy_CASA__,
    "CASAB"      : __asm_proxy_CASAB__,
    "CASAH"      : __asm_proxy_CASAH__,
    "CASAL"      : __asm_proxy_CASAL__,
    "CASALB"     : __asm_proxy_CASALB__,
    "CASALH"     : __asm_proxy_CASALH__,
    "CASB"       : __asm_proxy_CASB__,
    "CASH"       : __asm_proxy_CASH__,
    "CASL"       : __asm_proxy_CASL__,
    "CASLB"      : __asm_proxy_CASLB__,
    "CASLH"      : __asm_proxy_CASLH__,
    "CASP"       : __asm_proxy_CASP__,
    "CASPA"      : __asm_proxy_CASPA__,
    "CASPAL"     : __asm_proxy_CASPAL__,
    "CASPL"      : __asm_proxy_CASPL__,
    "CBNZ"       : __asm_proxy_CBNZ__,
    "CBZ"        : __asm_proxy_CBZ__,
    "CCMN"       : __asm_proxy_CCMN__,
    "CCMP"       : __asm_proxy_CCMP__,
    "CFINV"      : __asm_proxy_CFINV__,
    "CFP"        : __asm_proxy_CFP__,
    "CHKFEAT"    : __asm_proxy_CHKFEAT__,
    "CINC"       : __asm_proxy_CINC__,
    "CINV"       : __asm_proxy_CINV__,
    "CLRBHB"     : __asm_proxy_CLRBHB__,
    "CLREX"      : __asm_proxy_CLREX__,
    "CLS"        : __asm_proxy_CLS__,
    "CLZ"        : __asm_proxy_CLZ__,
    "CMEQ"       : __asm_proxy_CMEQ__,
    "CMGE"       : __asm_proxy_CMGE__,
    "CMGT"       : __asm_proxy_CMGT__,
    "CMHI"       : __asm_proxy_CMHI__,
    "CMHS"       : __asm_proxy_CMHS__,
    "CMLE"       : __asm_proxy_CMLE__,
    "CMLT"       : __asm_proxy_CMLT__,
    "CMN"        : __asm_proxy_CMN__,
    "CMP"        : __asm_proxy_CMP__,
    "CMPP"       : __asm_proxy_CMPP__,
    "CMTST"      : __asm_proxy_CMTST__,
    "CNEG"       : __asm_proxy_CNEG__,
    "CNT"        : __asm_proxy_CNT__,
    "COSP"       : __asm_proxy_COSP__,
    "CPP"        : __asm_proxy_CPP__,
    "CPYE"       : __asm_proxy_CPYE__,
    "CPYEN"      : __asm_proxy_CPYEN__,
    "CPYERN"     : __asm_proxy_CPYERN__,
    "CPYERT"     : __asm_proxy_CPYERT__,
    "CPYERTN"    : __asm_proxy_CPYERTN__,
    "CPYERTRN"   : __asm_proxy_CPYERTRN__,
    "CPYERTWN"   : __asm_proxy_CPYERTWN__,
    "CPYET"      : __asm_proxy_CPYET__,
    "CPYETN"     : __asm_proxy_CPYETN__,
    "CPYETRN"    : __asm_proxy_CPYETRN__,
    "CPYETWN"    : __asm_proxy_CPYETWN__,
    "CPYEWN"     : __asm_proxy_CPYEWN__,
    "CPYEWT"     : __asm_proxy_CPYEWT__,
    "CPYEWTN"    : __asm_proxy_CPYEWTN__,
    "CPYEWTRN"   : __asm_proxy_CPYEWTRN__,
    "CPYEWTWN"   : __asm_proxy_CPYEWTWN__,
    "CPYFE"      : __asm_proxy_CPYFE__,
    "CPYFEN"     : __asm_proxy_CPYFEN__,
    "CPYFERN"    : __asm_proxy_CPYFERN__,
    "CPYFERT"    : __asm_proxy_CPYFERT__,
    "CPYFERTN"   : __asm_proxy_CPYFERTN__,
    "CPYFERTRN"  : __asm_proxy_CPYFERTRN__,
    "CPYFERTWN"  : __asm_proxy_CPYFERTWN__,
    "CPYFET"     : __asm_proxy_CPYFET__,
    "CPYFETN"    : __asm_proxy_CPYFETN__,
    "CPYFETRN"   : __asm_proxy_CPYFETRN__,
    "CPYFETWN"   : __asm_proxy_CPYFETWN__,
    "CPYFEWN"    : __asm_proxy_CPYFEWN__,
    "CPYFEWT"    : __asm_proxy_CPYFEWT__,
    "CPYFEWTN"   : __asm_proxy_CPYFEWTN__,
    "CPYFEWTRN"  : __asm_proxy_CPYFEWTRN__,
    "CPYFEWTWN"  : __asm_proxy_CPYFEWTWN__,
    "CPYFM"      : __asm_proxy_CPYFM__,
    "CPYFMN"     : __asm_proxy_CPYFMN__,
    "CPYFMRN"    : __asm_proxy_CPYFMRN__,
    "CPYFMRT"    : __asm_proxy_CPYFMRT__,
    "CPYFMRTN"   : __asm_proxy_CPYFMRTN__,
    "CPYFMRTRN"  : __asm_proxy_CPYFMRTRN__,
    "CPYFMRTWN"  : __asm_proxy_CPYFMRTWN__,
    "CPYFMT"     : __asm_proxy_CPYFMT__,
    "CPYFMTN"    : __asm_proxy_CPYFMTN__,
    "CPYFMTRN"   : __asm_proxy_CPYFMTRN__,
    "CPYFMTWN"   : __asm_proxy_CPYFMTWN__,
    "CPYFMWN"    : __asm_proxy_CPYFMWN__,
    "CPYFMWT"    : __asm_proxy_CPYFMWT__,
    "CPYFMWTN"   : __asm_proxy_CPYFMWTN__,
    "CPYFMWTRN"  : __asm_proxy_CPYFMWTRN__,
    "CPYFMWTWN"  : __asm_proxy_CPYFMWTWN__,
    "CPYFP"      : __asm_proxy_CPYFP__,
    "CPYFPN"     : __asm_proxy_CPYFPN__,
    "CPYFPRN"    : __asm_proxy_CPYFPRN__,
    "CPYFPRT"    : __asm_proxy_CPYFPRT__,
    "CPYFPRTN"   : __asm_proxy_CPYFPRTN__,
    "CPYFPRTRN"  : __asm_proxy_CPYFPRTRN__,
    "CPYFPRTWN"  : __asm_proxy_CPYFPRTWN__,
    "CPYFPT"     : __asm_proxy_CPYFPT__,
    "CPYFPTN"    : __asm_proxy_CPYFPTN__,
    "CPYFPTRN"   : __asm_proxy_CPYFPTRN__,
    "CPYFPTWN"   : __asm_proxy_CPYFPTWN__,
    "CPYFPWN"    : __asm_proxy_CPYFPWN__,
    "CPYFPWT"    : __asm_proxy_CPYFPWT__,
    "CPYFPWTN"   : __asm_proxy_CPYFPWTN__,
    "CPYFPWTRN"  : __asm_proxy_CPYFPWTRN__,
    "CPYFPWTWN"  : __asm_proxy_CPYFPWTWN__,
    "CPYM"       : __asm_proxy_CPYM__,
    "CPYMN"      : __asm_proxy_CPYMN__,
    "CPYMRN"     : __asm_proxy_CPYMRN__,
    "CPYMRT"     : __asm_proxy_CPYMRT__,
    "CPYMRTN"    : __asm_proxy_CPYMRTN__,
    "CPYMRTRN"   : __asm_proxy_CPYMRTRN__,
    "CPYMRTWN"   : __asm_proxy_CPYMRTWN__,
    "CPYMT"      : __asm_proxy_CPYMT__,
    "CPYMTN"     : __asm_proxy_CPYMTN__,
    "CPYMTRN"    : __asm_proxy_CPYMTRN__,
    "CPYMTWN"    : __asm_proxy_CPYMTWN__,
    "CPYMWN"     : __asm_proxy_CPYMWN__,
    "CPYMWT"     : __asm_proxy_CPYMWT__,
    "CPYMWTN"    : __asm_proxy_CPYMWTN__,
    "CPYMWTRN"   : __asm_proxy_CPYMWTRN__,
    "CPYMWTWN"   : __asm_proxy_CPYMWTWN__,
    "CPYP"       : __asm_proxy_CPYP__,
    "CPYPN"      : __asm_proxy_CPYPN__,
    "CPYPRN"     : __asm_proxy_CPYPRN__,
    "CPYPRT"     : __asm_proxy_CPYPRT__,
    "CPYPRTN"    : __asm_proxy_CPYPRTN__,
    "CPYPRTRN"   : __asm_proxy_CPYPRTRN__,
    "CPYPRTWN"   : __asm_proxy_CPYPRTWN__,
    "CPYPT"      : __asm_proxy_CPYPT__,
    "CPYPTN"     : __asm_proxy_CPYPTN__,
    "CPYPTRN"    : __asm_proxy_CPYPTRN__,
    "CPYPTWN"    : __asm_proxy_CPYPTWN__,
    "CPYPWN"     : __asm_proxy_CPYPWN__,
    "CPYPWT"     : __asm_proxy_CPYPWT__,
    "CPYPWTN"    : __asm_proxy_CPYPWTN__,
    "CPYPWTRN"   : __asm_proxy_CPYPWTRN__,
    "CPYPWTWN"   : __asm_proxy_CPYPWTWN__,
    "CRC32B"     : __asm_proxy_CRC32B__,
    "CRC32CB"    : __asm_proxy_CRC32CB__,
    "CRC32CH"    : __asm_proxy_CRC32CH__,
    "CRC32CW"    : __asm_proxy_CRC32CW__,
    "CRC32CX"    : __asm_proxy_CRC32CX__,
    "CRC32H"     : __asm_proxy_CRC32H__,
    "CRC32W"     : __asm_proxy_CRC32W__,
    "CRC32X"     : __asm_proxy_CRC32X__,
    "CSDB"       : __asm_proxy_CSDB__,
    "CSEL"       : __asm_proxy_CSEL__,
    "CSET"       : __asm_proxy_CSET__,
    "CSETM"      : __asm_proxy_CSETM__,
    "CSINC"      : __asm_proxy_CSINC__,
    "CSINV"      : __asm_proxy_CSINV__,
    "CSNEG"      : __asm_proxy_CSNEG__,
    "CTZ"        : __asm_proxy_CTZ__,
    "DC"         : __asm_proxy_DC__,
    "DCPS1"      : __asm_proxy_DCPS1__,
    "DCPS2"      : __asm_proxy_DCPS2__,
    "DCPS3"      : __asm_proxy_DCPS3__,
    "DGH"        : __asm_proxy_DGH__,
    "DMB"        : __asm_proxy_DMB__,
    "DRPS"       : __asm_proxy_DRPS__,
    "DSB"        : __asm_proxy_DSB__,
    "DUP"        : __asm_proxy_DUP__,
    "DVP"        : __asm_proxy_DVP__,
    "EON"        : __asm_proxy_EON__,
    "EOR"        : __asm_proxy_EOR__,
    "EOR3"       : __asm_proxy_EOR3__,
    "ERET"       : __asm_proxy_ERET__,
    "ERETAA"     : __asm_proxy_ERETAA__,
    "ERETAB"     : __asm_proxy_ERETAB__,
    "ESB"        : __asm_proxy_ESB__,
    "EXT"        : __asm_proxy_EXT__,
    "EXTR"       : __asm_proxy_EXTR__,
    "FABD"       : __asm_proxy_FABD__,
    "FABS"       : __asm_proxy_FABS__,
    "FACGE"      : __asm_proxy_FACGE__,
    "FACGT"      : __asm_proxy_FACGT__,
    "FADD"       : __asm_proxy_FADD__,
    "FADDP"      : __asm_proxy_FADDP__,
    "FCADD"      : __asm_proxy_FCADD__,
    "FCCMP"      : __asm_proxy_FCCMP__,
    "FCCMPE"     : __asm_proxy_FCCMPE__,
    "FCMEQ"      : __asm_proxy_FCMEQ__,
    "FCMGE"      : __asm_proxy_FCMGE__,
    "FCMGT"      : __asm_proxy_FCMGT__,
    "FCMLA"      : __asm_proxy_FCMLA__,
    "FCMLE"      : __asm_proxy_FCMLE__,
    "FCMLT"      : __asm_proxy_FCMLT__,
    "FCMP"       : __asm_proxy_FCMP__,
    "FCMPE"      : __asm_proxy_FCMPE__,
    "FCSEL"      : __asm_proxy_FCSEL__,
    "FCVT"       : __asm_proxy_FCVT__,
    "FCVTAS"     : __asm_proxy_FCVTAS__,
    "FCVTAU"     : __asm_proxy_FCVTAU__,
    "FCVTL"      : __asm_proxy_FCVTL__,
    "FCVTL2"     : __asm_proxy_FCVTL2__,
    "FCVTMS"     : __asm_proxy_FCVTMS__,
    "FCVTMU"     : __asm_proxy_FCVTMU__,
    "FCVTN"      : __asm_proxy_FCVTN__,
    "FCVTN2"     : __asm_proxy_FCVTN2__,
    "FCVTNS"     : __asm_proxy_FCVTNS__,
    "FCVTNU"     : __asm_proxy_FCVTNU__,
    "FCVTPS"     : __asm_proxy_FCVTPS__,
    "FCVTPU"     : __asm_proxy_FCVTPU__,
    "FCVTXN"     : __asm_proxy_FCVTXN__,
    "FCVTXN2"    : __asm_proxy_FCVTXN2__,
    "FCVTZS"     : __asm_proxy_FCVTZS__,
    "FCVTZU"     : __asm_proxy_FCVTZU__,
    "FDIV"       : __asm_proxy_FDIV__,
    "FJCVTZS"    : __asm_proxy_FJCVTZS__,
    "FMADD"      : __asm_proxy_FMADD__,
    "FMAX"       : __asm_proxy_FMAX__,
    "FMAXNM"     : __asm_proxy_FMAXNM__,
    "FMAXNMP"    : __asm_proxy_FMAXNMP__,
    "FMAXNMV"    : __asm_proxy_FMAXNMV__,
    "FMAXP"      : __asm_proxy_FMAXP__,
    "FMAXV"      : __asm_proxy_FMAXV__,
    "FMIN"       : __asm_proxy_FMIN__,
    "FMINNM"     : __asm_proxy_FMINNM__,
    "FMINNMP"    : __asm_proxy_FMINNMP__,
    "FMINNMV"    : __asm_proxy_FMINNMV__,
    "FMINP"      : __asm_proxy_FMINP__,
    "FMINV"      : __asm_proxy_FMINV__,
    "FMLA"       : __asm_proxy_FMLA__,
    "FMLAL"      : __asm_proxy_FMLAL__,
    "FMLAL2"     : __asm_proxy_FMLAL2__,
    "FMLS"       : __asm_proxy_FMLS__,
    "FMLSL"      : __asm_proxy_FMLSL__,
    "FMLSL2"     : __asm_proxy_FMLSL2__,
    "FMOV"       : __asm_proxy_FMOV__,
    "FMSUB"      : __asm_proxy_FMSUB__,
    "FMUL"       : __asm_proxy_FMUL__,
    "FMULX"      : __asm_proxy_FMULX__,
    "FNEG"       : __asm_proxy_FNEG__,
    "FNMADD"     : __asm_proxy_FNMADD__,
    "FNMSUB"     : __asm_proxy_FNMSUB__,
    "FNMUL"      : __asm_proxy_FNMUL__,
    "FRECPE"     : __asm_proxy_FRECPE__,
    "FRECPS"     : __asm_proxy_FRECPS__,
    "FRECPX"     : __asm_proxy_FRECPX__,
    "FRINT32X"   : __asm_proxy_FRINT32X__,
    "FRINT32Z"   : __asm_proxy_FRINT32Z__,
    "FRINT64X"   : __asm_proxy_FRINT64X__,
    "FRINT64Z"   : __asm_proxy_FRINT64Z__,
    "FRINTA"     : __asm_proxy_FRINTA__,
    "FRINTI"     : __asm_proxy_FRINTI__,
    "FRINTM"     : __asm_proxy_FRINTM__,
    "FRINTN"     : __asm_proxy_FRINTN__,
    "FRINTP"     : __asm_proxy_FRINTP__,
    "FRINTX"     : __asm_proxy_FRINTX__,
    "FRINTZ"     : __asm_proxy_FRINTZ__,
    "FRSQRTE"    : __asm_proxy_FRSQRTE__,
    "FRSQRTS"    : __asm_proxy_FRSQRTS__,
    "FSQRT"      : __asm_proxy_FSQRT__,
    "FSUB"       : __asm_proxy_FSUB__,
    "GCSB"       : __asm_proxy_GCSB__,
    "GCSPOPCX"   : __asm_proxy_GCSPOPCX__,
    "GCSPOPM"    : __asm_proxy_GCSPOPM__,
    "GCSPOPX"    : __asm_proxy_GCSPOPX__,
    "GCSPUSHM"   : __asm_proxy_GCSPUSHM__,
    "GCSPUSHX"   : __asm_proxy_GCSPUSHX__,
    "GCSSS1"     : __asm_proxy_GCSSS1__,
    "GCSSS2"     : __asm_proxy_GCSSS2__,
    "GCSSTR"     : __asm_proxy_GCSSTR__,
    "GCSSTTR"    : __asm_proxy_GCSSTTR__,
    "GMI"        : __asm_proxy_GMI__,
    "HINT"       : __asm_proxy_HINT__,
    "HLT"        : __asm_proxy_HLT__,
    "HVC"        : __asm_proxy_HVC__,
    "IC"         : __asm_proxy_IC__,
    "INS"        : __asm_proxy_INS__,
    "IRG"        : __asm_proxy_IRG__,
    "ISB"        : __asm_proxy_ISB__,
    "LD1"        : __asm_proxy_LD1__,
    "LD1R"       : __asm_proxy_LD1R__,
    "LD2"        : __asm_proxy_LD2__,
    "LD2R"       : __asm_proxy_LD2R__,
    "LD3"        : __asm_proxy_LD3__,
    "LD3R"       : __asm_proxy_LD3R__,
    "LD4"        : __asm_proxy_LD4__,
    "LD4R"       : __asm_proxy_LD4R__,
    "LD64B"      : __asm_proxy_LD64B__,
    "LDADD"      : __asm_proxy_LDADD__,
    "LDADDA"     : __asm_proxy_LDADDA__,
    "LDADDAB"    : __asm_proxy_LDADDAB__,
    "LDADDAH"    : __asm_proxy_LDADDAH__,
    "LDADDAL"    : __asm_proxy_LDADDAL__,
    "LDADDALB"   : __asm_proxy_LDADDALB__,
    "LDADDALH"   : __asm_proxy_LDADDALH__,
    "LDADDB"     : __asm_proxy_LDADDB__,
    "LDADDH"     : __asm_proxy_LDADDH__,
    "LDADDL"     : __asm_proxy_LDADDL__,
    "LDADDLB"    : __asm_proxy_LDADDLB__,
    "LDADDLH"    : __asm_proxy_LDADDLH__,
    "LDAP1"      : __asm_proxy_LDAP1__,
    "LDAPR"      : __asm_proxy_LDAPR__,
    "LDAPRB"     : __asm_proxy_LDAPRB__,
    "LDAPRH"     : __asm_proxy_LDAPRH__,
    "LDAPUR"     : __asm_proxy_LDAPUR__,
    "LDAPURB"    : __asm_proxy_LDAPURB__,
    "LDAPURH"    : __asm_proxy_LDAPURH__,
    "LDAPURSB"   : __asm_proxy_LDAPURSB__,
    "LDAPURSH"   : __asm_proxy_LDAPURSH__,
    "LDAPURSW"   : __asm_proxy_LDAPURSW__,
    "LDAR"       : __asm_proxy_LDAR__,
    "LDARB"      : __asm_proxy_LDARB__,
    "LDARH"      : __asm_proxy_LDARH__,
    "LDAXP"      : __asm_proxy_LDAXP__,
    "LDAXR"      : __asm_proxy_LDAXR__,
    "LDAXRB"     : __asm_proxy_LDAXRB__,
    "LDAXRH"     : __asm_proxy_LDAXRH__,
    "LDCLR"      : __asm_proxy_LDCLR__,
    "LDCLRA"     : __asm_proxy_LDCLRA__,
    "LDCLRAB"    : __asm_proxy_LDCLRAB__,
    "LDCLRAH"    : __asm_proxy_LDCLRAH__,
    "LDCLRAL"    : __asm_proxy_LDCLRAL__,
    "LDCLRALB"   : __asm_proxy_LDCLRALB__,
    "LDCLRALH"   : __asm_proxy_LDCLRALH__,
    "LDCLRB"     : __asm_proxy_LDCLRB__,
    "LDCLRH"     : __asm_proxy_LDCLRH__,
    "LDCLRL"     : __asm_proxy_LDCLRL__,
    "LDCLRLB"    : __asm_proxy_LDCLRLB__,
    "LDCLRLH"    : __asm_proxy_LDCLRLH__,
    "LDCLRP"     : __asm_proxy_LDCLRP__,
    "LDCLRPA"    : __asm_proxy_LDCLRPA__,
    "LDCLRPAL"   : __asm_proxy_LDCLRPAL__,
    "LDCLRPL"    : __asm_proxy_LDCLRPL__,
    "LDEOR"      : __asm_proxy_LDEOR__,
    "LDEORA"     : __asm_proxy_LDEORA__,
    "LDEORAB"    : __asm_proxy_LDEORAB__,
    "LDEORAH"    : __asm_proxy_LDEORAH__,
    "LDEORAL"    : __asm_proxy_LDEORAL__,
    "LDEORALB"   : __asm_proxy_LDEORALB__,
    "LDEORALH"   : __asm_proxy_LDEORALH__,
    "LDEORB"     : __asm_proxy_LDEORB__,
    "LDEORH"     : __asm_proxy_LDEORH__,
    "LDEORL"     : __asm_proxy_LDEORL__,
    "LDEORLB"    : __asm_proxy_LDEORLB__,
    "LDEORLH"    : __asm_proxy_LDEORLH__,
    "LDG"        : __asm_proxy_LDG__,
    "LDGM"       : __asm_proxy_LDGM__,
    "LDIAPP"     : __asm_proxy_LDIAPP__,
    "LDLAR"      : __asm_proxy_LDLAR__,
    "LDLARB"     : __asm_proxy_LDLARB__,
    "LDLARH"     : __asm_proxy_LDLARH__,
    "LDNP"       : __asm_proxy_LDNP__,
    "LDP"        : __asm_proxy_LDP__,
    "LDPSW"      : __asm_proxy_LDPSW__,
    "LDR"        : __asm_proxy_LDR__,
    "LDRAA"      : __asm_proxy_LDRAA__,
    "LDRAB"      : __asm_proxy_LDRAB__,
    "LDRB"       : __asm_proxy_LDRB__,
    "LDRH"       : __asm_proxy_LDRH__,
    "LDRSB"      : __asm_proxy_LDRSB__,
    "LDRSH"      : __asm_proxy_LDRSH__,
    "LDRSW"      : __asm_proxy_LDRSW__,
    "LDSET"      : __asm_proxy_LDSET__,
    "LDSETA"     : __asm_proxy_LDSETA__,
    "LDSETAB"    : __asm_proxy_LDSETAB__,
    "LDSETAH"    : __asm_proxy_LDSETAH__,
    "LDSETAL"    : __asm_proxy_LDSETAL__,
    "LDSETALB"   : __asm_proxy_LDSETALB__,
    "LDSETALH"   : __asm_proxy_LDSETALH__,
    "LDSETB"     : __asm_proxy_LDSETB__,
    "LDSETH"     : __asm_proxy_LDSETH__,
    "LDSETL"     : __asm_proxy_LDSETL__,
    "LDSETLB"    : __asm_proxy_LDSETLB__,
    "LDSETLH"    : __asm_proxy_LDSETLH__,
    "LDSETP"     : __asm_proxy_LDSETP__,
    "LDSETPA"    : __asm_proxy_LDSETPA__,
    "LDSETPAL"   : __asm_proxy_LDSETPAL__,
    "LDSETPL"    : __asm_proxy_LDSETPL__,
    "LDSMAX"     : __asm_proxy_LDSMAX__,
    "LDSMAXA"    : __asm_proxy_LDSMAXA__,
    "LDSMAXAB"   : __asm_proxy_LDSMAXAB__,
    "LDSMAXAH"   : __asm_proxy_LDSMAXAH__,
    "LDSMAXAL"   : __asm_proxy_LDSMAXAL__,
    "LDSMAXALB"  : __asm_proxy_LDSMAXALB__,
    "LDSMAXALH"  : __asm_proxy_LDSMAXALH__,
    "LDSMAXB"    : __asm_proxy_LDSMAXB__,
    "LDSMAXH"    : __asm_proxy_LDSMAXH__,
    "LDSMAXL"    : __asm_proxy_LDSMAXL__,
    "LDSMAXLB"   : __asm_proxy_LDSMAXLB__,
    "LDSMAXLH"   : __asm_proxy_LDSMAXLH__,
    "LDSMIN"     : __asm_proxy_LDSMIN__,
    "LDSMINA"    : __asm_proxy_LDSMINA__,
    "LDSMINAB"   : __asm_proxy_LDSMINAB__,
    "LDSMINAH"   : __asm_proxy_LDSMINAH__,
    "LDSMINAL"   : __asm_proxy_LDSMINAL__,
    "LDSMINALB"  : __asm_proxy_LDSMINALB__,
    "LDSMINALH"  : __asm_proxy_LDSMINALH__,
    "LDSMINB"    : __asm_proxy_LDSMINB__,
    "LDSMINH"    : __asm_proxy_LDSMINH__,
    "LDSMINL"    : __asm_proxy_LDSMINL__,
    "LDSMINLB"   : __asm_proxy_LDSMINLB__,
    "LDSMINLH"   : __asm_proxy_LDSMINLH__,
    "LDTR"       : __asm_proxy_LDTR__,
    "LDTRB"      : __asm_proxy_LDTRB__,
    "LDTRH"      : __asm_proxy_LDTRH__,
    "LDTRSB"     : __asm_proxy_LDTRSB__,
    "LDTRSH"     : __asm_proxy_LDTRSH__,
    "LDTRSW"     : __asm_proxy_LDTRSW__,
    "LDUMAX"     : __asm_proxy_LDUMAX__,
    "LDUMAXA"    : __asm_proxy_LDUMAXA__,
    "LDUMAXAB"   : __asm_proxy_LDUMAXAB__,
    "LDUMAXAH"   : __asm_proxy_LDUMAXAH__,
    "LDUMAXAL"   : __asm_proxy_LDUMAXAL__,
    "LDUMAXALB"  : __asm_proxy_LDUMAXALB__,
    "LDUMAXALH"  : __asm_proxy_LDUMAXALH__,
    "LDUMAXB"    : __asm_proxy_LDUMAXB__,
    "LDUMAXH"    : __asm_proxy_LDUMAXH__,
    "LDUMAXL"    : __asm_proxy_LDUMAXL__,
    "LDUMAXLB"   : __asm_proxy_LDUMAXLB__,
    "LDUMAXLH"   : __asm_proxy_LDUMAXLH__,
    "LDUMIN"     : __asm_proxy_LDUMIN__,
    "LDUMINA"    : __asm_proxy_LDUMINA__,
    "LDUMINAB"   : __asm_proxy_LDUMINAB__,
    "LDUMINAH"   : __asm_proxy_LDUMINAH__,
    "LDUMINAL"   : __asm_proxy_LDUMINAL__,
    "LDUMINALB"  : __asm_proxy_LDUMINALB__,
    "LDUMINALH"  : __asm_proxy_LDUMINALH__,
    "LDUMINB"    : __asm_proxy_LDUMINB__,
    "LDUMINH"    : __asm_proxy_LDUMINH__,
    "LDUMINL"    : __asm_proxy_LDUMINL__,
    "LDUMINLB"   : __asm_proxy_LDUMINLB__,
    "LDUMINLH"   : __asm_proxy_LDUMINLH__,
    "LDUR"       : __asm_proxy_LDUR__,
    "LDURB"      : __asm_proxy_LDURB__,
    "LDURH"      : __asm_proxy_LDURH__,
    "LDURSB"     : __asm_proxy_LDURSB__,
    "LDURSH"     : __asm_proxy_LDURSH__,
    "LDURSW"     : __asm_proxy_LDURSW__,
    "LDXP"       : __asm_proxy_LDXP__,
    "LDXR"       : __asm_proxy_LDXR__,
    "LDXRB"      : __asm_proxy_LDXRB__,
    "LDXRH"      : __asm_proxy_LDXRH__,
    "LSL"        : __asm_proxy_LSL__,
    "LSLV"       : __asm_proxy_LSLV__,
    "LSR"        : __asm_proxy_LSR__,
    "LSRV"       : __asm_proxy_LSRV__,
    "MADD"       : __asm_proxy_MADD__,
    "MLA"        : __asm_proxy_MLA__,
    "MLS"        : __asm_proxy_MLS__,
    "MNEG"       : __asm_proxy_MNEG__,
    "MOV"        : __asm_proxy_MOV__,
    "MOVI"       : __asm_proxy_MOVI__,
    "MOVK"       : __asm_proxy_MOVK__,
    "MOVN"       : __asm_proxy_MOVN__,
    "MOVZ"       : __asm_proxy_MOVZ__,
    "MRRS"       : __asm_proxy_MRRS__,
    "MRS"        : __asm_proxy_MRS__,
    "MSR"        : __asm_proxy_MSR__,
    "MSRR"       : __asm_proxy_MSRR__,
    "MSUB"       : __asm_proxy_MSUB__,
    "MUL"        : __asm_proxy_MUL__,
    "MVN"        : __asm_proxy_MVN__,
    "MVNI"       : __asm_proxy_MVNI__,
    "NEG"        : __asm_proxy_NEG__,
    "NEGS"       : __asm_proxy_NEGS__,
    "NGC"        : __asm_proxy_NGC__,
    "NGCS"       : __asm_proxy_NGCS__,
    "NOP"        : __asm_proxy_NOP__,
    "NOT"        : __asm_proxy_NOT__,
    "ORN"        : __asm_proxy_ORN__,
    "ORR"        : __asm_proxy_ORR__,
    "PACDA"      : __asm_proxy_PACDA__,
    "PACDB"      : __asm_proxy_PACDB__,
    "PACDZA"     : __asm_proxy_PACDZA__,
    "PACDZB"     : __asm_proxy_PACDZB__,
    "PACGA"      : __asm_proxy_PACGA__,
    "PACIA"      : __asm_proxy_PACIA__,
    "PACIA1716"  : __asm_proxy_PACIA1716__,
    "PACIASP"    : __asm_proxy_PACIASP__,
    "PACIAZ"     : __asm_proxy_PACIAZ__,
    "PACIB"      : __asm_proxy_PACIB__,
    "PACIB1716"  : __asm_proxy_PACIB1716__,
    "PACIBSP"    : __asm_proxy_PACIBSP__,
    "PACIBZ"     : __asm_proxy_PACIBZ__,
    "PACIZA"     : __asm_proxy_PACIZA__,
    "PACIZB"     : __asm_proxy_PACIZB__,
    "PMUL"       : __asm_proxy_PMUL__,
    "PMULL"      : __asm_proxy_PMULL__,
    "PMULL2"     : __asm_proxy_PMULL2__,
    "PRFM"       : __asm_proxy_PRFM__,
    "PRFUM"      : __asm_proxy_PRFUM__,
    "PSB"        : __asm_proxy_PSB__,
    "PSSBB"      : __asm_proxy_PSSBB__,
    "RADDHN"     : __asm_proxy_RADDHN__,
    "RADDHN2"    : __asm_proxy_RADDHN2__,
    "RAX1"       : __asm_proxy_RAX1__,
    "RBIT"       : __asm_proxy_RBIT__,
    "RCWCAS"     : __asm_proxy_RCWCAS__,
    "RCWCASA"    : __asm_proxy_RCWCASA__,
    "RCWCASAL"   : __asm_proxy_RCWCASAL__,
    "RCWCASL"    : __asm_proxy_RCWCASL__,
    "RCWCASP"    : __asm_proxy_RCWCASP__,
    "RCWCASPA"   : __asm_proxy_RCWCASPA__,
    "RCWCASPAL"  : __asm_proxy_RCWCASPAL__,
    "RCWCASPL"   : __asm_proxy_RCWCASPL__,
    "RCWCLR"     : __asm_proxy_RCWCLR__,
    "RCWCLRA"    : __asm_proxy_RCWCLRA__,
    "RCWCLRAL"   : __asm_proxy_RCWCLRAL__,
    "RCWCLRL"    : __asm_proxy_RCWCLRL__,
    "RCWCLRP"    : __asm_proxy_RCWCLRP__,
    "RCWCLRPA"   : __asm_proxy_RCWCLRPA__,
    "RCWCLRPAL"  : __asm_proxy_RCWCLRPAL__,
    "RCWCLRPL"   : __asm_proxy_RCWCLRPL__,
    "RCWSCAS"    : __asm_proxy_RCWSCAS__,
    "RCWSCASA"   : __asm_proxy_RCWSCASA__,
    "RCWSCASAL"  : __asm_proxy_RCWSCASAL__,
    "RCWSCASL"   : __asm_proxy_RCWSCASL__,
    "RCWSCASP"   : __asm_proxy_RCWSCASP__,
    "RCWSCASPA"  : __asm_proxy_RCWSCASPA__,
    "RCWSCASPAL" : __asm_proxy_RCWSCASPAL__,
    "RCWSCASPL"  : __asm_proxy_RCWSCASPL__,
    "RCWSCLR"    : __asm_proxy_RCWSCLR__,
    "RCWSCLRA"   : __asm_proxy_RCWSCLRA__,
    "RCWSCLRAL"  : __asm_proxy_RCWSCLRAL__,
    "RCWSCLRL"   : __asm_proxy_RCWSCLRL__,
    "RCWSCLRP"   : __asm_proxy_RCWSCLRP__,
    "RCWSCLRPA"  : __asm_proxy_RCWSCLRPA__,
    "RCWSCLRPAL" : __asm_proxy_RCWSCLRPAL__,
    "RCWSCLRPL"  : __asm_proxy_RCWSCLRPL__,
    "RCWSET"     : __asm_proxy_RCWSET__,
    "RCWSETA"    : __asm_proxy_RCWSETA__,
    "RCWSETAL"   : __asm_proxy_RCWSETAL__,
    "RCWSETL"    : __asm_proxy_RCWSETL__,
    "RCWSETP"    : __asm_proxy_RCWSETP__,
    "RCWSETPA"   : __asm_proxy_RCWSETPA__,
    "RCWSETPAL"  : __asm_proxy_RCWSETPAL__,
    "RCWSETPL"   : __asm_proxy_RCWSETPL__,
    "RCWSSET"    : __asm_proxy_RCWSSET__,
    "RCWSSETA"   : __asm_proxy_RCWSSETA__,
    "RCWSSETAL"  : __asm_proxy_RCWSSETAL__,
    "RCWSSETL"   : __asm_proxy_RCWSSETL__,
    "RCWSSETP"   : __asm_proxy_RCWSSETP__,
    "RCWSSETPA"  : __asm_proxy_RCWSSETPA__,
    "RCWSSETPAL" : __asm_proxy_RCWSSETPAL__,
    "RCWSSETPL"  : __asm_proxy_RCWSSETPL__,
    "RCWSSWP"    : __asm_proxy_RCWSSWP__,
    "RCWSSWPA"   : __asm_proxy_RCWSSWPA__,
    "RCWSSWPAL"  : __asm_proxy_RCWSSWPAL__,
    "RCWSSWPL"   : __asm_proxy_RCWSSWPL__,
    "RCWSSWPP"   : __asm_proxy_RCWSSWPP__,
    "RCWSSWPPA"  : __asm_proxy_RCWSSWPPA__,
    "RCWSSWPPAL" : __asm_proxy_RCWSSWPPAL__,
    "RCWSSWPPL"  : __asm_proxy_RCWSSWPPL__,
    "RCWSWP"     : __asm_proxy_RCWSWP__,
    "RCWSWPA"    : __asm_proxy_RCWSWPA__,
    "RCWSWPAL"   : __asm_proxy_RCWSWPAL__,
    "RCWSWPL"    : __asm_proxy_RCWSWPL__,
    "RCWSWPP"    : __asm_proxy_RCWSWPP__,
    "RCWSWPPA"   : __asm_proxy_RCWSWPPA__,
    "RCWSWPPAL"  : __asm_proxy_RCWSWPPAL__,
    "RCWSWPPL"   : __asm_proxy_RCWSWPPL__,
    "RET"        : __asm_proxy_RET__,
    "RETAA"      : __asm_proxy_RETAA__,
    "RETAB"      : __asm_proxy_RETAB__,
    "REV"        : __asm_proxy_REV__,
    "REV16"      : __asm_proxy_REV16__,
    "REV32"      : __asm_proxy_REV32__,
    "REV64"      : __asm_proxy_REV64__,
    "RMIF"       : __asm_proxy_RMIF__,
    "ROR"        : __asm_proxy_ROR__,
    "RORV"       : __asm_proxy_RORV__,
    "RPRFM"      : __asm_proxy_RPRFM__,
    "RSHRN"      : __asm_proxy_RSHRN__,
    "RSHRN2"     : __asm_proxy_RSHRN2__,
    "RSUBHN"     : __asm_proxy_RSUBHN__,
    "RSUBHN2"    : __asm_proxy_RSUBHN2__,
    "SABA"       : __asm_proxy_SABA__,
    "SABAL"      : __asm_proxy_SABAL__,
    "SABAL2"     : __asm_proxy_SABAL2__,
    "SABD"       : __asm_proxy_SABD__,
    "SABDL"      : __asm_proxy_SABDL__,
    "SABDL2"     : __asm_proxy_SABDL2__,
    "SADALP"     : __asm_proxy_SADALP__,
    "SADDL"      : __asm_proxy_SADDL__,
    "SADDL2"     : __asm_proxy_SADDL2__,
    "SADDLP"     : __asm_proxy_SADDLP__,
    "SADDLV"     : __asm_proxy_SADDLV__,
    "SADDW"      : __asm_proxy_SADDW__,
    "SADDW2"     : __asm_proxy_SADDW2__,
    "SB"         : __asm_proxy_SB__,
    "SBC"        : __asm_proxy_SBC__,
    "SBCS"       : __asm_proxy_SBCS__,
    "SBFIZ"      : __asm_proxy_SBFIZ__,
    "SBFM"       : __asm_proxy_SBFM__,
    "SBFX"       : __asm_proxy_SBFX__,
    "SCVTF"      : __asm_proxy_SCVTF__,
    "SDIV"       : __asm_proxy_SDIV__,
    "SDOT"       : __asm_proxy_SDOT__,
    "SETE"       : __asm_proxy_SETE__,
    "SETEN"      : __asm_proxy_SETEN__,
    "SETET"      : __asm_proxy_SETET__,
    "SETETN"     : __asm_proxy_SETETN__,
    "SETF16"     : __asm_proxy_SETF16__,
    "SETF8"      : __asm_proxy_SETF8__,
    "SETGE"      : __asm_proxy_SETGE__,
    "SETGEN"     : __asm_proxy_SETGEN__,
    "SETGET"     : __asm_proxy_SETGET__,
    "SETGETN"    : __asm_proxy_SETGETN__,
    "SETGM"      : __asm_proxy_SETGM__,
    "SETGMN"     : __asm_proxy_SETGMN__,
    "SETGMT"     : __asm_proxy_SETGMT__,
    "SETGMTN"    : __asm_proxy_SETGMTN__,
    "SETGP"      : __asm_proxy_SETGP__,
    "SETGPN"     : __asm_proxy_SETGPN__,
    "SETGPT"     : __asm_proxy_SETGPT__,
    "SETGPTN"    : __asm_proxy_SETGPTN__,
    "SETM"       : __asm_proxy_SETM__,
    "SETMN"      : __asm_proxy_SETMN__,
    "SETMT"      : __asm_proxy_SETMT__,
    "SETMTN"     : __asm_proxy_SETMTN__,
    "SETP"       : __asm_proxy_SETP__,
    "SETPN"      : __asm_proxy_SETPN__,
    "SETPT"      : __asm_proxy_SETPT__,
    "SETPTN"     : __asm_proxy_SETPTN__,
    "SEV"        : __asm_proxy_SEV__,
    "SEVL"       : __asm_proxy_SEVL__,
    "SHA1C"      : __asm_proxy_SHA1C__,
    "SHA1H"      : __asm_proxy_SHA1H__,
    "SHA1M"      : __asm_proxy_SHA1M__,
    "SHA1P"      : __asm_proxy_SHA1P__,
    "SHA1SU0"    : __asm_proxy_SHA1SU0__,
    "SHA1SU1"    : __asm_proxy_SHA1SU1__,
    "SHA256H"    : __asm_proxy_SHA256H__,
    "SHA256H2"   : __asm_proxy_SHA256H2__,
    "SHA256SU0"  : __asm_proxy_SHA256SU0__,
    "SHA256SU1"  : __asm_proxy_SHA256SU1__,
    "SHA512H"    : __asm_proxy_SHA512H__,
    "SHA512H2"   : __asm_proxy_SHA512H2__,
    "SHA512SU0"  : __asm_proxy_SHA512SU0__,
    "SHA512SU1"  : __asm_proxy_SHA512SU1__,
    "SHADD"      : __asm_proxy_SHADD__,
    "SHL"        : __asm_proxy_SHL__,
    "SHLL"       : __asm_proxy_SHLL__,
    "SHLL2"      : __asm_proxy_SHLL2__,
    "SHRN"       : __asm_proxy_SHRN__,
    "SHRN2"      : __asm_proxy_SHRN2__,
    "SHSUB"      : __asm_proxy_SHSUB__,
    "SLI"        : __asm_proxy_SLI__,
    "SM3PARTW1"  : __asm_proxy_SM3PARTW1__,
    "SM3PARTW2"  : __asm_proxy_SM3PARTW2__,
    "SM3SS1"     : __asm_proxy_SM3SS1__,
    "SM3TT1A"    : __asm_proxy_SM3TT1A__,
    "SM3TT1B"    : __asm_proxy_SM3TT1B__,
    "SM3TT2A"    : __asm_proxy_SM3TT2A__,
    "SM3TT2B"    : __asm_proxy_SM3TT2B__,
    "SM4E"       : __asm_proxy_SM4E__,
    "SM4EKEY"    : __asm_proxy_SM4EKEY__,
    "SMADDL"     : __asm_proxy_SMADDL__,
    "SMAX"       : __asm_proxy_SMAX__,
    "SMAXP"      : __asm_proxy_SMAXP__,
    "SMAXV"      : __asm_proxy_SMAXV__,
    "SMC"        : __asm_proxy_SMC__,
    "SMIN"       : __asm_proxy_SMIN__,
    "SMINP"      : __asm_proxy_SMINP__,
    "SMINV"      : __asm_proxy_SMINV__,
    "SMLAL"      : __asm_proxy_SMLAL__,
    "SMLAL2"     : __asm_proxy_SMLAL2__,
    "SMLSL"      : __asm_proxy_SMLSL__,
    "SMLSL2"     : __asm_proxy_SMLSL2__,
    "SMMLA"      : __asm_proxy_SMMLA__,
    "SMNEGL"     : __asm_proxy_SMNEGL__,
    "SMOV"       : __asm_proxy_SMOV__,
    "SMSTART"    : __asm_proxy_SMSTART__,
    "SMSTOP"     : __asm_proxy_SMSTOP__,
    "SMSUBL"     : __asm_proxy_SMSUBL__,
    "SMULH"      : __asm_proxy_SMULH__,
    "SMULL"      : __asm_proxy_SMULL__,
    "SMULL2"     : __asm_proxy_SMULL2__,
    "SQABS"      : __asm_proxy_SQABS__,
    "SQADD"      : __asm_proxy_SQADD__,
    "SQDMLAL"    : __asm_proxy_SQDMLAL__,
    "SQDMLAL2"   : __asm_proxy_SQDMLAL2__,
    "SQDMLSL"    : __asm_proxy_SQDMLSL__,
    "SQDMLSL2"   : __asm_proxy_SQDMLSL2__,
    "SQDMULH"    : __asm_proxy_SQDMULH__,
    "SQDMULL"    : __asm_proxy_SQDMULL__,
    "SQDMULL2"   : __asm_proxy_SQDMULL2__,
    "SQNEG"      : __asm_proxy_SQNEG__,
    "SQRDMLAH"   : __asm_proxy_SQRDMLAH__,
    "SQRDMLSH"   : __asm_proxy_SQRDMLSH__,
    "SQRDMULH"   : __asm_proxy_SQRDMULH__,
    "SQRSHL"     : __asm_proxy_SQRSHL__,
    "SQRSHRN"    : __asm_proxy_SQRSHRN__,
    "SQRSHRN2"   : __asm_proxy_SQRSHRN2__,
    "SQRSHRUN"   : __asm_proxy_SQRSHRUN__,
    "SQRSHRUN2"  : __asm_proxy_SQRSHRUN2__,
    "SQSHL"      : __asm_proxy_SQSHL__,
    "SQSHLU"     : __asm_proxy_SQSHLU__,
    "SQSHRN"     : __asm_proxy_SQSHRN__,
    "SQSHRN2"    : __asm_proxy_SQSHRN2__,
    "SQSHRUN"    : __asm_proxy_SQSHRUN__,
    "SQSHRUN2"   : __asm_proxy_SQSHRUN2__,
    "SQSUB"      : __asm_proxy_SQSUB__,
    "SQXTN"      : __asm_proxy_SQXTN__,
    "SQXTN2"     : __asm_proxy_SQXTN2__,
    "SQXTUN"     : __asm_proxy_SQXTUN__,
    "SQXTUN2"    : __asm_proxy_SQXTUN2__,
    "SRHADD"     : __asm_proxy_SRHADD__,
    "SRI"        : __asm_proxy_SRI__,
    "SRSHL"      : __asm_proxy_SRSHL__,
    "SRSHR"      : __asm_proxy_SRSHR__,
    "SRSRA"      : __asm_proxy_SRSRA__,
    "SSBB"       : __asm_proxy_SSBB__,
    "SSHL"       : __asm_proxy_SSHL__,
    "SSHLL"      : __asm_proxy_SSHLL__,
    "SSHLL2"     : __asm_proxy_SSHLL2__,
    "SSHR"       : __asm_proxy_SSHR__,
    "SSRA"       : __asm_proxy_SSRA__,
    "SSUBL"      : __asm_proxy_SSUBL__,
    "SSUBL2"     : __asm_proxy_SSUBL2__,
    "SSUBW"      : __asm_proxy_SSUBW__,
    "SSUBW2"     : __asm_proxy_SSUBW2__,
    "ST1"        : __asm_proxy_ST1__,
    "ST2"        : __asm_proxy_ST2__,
    "ST2G"       : __asm_proxy_ST2G__,
    "ST3"        : __asm_proxy_ST3__,
    "ST4"        : __asm_proxy_ST4__,
    "ST64B"      : __asm_proxy_ST64B__,
    "ST64BV"     : __asm_proxy_ST64BV__,
    "ST64BV0"    : __asm_proxy_ST64BV0__,
    "STADD"      : __asm_proxy_STADD__,
    "STADDB"     : __asm_proxy_STADDB__,
    "STADDH"     : __asm_proxy_STADDH__,
    "STADDL"     : __asm_proxy_STADDL__,
    "STADDLB"    : __asm_proxy_STADDLB__,
    "STADDLH"    : __asm_proxy_STADDLH__,
    "STCLR"      : __asm_proxy_STCLR__,
    "STCLRB"     : __asm_proxy_STCLRB__,
    "STCLRH"     : __asm_proxy_STCLRH__,
    "STCLRL"     : __asm_proxy_STCLRL__,
    "STCLRLB"    : __asm_proxy_STCLRLB__,
    "STCLRLH"    : __asm_proxy_STCLRLH__,
    "STEOR"      : __asm_proxy_STEOR__,
    "STEORB"     : __asm_proxy_STEORB__,
    "STEORH"     : __asm_proxy_STEORH__,
    "STEORL"     : __asm_proxy_STEORL__,
    "STEORLB"    : __asm_proxy_STEORLB__,
    "STEORLH"    : __asm_proxy_STEORLH__,
    "STG"        : __asm_proxy_STG__,
    "STGM"       : __asm_proxy_STGM__,
    "STGP"       : __asm_proxy_STGP__,
    "STILP"      : __asm_proxy_STILP__,
    "STL1"       : __asm_proxy_STL1__,
    "STLLR"      : __asm_proxy_STLLR__,
    "STLLRB"     : __asm_proxy_STLLRB__,
    "STLLRH"     : __asm_proxy_STLLRH__,
    "STLR"       : __asm_proxy_STLR__,
    "STLRB"      : __asm_proxy_STLRB__,
    "STLRH"      : __asm_proxy_STLRH__,
    "STLUR"      : __asm_proxy_STLUR__,
    "STLURB"     : __asm_proxy_STLURB__,
    "STLURH"     : __asm_proxy_STLURH__,
    "STLXP"      : __asm_proxy_STLXP__,
    "STLXR"      : __asm_proxy_STLXR__,
    "STLXRB"     : __asm_proxy_STLXRB__,
    "STLXRH"     : __asm_proxy_STLXRH__,
    "STNP"       : __asm_proxy_STNP__,
    "STP"        : __asm_proxy_STP__,
    "STR"        : __asm_proxy_STR__,
    "STRB"       : __asm_proxy_STRB__,
    "STRH"       : __asm_proxy_STRH__,
    "STSET"      : __asm_proxy_STSET__,
    "STSETB"     : __asm_proxy_STSETB__,
    "STSETH"     : __asm_proxy_STSETH__,
    "STSETL"     : __asm_proxy_STSETL__,
    "STSETLB"    : __asm_proxy_STSETLB__,
    "STSETLH"    : __asm_proxy_STSETLH__,
    "STSMAX"     : __asm_proxy_STSMAX__,
    "STSMAXB"    : __asm_proxy_STSMAXB__,
    "STSMAXH"    : __asm_proxy_STSMAXH__,
    "STSMAXL"    : __asm_proxy_STSMAXL__,
    "STSMAXLB"   : __asm_proxy_STSMAXLB__,
    "STSMAXLH"   : __asm_proxy_STSMAXLH__,
    "STSMIN"     : __asm_proxy_STSMIN__,
    "STSMINB"    : __asm_proxy_STSMINB__,
    "STSMINH"    : __asm_proxy_STSMINH__,
    "STSMINL"    : __asm_proxy_STSMINL__,
    "STSMINLB"   : __asm_proxy_STSMINLB__,
    "STSMINLH"   : __asm_proxy_STSMINLH__,
    "STTR"       : __asm_proxy_STTR__,
    "STTRB"      : __asm_proxy_STTRB__,
    "STTRH"      : __asm_proxy_STTRH__,
    "STUMAX"     : __asm_proxy_STUMAX__,
    "STUMAXB"    : __asm_proxy_STUMAXB__,
    "STUMAXH"    : __asm_proxy_STUMAXH__,
    "STUMAXL"    : __asm_proxy_STUMAXL__,
    "STUMAXLB"   : __asm_proxy_STUMAXLB__,
    "STUMAXLH"   : __asm_proxy_STUMAXLH__,
    "STUMIN"     : __asm_proxy_STUMIN__,
    "STUMINB"    : __asm_proxy_STUMINB__,
    "STUMINH"    : __asm_proxy_STUMINH__,
    "STUMINL"    : __asm_proxy_STUMINL__,
    "STUMINLB"   : __asm_proxy_STUMINLB__,
    "STUMINLH"   : __asm_proxy_STUMINLH__,
    "STUR"       : __asm_proxy_STUR__,
    "STURB"      : __asm_proxy_STURB__,
    "STURH"      : __asm_proxy_STURH__,
    "STXP"       : __asm_proxy_STXP__,
    "STXR"       : __asm_proxy_STXR__,
    "STXRB"      : __asm_proxy_STXRB__,
    "STXRH"      : __asm_proxy_STXRH__,
    "STZ2G"      : __asm_proxy_STZ2G__,
    "STZG"       : __asm_proxy_STZG__,
    "STZGM"      : __asm_proxy_STZGM__,
    "SUB"        : __asm_proxy_SUB__,
    "SUBG"       : __asm_proxy_SUBG__,
    "SUBHN"      : __asm_proxy_SUBHN__,
    "SUBHN2"     : __asm_proxy_SUBHN2__,
    "SUBP"       : __asm_proxy_SUBP__,
    "SUBPS"      : __asm_proxy_SUBPS__,
    "SUBS"       : __asm_proxy_SUBS__,
    "SUDOT"      : __asm_proxy_SUDOT__,
    "SUQADD"     : __asm_proxy_SUQADD__,
    "SVC"        : __asm_proxy_SVC__,
    "SWP"        : __asm_proxy_SWP__,
    "SWPA"       : __asm_proxy_SWPA__,
    "SWPAB"      : __asm_proxy_SWPAB__,
    "SWPAH"      : __asm_proxy_SWPAH__,
    "SWPAL"      : __asm_proxy_SWPAL__,
    "SWPALB"     : __asm_proxy_SWPALB__,
    "SWPALH"     : __asm_proxy_SWPALH__,
    "SWPB"       : __asm_proxy_SWPB__,
    "SWPH"       : __asm_proxy_SWPH__,
    "SWPL"       : __asm_proxy_SWPL__,
    "SWPLB"      : __asm_proxy_SWPLB__,
    "SWPLH"      : __asm_proxy_SWPLH__,
    "SWPP"       : __asm_proxy_SWPP__,
    "SWPPA"      : __asm_proxy_SWPPA__,
    "SWPPAL"     : __asm_proxy_SWPPAL__,
    "SWPPL"      : __asm_proxy_SWPPL__,
    "SXTB"       : __asm_proxy_SXTB__,
    "SXTH"       : __asm_proxy_SXTH__,
    "SXTL"       : __asm_proxy_SXTL__,
    "SXTL2"      : __asm_proxy_SXTL2__,
    "SXTW"       : __asm_proxy_SXTW__,
    "SYS"        : __asm_proxy_SYS__,
    "SYSL"       : __asm_proxy_SYSL__,
    "SYSP"       : __asm_proxy_SYSP__,
    "TBL"        : __asm_proxy_TBL__,
    "TBNZ"       : __asm_proxy_TBNZ__,
    "TBX"        : __asm_proxy_TBX__,
    "TBZ"        : __asm_proxy_TBZ__,
    "TCANCEL"    : __asm_proxy_TCANCEL__,
    "TCOMMIT"    : __asm_proxy_TCOMMIT__,
    "TLBI"       : __asm_proxy_TLBI__,
    "TLBIP"      : __asm_proxy_TLBIP__,
    "TRCIT"      : __asm_proxy_TRCIT__,
    "TRN1"       : __asm_proxy_TRN1__,
    "TRN2"       : __asm_proxy_TRN2__,
    "TSB"        : __asm_proxy_TSB__,
    "TST"        : __asm_proxy_TST__,
    "TSTART"     : __asm_proxy_TSTART__,
    "TTEST"      : __asm_proxy_TTEST__,
    "UABA"       : __asm_proxy_UABA__,
    "UABAL"      : __asm_proxy_UABAL__,
    "UABAL2"     : __asm_proxy_UABAL2__,
    "UABD"       : __asm_proxy_UABD__,
    "UABDL"      : __asm_proxy_UABDL__,
    "UABDL2"     : __asm_proxy_UABDL2__,
    "UADALP"     : __asm_proxy_UADALP__,
    "UADDL"      : __asm_proxy_UADDL__,
    "UADDL2"     : __asm_proxy_UADDL2__,
    "UADDLP"     : __asm_proxy_UADDLP__,
    "UADDLV"     : __asm_proxy_UADDLV__,
    "UADDW"      : __asm_proxy_UADDW__,
    "UADDW2"     : __asm_proxy_UADDW2__,
    "UBFIZ"      : __asm_proxy_UBFIZ__,
    "UBFM"       : __asm_proxy_UBFM__,
    "UBFX"       : __asm_proxy_UBFX__,
    "UCVTF"      : __asm_proxy_UCVTF__,
    "UDF"        : __asm_proxy_UDF__,
    "UDIV"       : __asm_proxy_UDIV__,
    "UDOT"       : __asm_proxy_UDOT__,
    "UHADD"      : __asm_proxy_UHADD__,
    "UHSUB"      : __asm_proxy_UHSUB__,
    "UMADDL"     : __asm_proxy_UMADDL__,
    "UMAX"       : __asm_proxy_UMAX__,
    "UMAXP"      : __asm_proxy_UMAXP__,
    "UMAXV"      : __asm_proxy_UMAXV__,
    "UMIN"       : __asm_proxy_UMIN__,
    "UMINP"      : __asm_proxy_UMINP__,
    "UMINV"      : __asm_proxy_UMINV__,
    "UMLAL"      : __asm_proxy_UMLAL__,
    "UMLAL2"     : __asm_proxy_UMLAL2__,
    "UMLSL"      : __asm_proxy_UMLSL__,
    "UMLSL2"     : __asm_proxy_UMLSL2__,
    "UMMLA"      : __asm_proxy_UMMLA__,
    "UMNEGL"     : __asm_proxy_UMNEGL__,
    "UMOV"       : __asm_proxy_UMOV__,
    "UMSUBL"     : __asm_proxy_UMSUBL__,
    "UMULH"      : __asm_proxy_UMULH__,
    "UMULL"      : __asm_proxy_UMULL__,
    "UMULL2"     : __asm_proxy_UMULL2__,
    "UQADD"      : __asm_proxy_UQADD__,
    "UQRSHL"     : __asm_proxy_UQRSHL__,
    "UQRSHRN"    : __asm_proxy_UQRSHRN__,
    "UQRSHRN2"   : __asm_proxy_UQRSHRN2__,
    "UQSHL"      : __asm_proxy_UQSHL__,
    "UQSHRN"     : __asm_proxy_UQSHRN__,
    "UQSHRN2"    : __asm_proxy_UQSHRN2__,
    "UQSUB"      : __asm_proxy_UQSUB__,
    "UQXTN"      : __asm_proxy_UQXTN__,
    "UQXTN2"     : __asm_proxy_UQXTN2__,
    "URECPE"     : __asm_proxy_URECPE__,
    "URHADD"     : __asm_proxy_URHADD__,
    "URSHL"      : __asm_proxy_URSHL__,
    "URSHR"      : __asm_proxy_URSHR__,
    "URSQRTE"    : __asm_proxy_URSQRTE__,
    "URSRA"      : __asm_proxy_URSRA__,
    "USDOT"      : __asm_proxy_USDOT__,
    "USHL"       : __asm_proxy_USHL__,
    "USHLL"      : __asm_proxy_USHLL__,
    "USHLL2"     : __asm_proxy_USHLL2__,
    "USHR"       : __asm_proxy_USHR__,
    "USMMLA"     : __asm_proxy_USMMLA__,
    "USQADD"     : __asm_proxy_USQADD__,
    "USRA"       : __asm_proxy_USRA__,
    "USUBL"      : __asm_proxy_USUBL__,
    "USUBL2"     : __asm_proxy_USUBL2__,
    "USUBW"      : __asm_proxy_USUBW__,
    "USUBW2"     : __asm_proxy_USUBW2__,
    "UXTB"       : __asm_proxy_UXTB__,
    "UXTH"       : __asm_proxy_UXTH__,
    "UXTL"       : __asm_proxy_UXTL__,
    "UXTL2"      : __asm_proxy_UXTL2__,
    "UZP1"       : __asm_proxy_UZP1__,
    "UZP2"       : __asm_proxy_UZP2__,
    "WFE"        : __asm_proxy_WFE__,
    "WFET"       : __asm_proxy_WFET__,
    "WFI"        : __asm_proxy_WFI__,
    "WFIT"       : __asm_proxy_WFIT__,
    "XAFLAG"     : __asm_proxy_XAFLAG__,
    "XAR"        : __asm_proxy_XAR__,
    "XPACD"      : __asm_proxy_XPACD__,
    "XPACI"      : __asm_proxy_XPACI__,
    "XPACLRI"    : __asm_proxy_XPACLRI__,
    "XTN"        : __asm_proxy_XTN__,
    "XTN2"       : __asm_proxy_XTN2__,
    "YIELD"      : __asm_proxy_YIELD__,
    "ZIP1"       : __asm_proxy_ZIP1__,
    "ZIP2"       : __asm_proxy_ZIP2__,
}

func __asm_proxy_ABS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ABS takes 2 operands")
    } else {
        return p.ABS(vv[0], vv[1])
    }
}

func __asm_proxy_ADC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ADC takes 3 operands")
    } else {
        return p.ADC(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ADCS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ADCS takes 3 operands")
    } else {
        return p.ADCS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ADD__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.ADD(vv[0], vv[1], vv[2])
        case 4  : return p.ADD(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction ADD takes 3 or 4 operands")
    }
}

func __asm_proxy_ADDG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction ADDG takes 4 operands")
    } else {
        return p.ADDG(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_ADDHN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ADDHN takes 3 operands")
    } else {
        return p.ADDHN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ADDHN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ADDHN2 takes 3 operands")
    } else {
        return p.ADDHN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ADDP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.ADDP(vv[0], vv[1])
        case 3  : return p.ADDP(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction ADDP takes 2 or 3 operands")
    }
}

func __asm_proxy_ADDS__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.ADDS(vv[0], vv[1], vv[2])
        case 4  : return p.ADDS(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction ADDS takes 3 or 4 operands")
    }
}

func __asm_proxy_ADDV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ADDV takes 2 operands")
    } else {
        return p.ADDV(vv[0], vv[1])
    }
}

func __asm_proxy_ADR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ADR takes 2 operands")
    } else {
        return p.ADR(vv[0], vv[1])
    }
}

func __asm_proxy_ADRP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ADRP takes 2 operands")
    } else {
        return p.ADRP(vv[0], vv[1])
    }
}

func __asm_proxy_AESD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AESD takes 2 operands")
    } else {
        return p.AESD(vv[0], vv[1])
    }
}

func __asm_proxy_AESE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AESE takes 2 operands")
    } else {
        return p.AESE(vv[0], vv[1])
    }
}

func __asm_proxy_AESIMC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AESIMC takes 2 operands")
    } else {
        return p.AESIMC(vv[0], vv[1])
    }
}

func __asm_proxy_AESMC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AESMC takes 2 operands")
    } else {
        return p.AESMC(vv[0], vv[1])
    }
}

func __asm_proxy_AND__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.AND(vv[0], vv[1], vv[2])
        case 4  : return p.AND(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction AND takes 3 or 4 operands")
    }
}

func __asm_proxy_ANDS__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.ANDS(vv[0], vv[1], vv[2])
        case 4  : return p.ANDS(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction ANDS takes 3 or 4 operands")
    }
}

func __asm_proxy_ASR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ASR takes 3 operands")
    } else {
        return p.ASR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ASRV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ASRV takes 3 operands")
    } else {
        return p.ASRV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_AT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AT takes 2 operands")
    } else {
        return p.AT(vv[0], vv[1])
    }
}

func __asm_proxy_AUTDA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AUTDA takes 2 operands")
    } else {
        return p.AUTDA(vv[0], vv[1])
    }
}

func __asm_proxy_AUTDB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AUTDB takes 2 operands")
    } else {
        return p.AUTDB(vv[0], vv[1])
    }
}

func __asm_proxy_AUTDZA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction AUTDZA takes a single operand")
    } else {
        return p.AUTDZA(vv[0])
    }
}

func __asm_proxy_AUTDZB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction AUTDZB takes a single operand")
    } else {
        return p.AUTDZB(vv[0])
    }
}

func __asm_proxy_AUTIA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AUTIA takes 2 operands")
    } else {
        return p.AUTIA(vv[0], vv[1])
    }
}

func __asm_proxy_AUTIA1716__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction AUTIA1716 takes no operands")
    } else {
        return p.AUTIA1716()
    }
}

func __asm_proxy_AUTIASP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction AUTIASP takes no operands")
    } else {
        return p.AUTIASP()
    }
}

func __asm_proxy_AUTIAZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction AUTIAZ takes no operands")
    } else {
        return p.AUTIAZ()
    }
}

func __asm_proxy_AUTIB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction AUTIB takes 2 operands")
    } else {
        return p.AUTIB(vv[0], vv[1])
    }
}

func __asm_proxy_AUTIB1716__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction AUTIB1716 takes no operands")
    } else {
        return p.AUTIB1716()
    }
}

func __asm_proxy_AUTIBSP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction AUTIBSP takes no operands")
    } else {
        return p.AUTIBSP()
    }
}

func __asm_proxy_AUTIBZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction AUTIBZ takes no operands")
    } else {
        return p.AUTIBZ()
    }
}

func __asm_proxy_AUTIZA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction AUTIZA takes a single operand")
    } else {
        return p.AUTIZA(vv[0])
    }
}

func __asm_proxy_AUTIZB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction AUTIZB takes a single operand")
    } else {
        return p.AUTIZB(vv[0])
    }
}

func __asm_proxy_AXFLAG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction AXFLAG takes no operands")
    } else {
        return p.AXFLAG()
    }
}

func __asm_proxy_B__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction B takes a single operand")
    } else {
        return p.B(vv[0])
    }
}

func __asm_proxy_BEQ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BEQ takes a single operand")
    } else {
        return p.BEQ(vv[0])
    }
}

func __asm_proxy_BNE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BNE takes a single operand")
    } else {
        return p.BNE(vv[0])
    }
}

func __asm_proxy_BCS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCS takes a single operand")
    } else {
        return p.BCS(vv[0])
    }
}

func __asm_proxy_BHS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BHS takes a single operand")
    } else {
        return p.BHS(vv[0])
    }
}

func __asm_proxy_BCC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCC takes a single operand")
    } else {
        return p.BCC(vv[0])
    }
}

func __asm_proxy_BLO__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BLO takes a single operand")
    } else {
        return p.BLO(vv[0])
    }
}

func __asm_proxy_BMI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BMI takes a single operand")
    } else {
        return p.BMI(vv[0])
    }
}

func __asm_proxy_BPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BPL takes a single operand")
    } else {
        return p.BPL(vv[0])
    }
}

func __asm_proxy_BVS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BVS takes a single operand")
    } else {
        return p.BVS(vv[0])
    }
}

func __asm_proxy_BVC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BVC takes a single operand")
    } else {
        return p.BVC(vv[0])
    }
}

func __asm_proxy_BHI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BHI takes a single operand")
    } else {
        return p.BHI(vv[0])
    }
}

func __asm_proxy_BLS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BLS takes a single operand")
    } else {
        return p.BLS(vv[0])
    }
}

func __asm_proxy_BGE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BGE takes a single operand")
    } else {
        return p.BGE(vv[0])
    }
}

func __asm_proxy_BLT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BLT takes a single operand")
    } else {
        return p.BLT(vv[0])
    }
}

func __asm_proxy_BGT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BGT takes a single operand")
    } else {
        return p.BGT(vv[0])
    }
}

func __asm_proxy_BLE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BLE takes a single operand")
    } else {
        return p.BLE(vv[0])
    }
}

func __asm_proxy_BAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BAL takes a single operand")
    } else {
        return p.BAL(vv[0])
    }
}

func __asm_proxy_BCEQ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCEQ takes a single operand")
    } else {
        return p.BCEQ(vv[0])
    }
}

func __asm_proxy_BCNE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCNE takes a single operand")
    } else {
        return p.BCNE(vv[0])
    }
}

func __asm_proxy_BCCS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCCS takes a single operand")
    } else {
        return p.BCCS(vv[0])
    }
}

func __asm_proxy_BCHS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCHS takes a single operand")
    } else {
        return p.BCHS(vv[0])
    }
}

func __asm_proxy_BCCC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCCC takes a single operand")
    } else {
        return p.BCCC(vv[0])
    }
}

func __asm_proxy_BCLO__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCLO takes a single operand")
    } else {
        return p.BCLO(vv[0])
    }
}

func __asm_proxy_BCMI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCMI takes a single operand")
    } else {
        return p.BCMI(vv[0])
    }
}

func __asm_proxy_BCPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCPL takes a single operand")
    } else {
        return p.BCPL(vv[0])
    }
}

func __asm_proxy_BCVS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCVS takes a single operand")
    } else {
        return p.BCVS(vv[0])
    }
}

func __asm_proxy_BCVC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCVC takes a single operand")
    } else {
        return p.BCVC(vv[0])
    }
}

func __asm_proxy_BCHI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCHI takes a single operand")
    } else {
        return p.BCHI(vv[0])
    }
}

func __asm_proxy_BCLS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCLS takes a single operand")
    } else {
        return p.BCLS(vv[0])
    }
}

func __asm_proxy_BCGE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCGE takes a single operand")
    } else {
        return p.BCGE(vv[0])
    }
}

func __asm_proxy_BCLT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCLT takes a single operand")
    } else {
        return p.BCLT(vv[0])
    }
}

func __asm_proxy_BCGT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCGT takes a single operand")
    } else {
        return p.BCGT(vv[0])
    }
}

func __asm_proxy_BCLE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCLE takes a single operand")
    } else {
        return p.BCLE(vv[0])
    }
}

func __asm_proxy_BCAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BCAL takes a single operand")
    } else {
        return p.BCAL(vv[0])
    }
}

func __asm_proxy_BCAX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction BCAX takes 4 operands")
    } else {
        return p.BCAX(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_BFC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction BFC takes 3 operands")
    } else {
        return p.BFC(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_BFCVT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction BFCVT takes 2 operands")
    } else {
        return p.BFCVT(vv[0], vv[1])
    }
}

func __asm_proxy_BFCVTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction BFCVTN takes 2 operands")
    } else {
        return p.BFCVTN(vv[0], vv[1])
    }
}

func __asm_proxy_BFCVTN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction BFCVTN2 takes 2 operands")
    } else {
        return p.BFCVTN2(vv[0], vv[1])
    }
}

func __asm_proxy_BFDOT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction BFDOT takes 3 operands")
    } else {
        return p.BFDOT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_BFI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction BFI takes 4 operands")
    } else {
        return p.BFI(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_BFM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction BFM takes 4 operands")
    } else {
        return p.BFM(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_BFMLALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction BFMLALB takes 3 operands")
    } else {
        return p.BFMLALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_BFMLALT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction BFMLALT takes 3 operands")
    } else {
        return p.BFMLALT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_BFMMLA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction BFMMLA takes 3 operands")
    } else {
        return p.BFMMLA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_BFXIL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction BFXIL takes 4 operands")
    } else {
        return p.BFXIL(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_BIC__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.BIC(vv[0], vv[1])
        case 3  : return p.BIC(vv[0], vv[1], vv[2])
        case 4  : return p.BIC(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction BIC takes 2 or 3 or 4 operands")
    }
}

func __asm_proxy_BICS__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.BICS(vv[0], vv[1], vv[2])
        case 4  : return p.BICS(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction BICS takes 3 or 4 operands")
    }
}

func __asm_proxy_BIF__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction BIF takes 3 operands")
    } else {
        return p.BIF(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_BIT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction BIT takes 3 operands")
    } else {
        return p.BIT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_BL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BL takes a single operand")
    } else {
        return p.BL(vv[0])
    }
}

func __asm_proxy_BLR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BLR takes a single operand")
    } else {
        return p.BLR(vv[0])
    }
}

func __asm_proxy_BLRAA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction BLRAA takes 2 operands")
    } else {
        return p.BLRAA(vv[0], vv[1])
    }
}

func __asm_proxy_BLRAAZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BLRAAZ takes a single operand")
    } else {
        return p.BLRAAZ(vv[0])
    }
}

func __asm_proxy_BLRAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction BLRAB takes 2 operands")
    } else {
        return p.BLRAB(vv[0], vv[1])
    }
}

func __asm_proxy_BLRABZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BLRABZ takes a single operand")
    } else {
        return p.BLRABZ(vv[0])
    }
}

func __asm_proxy_BR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BR takes a single operand")
    } else {
        return p.BR(vv[0])
    }
}

func __asm_proxy_BRAA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction BRAA takes 2 operands")
    } else {
        return p.BRAA(vv[0], vv[1])
    }
}

func __asm_proxy_BRAAZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BRAAZ takes a single operand")
    } else {
        return p.BRAAZ(vv[0])
    }
}

func __asm_proxy_BRAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction BRAB takes 2 operands")
    } else {
        return p.BRAB(vv[0], vv[1])
    }
}

func __asm_proxy_BRABZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BRABZ takes a single operand")
    } else {
        return p.BRABZ(vv[0])
    }
}

func __asm_proxy_BRB__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 1  : return p.BRB(vv[0])
        case 2  : return p.BRB(vv[0], vv[1])
        default : panic("aarch64: instruction BRB takes 1 or 2 operands")
    }
}

func __asm_proxy_BRK__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction BRK takes a single operand")
    } else {
        return p.BRK(vv[0])
    }
}

func __asm_proxy_BSL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction BSL takes 3 operands")
    } else {
        return p.BSL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_BTI__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.BTI()
        case 1  : return p.BTI(vv[0])
        default : panic("aarch64: instruction BTI takes 0 or 1 operands")
    }
}

func __asm_proxy_CAS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CAS takes 3 operands")
    } else {
        return p.CAS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASA takes 3 operands")
    } else {
        return p.CASA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASAB takes 3 operands")
    } else {
        return p.CASAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASAH takes 3 operands")
    } else {
        return p.CASAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASAL takes 3 operands")
    } else {
        return p.CASAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASALB takes 3 operands")
    } else {
        return p.CASALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASALH takes 3 operands")
    } else {
        return p.CASALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASB takes 3 operands")
    } else {
        return p.CASB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASH takes 3 operands")
    } else {
        return p.CASH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASL takes 3 operands")
    } else {
        return p.CASL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASLB takes 3 operands")
    } else {
        return p.CASLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CASLH takes 3 operands")
    } else {
        return p.CASLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CASP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction CASP takes 5 operands")
    } else {
        return p.CASP(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_CASPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction CASPA takes 5 operands")
    } else {
        return p.CASPA(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_CASPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction CASPAL takes 5 operands")
    } else {
        return p.CASPAL(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_CASPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction CASPL takes 5 operands")
    } else {
        return p.CASPL(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_CBNZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CBNZ takes 2 operands")
    } else {
        return p.CBNZ(vv[0], vv[1])
    }
}

func __asm_proxy_CBZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CBZ takes 2 operands")
    } else {
        return p.CBZ(vv[0], vv[1])
    }
}

func __asm_proxy_CCMN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction CCMN takes 4 operands")
    } else {
        return p.CCMN(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_CCMP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction CCMP takes 4 operands")
    } else {
        return p.CCMP(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_CFINV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction CFINV takes no operands")
    } else {
        return p.CFINV()
    }
}

func __asm_proxy_CFP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CFP takes 2 operands")
    } else {
        return p.CFP(vv[0], vv[1])
    }
}

func __asm_proxy_CHKFEAT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction CHKFEAT takes a single operand")
    } else {
        return p.CHKFEAT(vv[0])
    }
}

func __asm_proxy_CINC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CINC takes 3 operands")
    } else {
        return p.CINC(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CINV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CINV takes 3 operands")
    } else {
        return p.CINV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CLRBHB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction CLRBHB takes no operands")
    } else {
        return p.CLRBHB()
    }
}

func __asm_proxy_CLREX__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.CLREX()
        case 1  : return p.CLREX(vv[0])
        default : panic("aarch64: instruction CLREX takes 0 or 1 operands")
    }
}

func __asm_proxy_CLS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CLS takes 2 operands")
    } else {
        return p.CLS(vv[0], vv[1])
    }
}

func __asm_proxy_CLZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CLZ takes 2 operands")
    } else {
        return p.CLZ(vv[0], vv[1])
    }
}

func __asm_proxy_CMEQ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CMEQ takes 3 operands")
    } else {
        return p.CMEQ(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CMGE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CMGE takes 3 operands")
    } else {
        return p.CMGE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CMGT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CMGT takes 3 operands")
    } else {
        return p.CMGT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CMHI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CMHI takes 3 operands")
    } else {
        return p.CMHI(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CMHS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CMHS takes 3 operands")
    } else {
        return p.CMHS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CMLE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CMLE takes 3 operands")
    } else {
        return p.CMLE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CMLT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CMLT takes 3 operands")
    } else {
        return p.CMLT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CMN__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.CMN(vv[0], vv[1])
        case 3  : return p.CMN(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction CMN takes 2 or 3 operands")
    }
}

func __asm_proxy_CMP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.CMP(vv[0], vv[1])
        case 3  : return p.CMP(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction CMP takes 2 or 3 operands")
    }
}

func __asm_proxy_CMPP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CMPP takes 2 operands")
    } else {
        return p.CMPP(vv[0], vv[1])
    }
}

func __asm_proxy_CMTST__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CMTST takes 3 operands")
    } else {
        return p.CMTST(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CNEG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CNEG takes 3 operands")
    } else {
        return p.CNEG(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CNT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CNT takes 2 operands")
    } else {
        return p.CNT(vv[0], vv[1])
    }
}

func __asm_proxy_COSP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction COSP takes 2 operands")
    } else {
        return p.COSP(vv[0], vv[1])
    }
}

func __asm_proxy_CPP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CPP takes 2 operands")
    } else {
        return p.CPP(vv[0], vv[1])
    }
}

func __asm_proxy_CPYE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYE takes 3 operands")
    } else {
        return p.CPYE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYEN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYEN takes 3 operands")
    } else {
        return p.CPYEN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYERN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYERN takes 3 operands")
    } else {
        return p.CPYERN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYERT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYERT takes 3 operands")
    } else {
        return p.CPYERT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYERTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYERTN takes 3 operands")
    } else {
        return p.CPYERTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYERTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYERTRN takes 3 operands")
    } else {
        return p.CPYERTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYERTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYERTWN takes 3 operands")
    } else {
        return p.CPYERTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYET takes 3 operands")
    } else {
        return p.CPYET(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYETN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYETN takes 3 operands")
    } else {
        return p.CPYETN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYETRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYETRN takes 3 operands")
    } else {
        return p.CPYETRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYETWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYETWN takes 3 operands")
    } else {
        return p.CPYETWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYEWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYEWN takes 3 operands")
    } else {
        return p.CPYEWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYEWT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYEWT takes 3 operands")
    } else {
        return p.CPYEWT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYEWTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYEWTN takes 3 operands")
    } else {
        return p.CPYEWTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYEWTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYEWTRN takes 3 operands")
    } else {
        return p.CPYEWTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYEWTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYEWTWN takes 3 operands")
    } else {
        return p.CPYEWTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFE takes 3 operands")
    } else {
        return p.CPYFE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFEN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFEN takes 3 operands")
    } else {
        return p.CPYFEN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFERN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFERN takes 3 operands")
    } else {
        return p.CPYFERN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFERT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFERT takes 3 operands")
    } else {
        return p.CPYFERT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFERTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFERTN takes 3 operands")
    } else {
        return p.CPYFERTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFERTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFERTRN takes 3 operands")
    } else {
        return p.CPYFERTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFERTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFERTWN takes 3 operands")
    } else {
        return p.CPYFERTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFET takes 3 operands")
    } else {
        return p.CPYFET(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFETN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFETN takes 3 operands")
    } else {
        return p.CPYFETN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFETRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFETRN takes 3 operands")
    } else {
        return p.CPYFETRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFETWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFETWN takes 3 operands")
    } else {
        return p.CPYFETWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFEWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFEWN takes 3 operands")
    } else {
        return p.CPYFEWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFEWT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFEWT takes 3 operands")
    } else {
        return p.CPYFEWT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFEWTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFEWTN takes 3 operands")
    } else {
        return p.CPYFEWTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFEWTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFEWTRN takes 3 operands")
    } else {
        return p.CPYFEWTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFEWTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFEWTWN takes 3 operands")
    } else {
        return p.CPYFEWTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFM takes 3 operands")
    } else {
        return p.CPYFM(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMN takes 3 operands")
    } else {
        return p.CPYFMN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMRN takes 3 operands")
    } else {
        return p.CPYFMRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMRT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMRT takes 3 operands")
    } else {
        return p.CPYFMRT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMRTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMRTN takes 3 operands")
    } else {
        return p.CPYFMRTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMRTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMRTRN takes 3 operands")
    } else {
        return p.CPYFMRTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMRTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMRTWN takes 3 operands")
    } else {
        return p.CPYFMRTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMT takes 3 operands")
    } else {
        return p.CPYFMT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMTN takes 3 operands")
    } else {
        return p.CPYFMTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMTRN takes 3 operands")
    } else {
        return p.CPYFMTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMTWN takes 3 operands")
    } else {
        return p.CPYFMTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMWN takes 3 operands")
    } else {
        return p.CPYFMWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMWT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMWT takes 3 operands")
    } else {
        return p.CPYFMWT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMWTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMWTN takes 3 operands")
    } else {
        return p.CPYFMWTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMWTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMWTRN takes 3 operands")
    } else {
        return p.CPYFMWTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFMWTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFMWTWN takes 3 operands")
    } else {
        return p.CPYFMWTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFP takes 3 operands")
    } else {
        return p.CPYFP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPN takes 3 operands")
    } else {
        return p.CPYFPN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPRN takes 3 operands")
    } else {
        return p.CPYFPRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPRT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPRT takes 3 operands")
    } else {
        return p.CPYFPRT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPRTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPRTN takes 3 operands")
    } else {
        return p.CPYFPRTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPRTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPRTRN takes 3 operands")
    } else {
        return p.CPYFPRTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPRTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPRTWN takes 3 operands")
    } else {
        return p.CPYFPRTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPT takes 3 operands")
    } else {
        return p.CPYFPT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPTN takes 3 operands")
    } else {
        return p.CPYFPTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPTRN takes 3 operands")
    } else {
        return p.CPYFPTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPTWN takes 3 operands")
    } else {
        return p.CPYFPTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPWN takes 3 operands")
    } else {
        return p.CPYFPWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPWT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPWT takes 3 operands")
    } else {
        return p.CPYFPWT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPWTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPWTN takes 3 operands")
    } else {
        return p.CPYFPWTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPWTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPWTRN takes 3 operands")
    } else {
        return p.CPYFPWTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYFPWTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYFPWTWN takes 3 operands")
    } else {
        return p.CPYFPWTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYM takes 3 operands")
    } else {
        return p.CPYM(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMN takes 3 operands")
    } else {
        return p.CPYMN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMRN takes 3 operands")
    } else {
        return p.CPYMRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMRT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMRT takes 3 operands")
    } else {
        return p.CPYMRT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMRTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMRTN takes 3 operands")
    } else {
        return p.CPYMRTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMRTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMRTRN takes 3 operands")
    } else {
        return p.CPYMRTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMRTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMRTWN takes 3 operands")
    } else {
        return p.CPYMRTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMT takes 3 operands")
    } else {
        return p.CPYMT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMTN takes 3 operands")
    } else {
        return p.CPYMTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMTRN takes 3 operands")
    } else {
        return p.CPYMTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMTWN takes 3 operands")
    } else {
        return p.CPYMTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMWN takes 3 operands")
    } else {
        return p.CPYMWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMWT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMWT takes 3 operands")
    } else {
        return p.CPYMWT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMWTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMWTN takes 3 operands")
    } else {
        return p.CPYMWTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMWTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMWTRN takes 3 operands")
    } else {
        return p.CPYMWTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYMWTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYMWTWN takes 3 operands")
    } else {
        return p.CPYMWTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYP takes 3 operands")
    } else {
        return p.CPYP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPN takes 3 operands")
    } else {
        return p.CPYPN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPRN takes 3 operands")
    } else {
        return p.CPYPRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPRT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPRT takes 3 operands")
    } else {
        return p.CPYPRT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPRTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPRTN takes 3 operands")
    } else {
        return p.CPYPRTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPRTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPRTRN takes 3 operands")
    } else {
        return p.CPYPRTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPRTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPRTWN takes 3 operands")
    } else {
        return p.CPYPRTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPT takes 3 operands")
    } else {
        return p.CPYPT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPTN takes 3 operands")
    } else {
        return p.CPYPTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPTRN takes 3 operands")
    } else {
        return p.CPYPTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPTWN takes 3 operands")
    } else {
        return p.CPYPTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPWN takes 3 operands")
    } else {
        return p.CPYPWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPWT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPWT takes 3 operands")
    } else {
        return p.CPYPWT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPWTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPWTN takes 3 operands")
    } else {
        return p.CPYPWTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPWTRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPWTRN takes 3 operands")
    } else {
        return p.CPYPWTRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CPYPWTWN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CPYPWTWN takes 3 operands")
    } else {
        return p.CPYPWTWN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CRC32B__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CRC32B takes 3 operands")
    } else {
        return p.CRC32B(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CRC32CB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CRC32CB takes 3 operands")
    } else {
        return p.CRC32CB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CRC32CH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CRC32CH takes 3 operands")
    } else {
        return p.CRC32CH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CRC32CW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CRC32CW takes 3 operands")
    } else {
        return p.CRC32CW(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CRC32CX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CRC32CX takes 3 operands")
    } else {
        return p.CRC32CX(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CRC32H__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CRC32H takes 3 operands")
    } else {
        return p.CRC32H(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CRC32W__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CRC32W takes 3 operands")
    } else {
        return p.CRC32W(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CRC32X__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction CRC32X takes 3 operands")
    } else {
        return p.CRC32X(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_CSDB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction CSDB takes no operands")
    } else {
        return p.CSDB()
    }
}

func __asm_proxy_CSEL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction CSEL takes 4 operands")
    } else {
        return p.CSEL(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_CSET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CSET takes 2 operands")
    } else {
        return p.CSET(vv[0], vv[1])
    }
}

func __asm_proxy_CSETM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CSETM takes 2 operands")
    } else {
        return p.CSETM(vv[0], vv[1])
    }
}

func __asm_proxy_CSINC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction CSINC takes 4 operands")
    } else {
        return p.CSINC(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_CSINV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction CSINV takes 4 operands")
    } else {
        return p.CSINV(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_CSNEG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction CSNEG takes 4 operands")
    } else {
        return p.CSNEG(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_CTZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction CTZ takes 2 operands")
    } else {
        return p.CTZ(vv[0], vv[1])
    }
}

func __asm_proxy_DC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction DC takes 2 operands")
    } else {
        return p.DC(vv[0], vv[1])
    }
}

func __asm_proxy_DCPS1__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.DCPS1()
        case 1  : return p.DCPS1(vv[0])
        default : panic("aarch64: instruction DCPS1 takes 0 or 1 operands")
    }
}

func __asm_proxy_DCPS2__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.DCPS2()
        case 1  : return p.DCPS2(vv[0])
        default : panic("aarch64: instruction DCPS2 takes 0 or 1 operands")
    }
}

func __asm_proxy_DCPS3__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.DCPS3()
        case 1  : return p.DCPS3(vv[0])
        default : panic("aarch64: instruction DCPS3 takes 0 or 1 operands")
    }
}

func __asm_proxy_DGH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction DGH takes no operands")
    } else {
        return p.DGH()
    }
}

func __asm_proxy_DMB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction DMB takes a single operand")
    } else {
        return p.DMB(vv[0])
    }
}

func __asm_proxy_DRPS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction DRPS takes no operands")
    } else {
        return p.DRPS()
    }
}

func __asm_proxy_DSB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction DSB takes a single operand")
    } else {
        return p.DSB(vv[0])
    }
}

func __asm_proxy_DUP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction DUP takes 2 operands")
    } else {
        return p.DUP(vv[0], vv[1])
    }
}

func __asm_proxy_DVP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction DVP takes 2 operands")
    } else {
        return p.DVP(vv[0], vv[1])
    }
}

func __asm_proxy_EON__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.EON(vv[0], vv[1], vv[2])
        case 4  : return p.EON(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction EON takes 3 or 4 operands")
    }
}

func __asm_proxy_EOR__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.EOR(vv[0], vv[1], vv[2])
        case 4  : return p.EOR(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction EOR takes 3 or 4 operands")
    }
}

func __asm_proxy_EOR3__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction EOR3 takes 4 operands")
    } else {
        return p.EOR3(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_ERET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction ERET takes no operands")
    } else {
        return p.ERET()
    }
}

func __asm_proxy_ERETAA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction ERETAA takes no operands")
    } else {
        return p.ERETAA()
    }
}

func __asm_proxy_ERETAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction ERETAB takes no operands")
    } else {
        return p.ERETAB()
    }
}

func __asm_proxy_ESB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction ESB takes no operands")
    } else {
        return p.ESB()
    }
}

func __asm_proxy_EXT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction EXT takes 4 operands")
    } else {
        return p.EXT(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_EXTR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction EXTR takes 4 operands")
    } else {
        return p.EXTR(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FABD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FABD takes 3 operands")
    } else {
        return p.FABD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FABS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FABS takes 2 operands")
    } else {
        return p.FABS(vv[0], vv[1])
    }
}

func __asm_proxy_FACGE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FACGE takes 3 operands")
    } else {
        return p.FACGE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FACGT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FACGT takes 3 operands")
    } else {
        return p.FACGT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FADD takes 3 operands")
    } else {
        return p.FADD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FADDP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.FADDP(vv[0], vv[1])
        case 3  : return p.FADDP(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction FADDP takes 2 or 3 operands")
    }
}

func __asm_proxy_FCADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FCADD takes 4 operands")
    } else {
        return p.FCADD(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FCCMP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FCCMP takes 4 operands")
    } else {
        return p.FCCMP(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FCCMPE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FCCMPE takes 4 operands")
    } else {
        return p.FCCMPE(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FCMEQ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FCMEQ takes 3 operands")
    } else {
        return p.FCMEQ(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FCMGE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FCMGE takes 3 operands")
    } else {
        return p.FCMGE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FCMGT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FCMGT takes 3 operands")
    } else {
        return p.FCMGT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FCMLA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FCMLA takes 4 operands")
    } else {
        return p.FCMLA(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FCMLE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FCMLE takes 3 operands")
    } else {
        return p.FCMLE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FCMLT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FCMLT takes 3 operands")
    } else {
        return p.FCMLT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FCMP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCMP takes 2 operands")
    } else {
        return p.FCMP(vv[0], vv[1])
    }
}

func __asm_proxy_FCMPE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCMPE takes 2 operands")
    } else {
        return p.FCMPE(vv[0], vv[1])
    }
}

func __asm_proxy_FCSEL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FCSEL takes 4 operands")
    } else {
        return p.FCSEL(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FCVT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVT takes 2 operands")
    } else {
        return p.FCVT(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTAS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTAS takes 2 operands")
    } else {
        return p.FCVTAS(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTAU__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTAU takes 2 operands")
    } else {
        return p.FCVTAU(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTL takes 2 operands")
    } else {
        return p.FCVTL(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTL2 takes 2 operands")
    } else {
        return p.FCVTL2(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTMS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTMS takes 2 operands")
    } else {
        return p.FCVTMS(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTMU__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTMU takes 2 operands")
    } else {
        return p.FCVTMU(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTN takes 2 operands")
    } else {
        return p.FCVTN(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTN2 takes 2 operands")
    } else {
        return p.FCVTN2(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTNS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTNS takes 2 operands")
    } else {
        return p.FCVTNS(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTNU__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTNU takes 2 operands")
    } else {
        return p.FCVTNU(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTPS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTPS takes 2 operands")
    } else {
        return p.FCVTPS(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTPU__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTPU takes 2 operands")
    } else {
        return p.FCVTPU(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTXN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTXN takes 2 operands")
    } else {
        return p.FCVTXN(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTXN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FCVTXN2 takes 2 operands")
    } else {
        return p.FCVTXN2(vv[0], vv[1])
    }
}

func __asm_proxy_FCVTZS__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.FCVTZS(vv[0], vv[1])
        case 3  : return p.FCVTZS(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction FCVTZS takes 2 or 3 operands")
    }
}

func __asm_proxy_FCVTZU__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.FCVTZU(vv[0], vv[1])
        case 3  : return p.FCVTZU(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction FCVTZU takes 2 or 3 operands")
    }
}

func __asm_proxy_FDIV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FDIV takes 3 operands")
    } else {
        return p.FDIV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FJCVTZS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FJCVTZS takes 2 operands")
    } else {
        return p.FJCVTZS(vv[0], vv[1])
    }
}

func __asm_proxy_FMADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FMADD takes 4 operands")
    } else {
        return p.FMADD(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FMAX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMAX takes 3 operands")
    } else {
        return p.FMAX(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMAXNM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMAXNM takes 3 operands")
    } else {
        return p.FMAXNM(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMAXNMP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.FMAXNMP(vv[0], vv[1])
        case 3  : return p.FMAXNMP(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction FMAXNMP takes 2 or 3 operands")
    }
}

func __asm_proxy_FMAXNMV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FMAXNMV takes 2 operands")
    } else {
        return p.FMAXNMV(vv[0], vv[1])
    }
}

func __asm_proxy_FMAXP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.FMAXP(vv[0], vv[1])
        case 3  : return p.FMAXP(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction FMAXP takes 2 or 3 operands")
    }
}

func __asm_proxy_FMAXV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FMAXV takes 2 operands")
    } else {
        return p.FMAXV(vv[0], vv[1])
    }
}

func __asm_proxy_FMIN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMIN takes 3 operands")
    } else {
        return p.FMIN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMINNM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMINNM takes 3 operands")
    } else {
        return p.FMINNM(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMINNMP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.FMINNMP(vv[0], vv[1])
        case 3  : return p.FMINNMP(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction FMINNMP takes 2 or 3 operands")
    }
}

func __asm_proxy_FMINNMV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FMINNMV takes 2 operands")
    } else {
        return p.FMINNMV(vv[0], vv[1])
    }
}

func __asm_proxy_FMINP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.FMINP(vv[0], vv[1])
        case 3  : return p.FMINP(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction FMINP takes 2 or 3 operands")
    }
}

func __asm_proxy_FMINV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FMINV takes 2 operands")
    } else {
        return p.FMINV(vv[0], vv[1])
    }
}

func __asm_proxy_FMLA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMLA takes 3 operands")
    } else {
        return p.FMLA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMLAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMLAL takes 3 operands")
    } else {
        return p.FMLAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMLAL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMLAL2 takes 3 operands")
    } else {
        return p.FMLAL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMLS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMLS takes 3 operands")
    } else {
        return p.FMLS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMLSL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMLSL takes 3 operands")
    } else {
        return p.FMLSL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMLSL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMLSL2 takes 3 operands")
    } else {
        return p.FMLSL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMOV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FMOV takes 2 operands")
    } else {
        return p.FMOV(vv[0], vv[1])
    }
}

func __asm_proxy_FMSUB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FMSUB takes 4 operands")
    } else {
        return p.FMSUB(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FMUL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMUL takes 3 operands")
    } else {
        return p.FMUL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FMULX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FMULX takes 3 operands")
    } else {
        return p.FMULX(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FNEG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FNEG takes 2 operands")
    } else {
        return p.FNEG(vv[0], vv[1])
    }
}

func __asm_proxy_FNMADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FNMADD takes 4 operands")
    } else {
        return p.FNMADD(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FNMSUB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction FNMSUB takes 4 operands")
    } else {
        return p.FNMSUB(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_FNMUL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FNMUL takes 3 operands")
    } else {
        return p.FNMUL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FRECPE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRECPE takes 2 operands")
    } else {
        return p.FRECPE(vv[0], vv[1])
    }
}

func __asm_proxy_FRECPS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FRECPS takes 3 operands")
    } else {
        return p.FRECPS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FRECPX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRECPX takes 2 operands")
    } else {
        return p.FRECPX(vv[0], vv[1])
    }
}

func __asm_proxy_FRINT32X__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINT32X takes 2 operands")
    } else {
        return p.FRINT32X(vv[0], vv[1])
    }
}

func __asm_proxy_FRINT32Z__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINT32Z takes 2 operands")
    } else {
        return p.FRINT32Z(vv[0], vv[1])
    }
}

func __asm_proxy_FRINT64X__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINT64X takes 2 operands")
    } else {
        return p.FRINT64X(vv[0], vv[1])
    }
}

func __asm_proxy_FRINT64Z__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINT64Z takes 2 operands")
    } else {
        return p.FRINT64Z(vv[0], vv[1])
    }
}

func __asm_proxy_FRINTA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINTA takes 2 operands")
    } else {
        return p.FRINTA(vv[0], vv[1])
    }
}

func __asm_proxy_FRINTI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINTI takes 2 operands")
    } else {
        return p.FRINTI(vv[0], vv[1])
    }
}

func __asm_proxy_FRINTM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINTM takes 2 operands")
    } else {
        return p.FRINTM(vv[0], vv[1])
    }
}

func __asm_proxy_FRINTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINTN takes 2 operands")
    } else {
        return p.FRINTN(vv[0], vv[1])
    }
}

func __asm_proxy_FRINTP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINTP takes 2 operands")
    } else {
        return p.FRINTP(vv[0], vv[1])
    }
}

func __asm_proxy_FRINTX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINTX takes 2 operands")
    } else {
        return p.FRINTX(vv[0], vv[1])
    }
}

func __asm_proxy_FRINTZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRINTZ takes 2 operands")
    } else {
        return p.FRINTZ(vv[0], vv[1])
    }
}

func __asm_proxy_FRSQRTE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FRSQRTE takes 2 operands")
    } else {
        return p.FRSQRTE(vv[0], vv[1])
    }
}

func __asm_proxy_FRSQRTS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FRSQRTS takes 3 operands")
    } else {
        return p.FRSQRTS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_FSQRT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction FSQRT takes 2 operands")
    } else {
        return p.FSQRT(vv[0], vv[1])
    }
}

func __asm_proxy_FSUB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction FSUB takes 3 operands")
    } else {
        return p.FSUB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_GCSB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction GCSB takes a single operand")
    } else {
        return p.GCSB(vv[0])
    }
}

func __asm_proxy_GCSPOPCX__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.GCSPOPCX()
        case 1  : return p.GCSPOPCX(vv[0])
        default : panic("aarch64: instruction GCSPOPCX takes 0 or 1 operands")
    }
}

func __asm_proxy_GCSPOPM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction GCSPOPM takes a single operand")
    } else {
        return p.GCSPOPM(vv[0])
    }
}

func __asm_proxy_GCSPOPX__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.GCSPOPX()
        case 1  : return p.GCSPOPX(vv[0])
        default : panic("aarch64: instruction GCSPOPX takes 0 or 1 operands")
    }
}

func __asm_proxy_GCSPUSHM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction GCSPUSHM takes a single operand")
    } else {
        return p.GCSPUSHM(vv[0])
    }
}

func __asm_proxy_GCSPUSHX__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.GCSPUSHX()
        case 1  : return p.GCSPUSHX(vv[0])
        default : panic("aarch64: instruction GCSPUSHX takes 0 or 1 operands")
    }
}

func __asm_proxy_GCSSS1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction GCSSS1 takes a single operand")
    } else {
        return p.GCSSS1(vv[0])
    }
}

func __asm_proxy_GCSSS2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction GCSSS2 takes a single operand")
    } else {
        return p.GCSSS2(vv[0])
    }
}

func __asm_proxy_GCSSTR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction GCSSTR takes 2 operands")
    } else {
        return p.GCSSTR(vv[0], vv[1])
    }
}

func __asm_proxy_GCSSTTR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction GCSSTTR takes 2 operands")
    } else {
        return p.GCSSTTR(vv[0], vv[1])
    }
}

func __asm_proxy_GMI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction GMI takes 3 operands")
    } else {
        return p.GMI(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_HINT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction HINT takes a single operand")
    } else {
        return p.HINT(vv[0])
    }
}

func __asm_proxy_HLT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction HLT takes a single operand")
    } else {
        return p.HLT(vv[0])
    }
}

func __asm_proxy_HVC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction HVC takes a single operand")
    } else {
        return p.HVC(vv[0])
    }
}

func __asm_proxy_IC__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 1  : return p.IC(vv[0])
        case 2  : return p.IC(vv[0], vv[1])
        default : panic("aarch64: instruction IC takes 1 or 2 operands")
    }
}

func __asm_proxy_INS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction INS takes 2 operands")
    } else {
        return p.INS(vv[0], vv[1])
    }
}

func __asm_proxy_IRG__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.IRG(vv[0], vv[1])
        case 3  : return p.IRG(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction IRG takes 2 or 3 operands")
    }
}

func __asm_proxy_ISB__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.ISB()
        case 1  : return p.ISB(vv[0])
        default : panic("aarch64: instruction ISB takes 0 or 1 operands")
    }
}

func __asm_proxy_LD1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD1 takes 2 operands")
    } else {
        return p.LD1(vv[0], vv[1])
    }
}

func __asm_proxy_LD1R__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD1R takes 2 operands")
    } else {
        return p.LD1R(vv[0], vv[1])
    }
}

func __asm_proxy_LD2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD2 takes 2 operands")
    } else {
        return p.LD2(vv[0], vv[1])
    }
}

func __asm_proxy_LD2R__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD2R takes 2 operands")
    } else {
        return p.LD2R(vv[0], vv[1])
    }
}

func __asm_proxy_LD3__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD3 takes 2 operands")
    } else {
        return p.LD3(vv[0], vv[1])
    }
}

func __asm_proxy_LD3R__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD3R takes 2 operands")
    } else {
        return p.LD3R(vv[0], vv[1])
    }
}

func __asm_proxy_LD4__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD4 takes 2 operands")
    } else {
        return p.LD4(vv[0], vv[1])
    }
}

func __asm_proxy_LD4R__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD4R takes 2 operands")
    } else {
        return p.LD4R(vv[0], vv[1])
    }
}

func __asm_proxy_LD64B__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LD64B takes 2 operands")
    } else {
        return p.LD64B(vv[0], vv[1])
    }
}

func __asm_proxy_LDADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADD takes 3 operands")
    } else {
        return p.LDADD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDA takes 3 operands")
    } else {
        return p.LDADDA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDAB takes 3 operands")
    } else {
        return p.LDADDAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDAH takes 3 operands")
    } else {
        return p.LDADDAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDAL takes 3 operands")
    } else {
        return p.LDADDAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDALB takes 3 operands")
    } else {
        return p.LDADDALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDALH takes 3 operands")
    } else {
        return p.LDADDALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDB takes 3 operands")
    } else {
        return p.LDADDB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDH takes 3 operands")
    } else {
        return p.LDADDH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDL takes 3 operands")
    } else {
        return p.LDADDL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDLB takes 3 operands")
    } else {
        return p.LDADDLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDADDLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDADDLH takes 3 operands")
    } else {
        return p.LDADDLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDAP1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAP1 takes 2 operands")
    } else {
        return p.LDAP1(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPR takes 2 operands")
    } else {
        return p.LDAPR(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPRB takes 2 operands")
    } else {
        return p.LDAPRB(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPRH takes 2 operands")
    } else {
        return p.LDAPRH(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPUR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPUR takes 2 operands")
    } else {
        return p.LDAPUR(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPURB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPURB takes 2 operands")
    } else {
        return p.LDAPURB(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPURH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPURH takes 2 operands")
    } else {
        return p.LDAPURH(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPURSB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPURSB takes 2 operands")
    } else {
        return p.LDAPURSB(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPURSH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPURSH takes 2 operands")
    } else {
        return p.LDAPURSH(vv[0], vv[1])
    }
}

func __asm_proxy_LDAPURSW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAPURSW takes 2 operands")
    } else {
        return p.LDAPURSW(vv[0], vv[1])
    }
}

func __asm_proxy_LDAR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAR takes 2 operands")
    } else {
        return p.LDAR(vv[0], vv[1])
    }
}

func __asm_proxy_LDARB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDARB takes 2 operands")
    } else {
        return p.LDARB(vv[0], vv[1])
    }
}

func __asm_proxy_LDARH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDARH takes 2 operands")
    } else {
        return p.LDARH(vv[0], vv[1])
    }
}

func __asm_proxy_LDAXP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDAXP takes 3 operands")
    } else {
        return p.LDAXP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDAXR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAXR takes 2 operands")
    } else {
        return p.LDAXR(vv[0], vv[1])
    }
}

func __asm_proxy_LDAXRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAXRB takes 2 operands")
    } else {
        return p.LDAXRB(vv[0], vv[1])
    }
}

func __asm_proxy_LDAXRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDAXRH takes 2 operands")
    } else {
        return p.LDAXRH(vv[0], vv[1])
    }
}

func __asm_proxy_LDCLR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLR takes 3 operands")
    } else {
        return p.LDCLR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRA takes 3 operands")
    } else {
        return p.LDCLRA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRAB takes 3 operands")
    } else {
        return p.LDCLRAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRAH takes 3 operands")
    } else {
        return p.LDCLRAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRAL takes 3 operands")
    } else {
        return p.LDCLRAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRALB takes 3 operands")
    } else {
        return p.LDCLRALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRALH takes 3 operands")
    } else {
        return p.LDCLRALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRB takes 3 operands")
    } else {
        return p.LDCLRB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRH takes 3 operands")
    } else {
        return p.LDCLRH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRL takes 3 operands")
    } else {
        return p.LDCLRL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRLB takes 3 operands")
    } else {
        return p.LDCLRLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRLH takes 3 operands")
    } else {
        return p.LDCLRLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRP takes 3 operands")
    } else {
        return p.LDCLRP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRPA takes 3 operands")
    } else {
        return p.LDCLRPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRPAL takes 3 operands")
    } else {
        return p.LDCLRPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDCLRPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDCLRPL takes 3 operands")
    } else {
        return p.LDCLRPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEOR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEOR takes 3 operands")
    } else {
        return p.LDEOR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORA takes 3 operands")
    } else {
        return p.LDEORA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORAB takes 3 operands")
    } else {
        return p.LDEORAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORAH takes 3 operands")
    } else {
        return p.LDEORAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORAL takes 3 operands")
    } else {
        return p.LDEORAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORALB takes 3 operands")
    } else {
        return p.LDEORALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORALH takes 3 operands")
    } else {
        return p.LDEORALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORB takes 3 operands")
    } else {
        return p.LDEORB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORH takes 3 operands")
    } else {
        return p.LDEORH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORL takes 3 operands")
    } else {
        return p.LDEORL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORLB takes 3 operands")
    } else {
        return p.LDEORLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDEORLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDEORLH takes 3 operands")
    } else {
        return p.LDEORLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDG takes 2 operands")
    } else {
        return p.LDG(vv[0], vv[1])
    }
}

func __asm_proxy_LDGM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDGM takes 2 operands")
    } else {
        return p.LDGM(vv[0], vv[1])
    }
}

func __asm_proxy_LDIAPP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDIAPP takes 3 operands")
    } else {
        return p.LDIAPP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDLAR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDLAR takes 2 operands")
    } else {
        return p.LDLAR(vv[0], vv[1])
    }
}

func __asm_proxy_LDLARB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDLARB takes 2 operands")
    } else {
        return p.LDLARB(vv[0], vv[1])
    }
}

func __asm_proxy_LDLARH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDLARH takes 2 operands")
    } else {
        return p.LDLARH(vv[0], vv[1])
    }
}

func __asm_proxy_LDNP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDNP takes 3 operands")
    } else {
        return p.LDNP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDP takes 3 operands")
    } else {
        return p.LDP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDPSW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDPSW takes 3 operands")
    } else {
        return p.LDPSW(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDR takes 2 operands")
    } else {
        return p.LDR(vv[0], vv[1])
    }
}

func __asm_proxy_LDRAA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDRAA takes 2 operands")
    } else {
        return p.LDRAA(vv[0], vv[1])
    }
}

func __asm_proxy_LDRAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDRAB takes 2 operands")
    } else {
        return p.LDRAB(vv[0], vv[1])
    }
}

func __asm_proxy_LDRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDRB takes 2 operands")
    } else {
        return p.LDRB(vv[0], vv[1])
    }
}

func __asm_proxy_LDRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDRH takes 2 operands")
    } else {
        return p.LDRH(vv[0], vv[1])
    }
}

func __asm_proxy_LDRSB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDRSB takes 2 operands")
    } else {
        return p.LDRSB(vv[0], vv[1])
    }
}

func __asm_proxy_LDRSH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDRSH takes 2 operands")
    } else {
        return p.LDRSH(vv[0], vv[1])
    }
}

func __asm_proxy_LDRSW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDRSW takes 2 operands")
    } else {
        return p.LDRSW(vv[0], vv[1])
    }
}

func __asm_proxy_LDSET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSET takes 3 operands")
    } else {
        return p.LDSET(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETA takes 3 operands")
    } else {
        return p.LDSETA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETAB takes 3 operands")
    } else {
        return p.LDSETAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETAH takes 3 operands")
    } else {
        return p.LDSETAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETAL takes 3 operands")
    } else {
        return p.LDSETAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETALB takes 3 operands")
    } else {
        return p.LDSETALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETALH takes 3 operands")
    } else {
        return p.LDSETALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETB takes 3 operands")
    } else {
        return p.LDSETB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETH takes 3 operands")
    } else {
        return p.LDSETH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETL takes 3 operands")
    } else {
        return p.LDSETL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETLB takes 3 operands")
    } else {
        return p.LDSETLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETLH takes 3 operands")
    } else {
        return p.LDSETLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETP takes 3 operands")
    } else {
        return p.LDSETP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETPA takes 3 operands")
    } else {
        return p.LDSETPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETPAL takes 3 operands")
    } else {
        return p.LDSETPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSETPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSETPL takes 3 operands")
    } else {
        return p.LDSETPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAX takes 3 operands")
    } else {
        return p.LDSMAX(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXA takes 3 operands")
    } else {
        return p.LDSMAXA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXAB takes 3 operands")
    } else {
        return p.LDSMAXAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXAH takes 3 operands")
    } else {
        return p.LDSMAXAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXAL takes 3 operands")
    } else {
        return p.LDSMAXAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXALB takes 3 operands")
    } else {
        return p.LDSMAXALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXALH takes 3 operands")
    } else {
        return p.LDSMAXALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXB takes 3 operands")
    } else {
        return p.LDSMAXB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXH takes 3 operands")
    } else {
        return p.LDSMAXH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXL takes 3 operands")
    } else {
        return p.LDSMAXL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXLB takes 3 operands")
    } else {
        return p.LDSMAXLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMAXLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMAXLH takes 3 operands")
    } else {
        return p.LDSMAXLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMIN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMIN takes 3 operands")
    } else {
        return p.LDSMIN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINA takes 3 operands")
    } else {
        return p.LDSMINA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINAB takes 3 operands")
    } else {
        return p.LDSMINAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINAH takes 3 operands")
    } else {
        return p.LDSMINAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINAL takes 3 operands")
    } else {
        return p.LDSMINAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINALB takes 3 operands")
    } else {
        return p.LDSMINALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINALH takes 3 operands")
    } else {
        return p.LDSMINALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINB takes 3 operands")
    } else {
        return p.LDSMINB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINH takes 3 operands")
    } else {
        return p.LDSMINH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINL takes 3 operands")
    } else {
        return p.LDSMINL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINLB takes 3 operands")
    } else {
        return p.LDSMINLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDSMINLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDSMINLH takes 3 operands")
    } else {
        return p.LDSMINLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDTR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDTR takes 2 operands")
    } else {
        return p.LDTR(vv[0], vv[1])
    }
}

func __asm_proxy_LDTRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDTRB takes 2 operands")
    } else {
        return p.LDTRB(vv[0], vv[1])
    }
}

func __asm_proxy_LDTRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDTRH takes 2 operands")
    } else {
        return p.LDTRH(vv[0], vv[1])
    }
}

func __asm_proxy_LDTRSB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDTRSB takes 2 operands")
    } else {
        return p.LDTRSB(vv[0], vv[1])
    }
}

func __asm_proxy_LDTRSH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDTRSH takes 2 operands")
    } else {
        return p.LDTRSH(vv[0], vv[1])
    }
}

func __asm_proxy_LDTRSW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDTRSW takes 2 operands")
    } else {
        return p.LDTRSW(vv[0], vv[1])
    }
}

func __asm_proxy_LDUMAX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAX takes 3 operands")
    } else {
        return p.LDUMAX(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXA takes 3 operands")
    } else {
        return p.LDUMAXA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXAB takes 3 operands")
    } else {
        return p.LDUMAXAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXAH takes 3 operands")
    } else {
        return p.LDUMAXAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXAL takes 3 operands")
    } else {
        return p.LDUMAXAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXALB takes 3 operands")
    } else {
        return p.LDUMAXALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXALH takes 3 operands")
    } else {
        return p.LDUMAXALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXB takes 3 operands")
    } else {
        return p.LDUMAXB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXH takes 3 operands")
    } else {
        return p.LDUMAXH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXL takes 3 operands")
    } else {
        return p.LDUMAXL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXLB takes 3 operands")
    } else {
        return p.LDUMAXLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMAXLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMAXLH takes 3 operands")
    } else {
        return p.LDUMAXLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMIN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMIN takes 3 operands")
    } else {
        return p.LDUMIN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINA takes 3 operands")
    } else {
        return p.LDUMINA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINAB takes 3 operands")
    } else {
        return p.LDUMINAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINAH takes 3 operands")
    } else {
        return p.LDUMINAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINAL takes 3 operands")
    } else {
        return p.LDUMINAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINALB takes 3 operands")
    } else {
        return p.LDUMINALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINALH takes 3 operands")
    } else {
        return p.LDUMINALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINB takes 3 operands")
    } else {
        return p.LDUMINB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINH takes 3 operands")
    } else {
        return p.LDUMINH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINL takes 3 operands")
    } else {
        return p.LDUMINL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINLB takes 3 operands")
    } else {
        return p.LDUMINLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUMINLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDUMINLH takes 3 operands")
    } else {
        return p.LDUMINLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDUR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDUR takes 2 operands")
    } else {
        return p.LDUR(vv[0], vv[1])
    }
}

func __asm_proxy_LDURB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDURB takes 2 operands")
    } else {
        return p.LDURB(vv[0], vv[1])
    }
}

func __asm_proxy_LDURH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDURH takes 2 operands")
    } else {
        return p.LDURH(vv[0], vv[1])
    }
}

func __asm_proxy_LDURSB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDURSB takes 2 operands")
    } else {
        return p.LDURSB(vv[0], vv[1])
    }
}

func __asm_proxy_LDURSH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDURSH takes 2 operands")
    } else {
        return p.LDURSH(vv[0], vv[1])
    }
}

func __asm_proxy_LDURSW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDURSW takes 2 operands")
    } else {
        return p.LDURSW(vv[0], vv[1])
    }
}

func __asm_proxy_LDXP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LDXP takes 3 operands")
    } else {
        return p.LDXP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LDXR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDXR takes 2 operands")
    } else {
        return p.LDXR(vv[0], vv[1])
    }
}

func __asm_proxy_LDXRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDXRB takes 2 operands")
    } else {
        return p.LDXRB(vv[0], vv[1])
    }
}

func __asm_proxy_LDXRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction LDXRH takes 2 operands")
    } else {
        return p.LDXRH(vv[0], vv[1])
    }
}

func __asm_proxy_LSL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LSL takes 3 operands")
    } else {
        return p.LSL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LSLV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LSLV takes 3 operands")
    } else {
        return p.LSLV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LSR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LSR takes 3 operands")
    } else {
        return p.LSR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_LSRV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction LSRV takes 3 operands")
    } else {
        return p.LSRV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_MADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction MADD takes 4 operands")
    } else {
        return p.MADD(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_MLA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction MLA takes 3 operands")
    } else {
        return p.MLA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_MLS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction MLS takes 3 operands")
    } else {
        return p.MLS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_MNEG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction MNEG takes 3 operands")
    } else {
        return p.MNEG(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_MOV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction MOV takes 2 operands")
    } else {
        return p.MOV(vv[0], vv[1])
    }
}

func __asm_proxy_MOVI__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.MOVI(vv[0], vv[1])
        case 3  : return p.MOVI(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction MOVI takes 2 or 3 operands")
    }
}

func __asm_proxy_MOVK__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.MOVK(vv[0], vv[1])
        case 3  : return p.MOVK(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction MOVK takes 2 or 3 operands")
    }
}

func __asm_proxy_MOVN__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.MOVN(vv[0], vv[1])
        case 3  : return p.MOVN(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction MOVN takes 2 or 3 operands")
    }
}

func __asm_proxy_MOVZ__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.MOVZ(vv[0], vv[1])
        case 3  : return p.MOVZ(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction MOVZ takes 2 or 3 operands")
    }
}

func __asm_proxy_MRRS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction MRRS takes 3 operands")
    } else {
        return p.MRRS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_MRS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction MRS takes 2 operands")
    } else {
        return p.MRS(vv[0], vv[1])
    }
}

func __asm_proxy_MSR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction MSR takes 2 operands")
    } else {
        return p.MSR(vv[0], vv[1])
    }
}

func __asm_proxy_MSRR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction MSRR takes 3 operands")
    } else {
        return p.MSRR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_MSUB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction MSUB takes 4 operands")
    } else {
        return p.MSUB(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_MUL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction MUL takes 3 operands")
    } else {
        return p.MUL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_MVN__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.MVN(vv[0], vv[1])
        case 3  : return p.MVN(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction MVN takes 2 or 3 operands")
    }
}

func __asm_proxy_MVNI__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.MVNI(vv[0], vv[1])
        case 3  : return p.MVNI(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction MVNI takes 2 or 3 operands")
    }
}

func __asm_proxy_NEG__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.NEG(vv[0], vv[1])
        case 3  : return p.NEG(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction NEG takes 2 or 3 operands")
    }
}

func __asm_proxy_NEGS__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.NEGS(vv[0], vv[1])
        case 3  : return p.NEGS(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction NEGS takes 2 or 3 operands")
    }
}

func __asm_proxy_NGC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction NGC takes 2 operands")
    } else {
        return p.NGC(vv[0], vv[1])
    }
}

func __asm_proxy_NGCS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction NGCS takes 2 operands")
    } else {
        return p.NGCS(vv[0], vv[1])
    }
}

func __asm_proxy_NOP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction NOP takes no operands")
    } else {
        return p.NOP()
    }
}

func __asm_proxy_NOT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction NOT takes 2 operands")
    } else {
        return p.NOT(vv[0], vv[1])
    }
}

func __asm_proxy_ORN__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.ORN(vv[0], vv[1], vv[2])
        case 4  : return p.ORN(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction ORN takes 3 or 4 operands")
    }
}

func __asm_proxy_ORR__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.ORR(vv[0], vv[1])
        case 3  : return p.ORR(vv[0], vv[1], vv[2])
        case 4  : return p.ORR(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction ORR takes 2 or 3 or 4 operands")
    }
}

func __asm_proxy_PACDA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction PACDA takes 2 operands")
    } else {
        return p.PACDA(vv[0], vv[1])
    }
}

func __asm_proxy_PACDB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction PACDB takes 2 operands")
    } else {
        return p.PACDB(vv[0], vv[1])
    }
}

func __asm_proxy_PACDZA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction PACDZA takes a single operand")
    } else {
        return p.PACDZA(vv[0])
    }
}

func __asm_proxy_PACDZB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction PACDZB takes a single operand")
    } else {
        return p.PACDZB(vv[0])
    }
}

func __asm_proxy_PACGA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction PACGA takes 3 operands")
    } else {
        return p.PACGA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_PACIA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction PACIA takes 2 operands")
    } else {
        return p.PACIA(vv[0], vv[1])
    }
}

func __asm_proxy_PACIA1716__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction PACIA1716 takes no operands")
    } else {
        return p.PACIA1716()
    }
}

func __asm_proxy_PACIASP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction PACIASP takes no operands")
    } else {
        return p.PACIASP()
    }
}

func __asm_proxy_PACIAZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction PACIAZ takes no operands")
    } else {
        return p.PACIAZ()
    }
}

func __asm_proxy_PACIB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction PACIB takes 2 operands")
    } else {
        return p.PACIB(vv[0], vv[1])
    }
}

func __asm_proxy_PACIB1716__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction PACIB1716 takes no operands")
    } else {
        return p.PACIB1716()
    }
}

func __asm_proxy_PACIBSP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction PACIBSP takes no operands")
    } else {
        return p.PACIBSP()
    }
}

func __asm_proxy_PACIBZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction PACIBZ takes no operands")
    } else {
        return p.PACIBZ()
    }
}

func __asm_proxy_PACIZA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction PACIZA takes a single operand")
    } else {
        return p.PACIZA(vv[0])
    }
}

func __asm_proxy_PACIZB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction PACIZB takes a single operand")
    } else {
        return p.PACIZB(vv[0])
    }
}

func __asm_proxy_PMUL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction PMUL takes 3 operands")
    } else {
        return p.PMUL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_PMULL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction PMULL takes 3 operands")
    } else {
        return p.PMULL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_PMULL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction PMULL2 takes 3 operands")
    } else {
        return p.PMULL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_PRFM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction PRFM takes 2 operands")
    } else {
        return p.PRFM(vv[0], vv[1])
    }
}

func __asm_proxy_PRFUM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction PRFUM takes 2 operands")
    } else {
        return p.PRFUM(vv[0], vv[1])
    }
}

func __asm_proxy_PSB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction PSB takes a single operand")
    } else {
        return p.PSB(vv[0])
    }
}

func __asm_proxy_PSSBB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction PSSBB takes no operands")
    } else {
        return p.PSSBB()
    }
}

func __asm_proxy_RADDHN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RADDHN takes 3 operands")
    } else {
        return p.RADDHN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RADDHN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RADDHN2 takes 3 operands")
    } else {
        return p.RADDHN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RAX1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RAX1 takes 3 operands")
    } else {
        return p.RAX1(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RBIT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction RBIT takes 2 operands")
    } else {
        return p.RBIT(vv[0], vv[1])
    }
}

func __asm_proxy_RCWCAS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCAS takes 3 operands")
    } else {
        return p.RCWCAS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCASA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCASA takes 3 operands")
    } else {
        return p.RCWCASA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCASAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCASAL takes 3 operands")
    } else {
        return p.RCWCASAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCASL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCASL takes 3 operands")
    } else {
        return p.RCWCASL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCASP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction RCWCASP takes 5 operands")
    } else {
        return p.RCWCASP(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_RCWCASPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction RCWCASPA takes 5 operands")
    } else {
        return p.RCWCASPA(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_RCWCASPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction RCWCASPAL takes 5 operands")
    } else {
        return p.RCWCASPAL(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_RCWCASPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction RCWCASPL takes 5 operands")
    } else {
        return p.RCWCASPL(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_RCWCLR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCLR takes 3 operands")
    } else {
        return p.RCWCLR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCLRA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCLRA takes 3 operands")
    } else {
        return p.RCWCLRA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCLRAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCLRAL takes 3 operands")
    } else {
        return p.RCWCLRAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCLRL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCLRL takes 3 operands")
    } else {
        return p.RCWCLRL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCLRP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCLRP takes 3 operands")
    } else {
        return p.RCWCLRP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCLRPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCLRPA takes 3 operands")
    } else {
        return p.RCWCLRPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCLRPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCLRPAL takes 3 operands")
    } else {
        return p.RCWCLRPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWCLRPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWCLRPL takes 3 operands")
    } else {
        return p.RCWCLRPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCAS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCAS takes 3 operands")
    } else {
        return p.RCWSCAS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCASA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCASA takes 3 operands")
    } else {
        return p.RCWSCASA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCASAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCASAL takes 3 operands")
    } else {
        return p.RCWSCASAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCASL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCASL takes 3 operands")
    } else {
        return p.RCWSCASL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCASP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction RCWSCASP takes 5 operands")
    } else {
        return p.RCWSCASP(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_RCWSCASPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction RCWSCASPA takes 5 operands")
    } else {
        return p.RCWSCASPA(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_RCWSCASPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction RCWSCASPAL takes 5 operands")
    } else {
        return p.RCWSCASPAL(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_RCWSCASPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction RCWSCASPL takes 5 operands")
    } else {
        return p.RCWSCASPL(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_RCWSCLR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCLR takes 3 operands")
    } else {
        return p.RCWSCLR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCLRA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCLRA takes 3 operands")
    } else {
        return p.RCWSCLRA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCLRAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCLRAL takes 3 operands")
    } else {
        return p.RCWSCLRAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCLRL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCLRL takes 3 operands")
    } else {
        return p.RCWSCLRL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCLRP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCLRP takes 3 operands")
    } else {
        return p.RCWSCLRP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCLRPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCLRPA takes 3 operands")
    } else {
        return p.RCWSCLRPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCLRPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCLRPAL takes 3 operands")
    } else {
        return p.RCWSCLRPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSCLRPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSCLRPL takes 3 operands")
    } else {
        return p.RCWSCLRPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSET takes 3 operands")
    } else {
        return p.RCWSET(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSETA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSETA takes 3 operands")
    } else {
        return p.RCWSETA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSETAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSETAL takes 3 operands")
    } else {
        return p.RCWSETAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSETL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSETL takes 3 operands")
    } else {
        return p.RCWSETL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSETP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSETP takes 3 operands")
    } else {
        return p.RCWSETP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSETPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSETPA takes 3 operands")
    } else {
        return p.RCWSETPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSETPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSETPAL takes 3 operands")
    } else {
        return p.RCWSETPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSETPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSETPL takes 3 operands")
    } else {
        return p.RCWSETPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSET takes 3 operands")
    } else {
        return p.RCWSSET(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSETA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSETA takes 3 operands")
    } else {
        return p.RCWSSETA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSETAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSETAL takes 3 operands")
    } else {
        return p.RCWSSETAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSETL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSETL takes 3 operands")
    } else {
        return p.RCWSSETL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSETP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSETP takes 3 operands")
    } else {
        return p.RCWSSETP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSETPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSETPA takes 3 operands")
    } else {
        return p.RCWSSETPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSETPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSETPAL takes 3 operands")
    } else {
        return p.RCWSSETPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSETPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSETPL takes 3 operands")
    } else {
        return p.RCWSSETPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSWP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSWP takes 3 operands")
    } else {
        return p.RCWSSWP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSWPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSWPA takes 3 operands")
    } else {
        return p.RCWSSWPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSWPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSWPAL takes 3 operands")
    } else {
        return p.RCWSSWPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSWPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSWPL takes 3 operands")
    } else {
        return p.RCWSSWPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSWPP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSWPP takes 3 operands")
    } else {
        return p.RCWSSWPP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSWPPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSWPPA takes 3 operands")
    } else {
        return p.RCWSSWPPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSWPPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSWPPAL takes 3 operands")
    } else {
        return p.RCWSSWPPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSSWPPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSSWPPL takes 3 operands")
    } else {
        return p.RCWSSWPPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSWP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSWP takes 3 operands")
    } else {
        return p.RCWSWP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSWPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSWPA takes 3 operands")
    } else {
        return p.RCWSWPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSWPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSWPAL takes 3 operands")
    } else {
        return p.RCWSWPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSWPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSWPL takes 3 operands")
    } else {
        return p.RCWSWPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSWPP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSWPP takes 3 operands")
    } else {
        return p.RCWSWPP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSWPPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSWPPA takes 3 operands")
    } else {
        return p.RCWSWPPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSWPPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSWPPAL takes 3 operands")
    } else {
        return p.RCWSWPPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RCWSWPPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RCWSWPPL takes 3 operands")
    } else {
        return p.RCWSWPPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RET__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.RET()
        case 1  : return p.RET(vv[0])
        default : panic("aarch64: instruction RET takes 0 or 1 operands")
    }
}

func __asm_proxy_RETAA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction RETAA takes no operands")
    } else {
        return p.RETAA()
    }
}

func __asm_proxy_RETAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction RETAB takes no operands")
    } else {
        return p.RETAB()
    }
}

func __asm_proxy_REV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction REV takes 2 operands")
    } else {
        return p.REV(vv[0], vv[1])
    }
}

func __asm_proxy_REV16__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction REV16 takes 2 operands")
    } else {
        return p.REV16(vv[0], vv[1])
    }
}

func __asm_proxy_REV32__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction REV32 takes 2 operands")
    } else {
        return p.REV32(vv[0], vv[1])
    }
}

func __asm_proxy_REV64__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction REV64 takes 2 operands")
    } else {
        return p.REV64(vv[0], vv[1])
    }
}

func __asm_proxy_RMIF__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RMIF takes 3 operands")
    } else {
        return p.RMIF(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ROR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ROR takes 3 operands")
    } else {
        return p.ROR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RORV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RORV takes 3 operands")
    } else {
        return p.RORV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RPRFM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RPRFM takes 3 operands")
    } else {
        return p.RPRFM(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RSHRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RSHRN takes 3 operands")
    } else {
        return p.RSHRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RSHRN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RSHRN2 takes 3 operands")
    } else {
        return p.RSHRN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RSUBHN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RSUBHN takes 3 operands")
    } else {
        return p.RSUBHN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_RSUBHN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction RSUBHN2 takes 3 operands")
    } else {
        return p.RSUBHN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SABA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SABA takes 3 operands")
    } else {
        return p.SABA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SABAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SABAL takes 3 operands")
    } else {
        return p.SABAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SABAL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SABAL2 takes 3 operands")
    } else {
        return p.SABAL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SABD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SABD takes 3 operands")
    } else {
        return p.SABD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SABDL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SABDL takes 3 operands")
    } else {
        return p.SABDL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SABDL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SABDL2 takes 3 operands")
    } else {
        return p.SABDL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SADALP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SADALP takes 2 operands")
    } else {
        return p.SADALP(vv[0], vv[1])
    }
}

func __asm_proxy_SADDL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SADDL takes 3 operands")
    } else {
        return p.SADDL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SADDL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SADDL2 takes 3 operands")
    } else {
        return p.SADDL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SADDLP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SADDLP takes 2 operands")
    } else {
        return p.SADDLP(vv[0], vv[1])
    }
}

func __asm_proxy_SADDLV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SADDLV takes 2 operands")
    } else {
        return p.SADDLV(vv[0], vv[1])
    }
}

func __asm_proxy_SADDW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SADDW takes 3 operands")
    } else {
        return p.SADDW(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SADDW2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SADDW2 takes 3 operands")
    } else {
        return p.SADDW2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction SB takes no operands")
    } else {
        return p.SB()
    }
}

func __asm_proxy_SBC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SBC takes 3 operands")
    } else {
        return p.SBC(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SBCS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SBCS takes 3 operands")
    } else {
        return p.SBCS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SBFIZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction SBFIZ takes 4 operands")
    } else {
        return p.SBFIZ(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_SBFM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction SBFM takes 4 operands")
    } else {
        return p.SBFM(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_SBFX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction SBFX takes 4 operands")
    } else {
        return p.SBFX(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_SCVTF__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.SCVTF(vv[0], vv[1])
        case 3  : return p.SCVTF(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction SCVTF takes 2 or 3 operands")
    }
}

func __asm_proxy_SDIV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SDIV takes 3 operands")
    } else {
        return p.SDIV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SDOT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SDOT takes 3 operands")
    } else {
        return p.SDOT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETE takes 3 operands")
    } else {
        return p.SETE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETEN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETEN takes 3 operands")
    } else {
        return p.SETEN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETET takes 3 operands")
    } else {
        return p.SETET(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETETN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETETN takes 3 operands")
    } else {
        return p.SETETN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETF16__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction SETF16 takes a single operand")
    } else {
        return p.SETF16(vv[0])
    }
}

func __asm_proxy_SETF8__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction SETF8 takes a single operand")
    } else {
        return p.SETF8(vv[0])
    }
}

func __asm_proxy_SETGE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGE takes 3 operands")
    } else {
        return p.SETGE(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGEN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGEN takes 3 operands")
    } else {
        return p.SETGEN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGET takes 3 operands")
    } else {
        return p.SETGET(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGETN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGETN takes 3 operands")
    } else {
        return p.SETGETN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGM takes 3 operands")
    } else {
        return p.SETGM(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGMN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGMN takes 3 operands")
    } else {
        return p.SETGMN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGMT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGMT takes 3 operands")
    } else {
        return p.SETGMT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGMTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGMTN takes 3 operands")
    } else {
        return p.SETGMTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGP takes 3 operands")
    } else {
        return p.SETGP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGPN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGPN takes 3 operands")
    } else {
        return p.SETGPN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGPT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGPT takes 3 operands")
    } else {
        return p.SETGPT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETGPTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETGPTN takes 3 operands")
    } else {
        return p.SETGPTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETM takes 3 operands")
    } else {
        return p.SETM(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETMN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETMN takes 3 operands")
    } else {
        return p.SETMN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETMT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETMT takes 3 operands")
    } else {
        return p.SETMT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETMTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETMTN takes 3 operands")
    } else {
        return p.SETMTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETP takes 3 operands")
    } else {
        return p.SETP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETPN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETPN takes 3 operands")
    } else {
        return p.SETPN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETPT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETPT takes 3 operands")
    } else {
        return p.SETPT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SETPTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SETPTN takes 3 operands")
    } else {
        return p.SETPTN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SEV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction SEV takes no operands")
    } else {
        return p.SEV()
    }
}

func __asm_proxy_SEVL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction SEVL takes no operands")
    } else {
        return p.SEVL()
    }
}

func __asm_proxy_SHA1C__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA1C takes 3 operands")
    } else {
        return p.SHA1C(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA1H__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SHA1H takes 2 operands")
    } else {
        return p.SHA1H(vv[0], vv[1])
    }
}

func __asm_proxy_SHA1M__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA1M takes 3 operands")
    } else {
        return p.SHA1M(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA1P__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA1P takes 3 operands")
    } else {
        return p.SHA1P(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA1SU0__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA1SU0 takes 3 operands")
    } else {
        return p.SHA1SU0(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA1SU1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SHA1SU1 takes 2 operands")
    } else {
        return p.SHA1SU1(vv[0], vv[1])
    }
}

func __asm_proxy_SHA256H__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA256H takes 3 operands")
    } else {
        return p.SHA256H(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA256H2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA256H2 takes 3 operands")
    } else {
        return p.SHA256H2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA256SU0__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SHA256SU0 takes 2 operands")
    } else {
        return p.SHA256SU0(vv[0], vv[1])
    }
}

func __asm_proxy_SHA256SU1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA256SU1 takes 3 operands")
    } else {
        return p.SHA256SU1(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA512H__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA512H takes 3 operands")
    } else {
        return p.SHA512H(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA512H2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA512H2 takes 3 operands")
    } else {
        return p.SHA512H2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHA512SU0__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SHA512SU0 takes 2 operands")
    } else {
        return p.SHA512SU0(vv[0], vv[1])
    }
}

func __asm_proxy_SHA512SU1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHA512SU1 takes 3 operands")
    } else {
        return p.SHA512SU1(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHADD takes 3 operands")
    } else {
        return p.SHADD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHL takes 3 operands")
    } else {
        return p.SHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHLL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHLL takes 3 operands")
    } else {
        return p.SHLL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHLL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHLL2 takes 3 operands")
    } else {
        return p.SHLL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHRN takes 3 operands")
    } else {
        return p.SHRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHRN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHRN2 takes 3 operands")
    } else {
        return p.SHRN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SHSUB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SHSUB takes 3 operands")
    } else {
        return p.SHSUB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SLI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SLI takes 3 operands")
    } else {
        return p.SLI(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SM3PARTW1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SM3PARTW1 takes 3 operands")
    } else {
        return p.SM3PARTW1(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SM3PARTW2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SM3PARTW2 takes 3 operands")
    } else {
        return p.SM3PARTW2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SM3SS1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction SM3SS1 takes 4 operands")
    } else {
        return p.SM3SS1(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_SM3TT1A__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SM3TT1A takes 3 operands")
    } else {
        return p.SM3TT1A(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SM3TT1B__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SM3TT1B takes 3 operands")
    } else {
        return p.SM3TT1B(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SM3TT2A__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SM3TT2A takes 3 operands")
    } else {
        return p.SM3TT2A(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SM3TT2B__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SM3TT2B takes 3 operands")
    } else {
        return p.SM3TT2B(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SM4E__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SM4E takes 2 operands")
    } else {
        return p.SM4E(vv[0], vv[1])
    }
}

func __asm_proxy_SM4EKEY__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SM4EKEY takes 3 operands")
    } else {
        return p.SM4EKEY(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMADDL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction SMADDL takes 4 operands")
    } else {
        return p.SMADDL(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_SMAX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMAX takes 3 operands")
    } else {
        return p.SMAX(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMAXP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMAXP takes 3 operands")
    } else {
        return p.SMAXP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMAXV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SMAXV takes 2 operands")
    } else {
        return p.SMAXV(vv[0], vv[1])
    }
}

func __asm_proxy_SMC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction SMC takes a single operand")
    } else {
        return p.SMC(vv[0])
    }
}

func __asm_proxy_SMIN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMIN takes 3 operands")
    } else {
        return p.SMIN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMINP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMINP takes 3 operands")
    } else {
        return p.SMINP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMINV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SMINV takes 2 operands")
    } else {
        return p.SMINV(vv[0], vv[1])
    }
}

func __asm_proxy_SMLAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMLAL takes 3 operands")
    } else {
        return p.SMLAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMLAL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMLAL2 takes 3 operands")
    } else {
        return p.SMLAL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMLSL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMLSL takes 3 operands")
    } else {
        return p.SMLSL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMLSL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMLSL2 takes 3 operands")
    } else {
        return p.SMLSL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMMLA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMMLA takes 3 operands")
    } else {
        return p.SMMLA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMNEGL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMNEGL takes 3 operands")
    } else {
        return p.SMNEGL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMOV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SMOV takes 2 operands")
    } else {
        return p.SMOV(vv[0], vv[1])
    }
}

func __asm_proxy_SMSTART__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.SMSTART()
        case 1  : return p.SMSTART(vv[0])
        default : panic("aarch64: instruction SMSTART takes 0 or 1 operands")
    }
}

func __asm_proxy_SMSTOP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 0  : return p.SMSTOP()
        case 1  : return p.SMSTOP(vv[0])
        default : panic("aarch64: instruction SMSTOP takes 0 or 1 operands")
    }
}

func __asm_proxy_SMSUBL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction SMSUBL takes 4 operands")
    } else {
        return p.SMSUBL(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_SMULH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMULH takes 3 operands")
    } else {
        return p.SMULH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMULL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMULL takes 3 operands")
    } else {
        return p.SMULL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SMULL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SMULL2 takes 3 operands")
    } else {
        return p.SMULL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQABS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SQABS takes 2 operands")
    } else {
        return p.SQABS(vv[0], vv[1])
    }
}

func __asm_proxy_SQADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQADD takes 3 operands")
    } else {
        return p.SQADD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQDMLAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQDMLAL takes 3 operands")
    } else {
        return p.SQDMLAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQDMLAL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQDMLAL2 takes 3 operands")
    } else {
        return p.SQDMLAL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQDMLSL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQDMLSL takes 3 operands")
    } else {
        return p.SQDMLSL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQDMLSL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQDMLSL2 takes 3 operands")
    } else {
        return p.SQDMLSL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQDMULH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQDMULH takes 3 operands")
    } else {
        return p.SQDMULH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQDMULL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQDMULL takes 3 operands")
    } else {
        return p.SQDMULL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQDMULL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQDMULL2 takes 3 operands")
    } else {
        return p.SQDMULL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQNEG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SQNEG takes 2 operands")
    } else {
        return p.SQNEG(vv[0], vv[1])
    }
}

func __asm_proxy_SQRDMLAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQRDMLAH takes 3 operands")
    } else {
        return p.SQRDMLAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQRDMLSH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQRDMLSH takes 3 operands")
    } else {
        return p.SQRDMLSH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQRDMULH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQRDMULH takes 3 operands")
    } else {
        return p.SQRDMULH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQRSHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQRSHL takes 3 operands")
    } else {
        return p.SQRSHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQRSHRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQRSHRN takes 3 operands")
    } else {
        return p.SQRSHRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQRSHRN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQRSHRN2 takes 3 operands")
    } else {
        return p.SQRSHRN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQRSHRUN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQRSHRUN takes 3 operands")
    } else {
        return p.SQRSHRUN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQRSHRUN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQRSHRUN2 takes 3 operands")
    } else {
        return p.SQRSHRUN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQSHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQSHL takes 3 operands")
    } else {
        return p.SQSHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQSHLU__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQSHLU takes 3 operands")
    } else {
        return p.SQSHLU(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQSHRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQSHRN takes 3 operands")
    } else {
        return p.SQSHRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQSHRN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQSHRN2 takes 3 operands")
    } else {
        return p.SQSHRN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQSHRUN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQSHRUN takes 3 operands")
    } else {
        return p.SQSHRUN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQSHRUN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQSHRUN2 takes 3 operands")
    } else {
        return p.SQSHRUN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQSUB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SQSUB takes 3 operands")
    } else {
        return p.SQSUB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SQXTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SQXTN takes 2 operands")
    } else {
        return p.SQXTN(vv[0], vv[1])
    }
}

func __asm_proxy_SQXTN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SQXTN2 takes 2 operands")
    } else {
        return p.SQXTN2(vv[0], vv[1])
    }
}

func __asm_proxy_SQXTUN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SQXTUN takes 2 operands")
    } else {
        return p.SQXTUN(vv[0], vv[1])
    }
}

func __asm_proxy_SQXTUN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SQXTUN2 takes 2 operands")
    } else {
        return p.SQXTUN2(vv[0], vv[1])
    }
}

func __asm_proxy_SRHADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SRHADD takes 3 operands")
    } else {
        return p.SRHADD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SRI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SRI takes 3 operands")
    } else {
        return p.SRI(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SRSHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SRSHL takes 3 operands")
    } else {
        return p.SRSHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SRSHR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SRSHR takes 3 operands")
    } else {
        return p.SRSHR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SRSRA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SRSRA takes 3 operands")
    } else {
        return p.SRSRA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSBB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction SSBB takes no operands")
    } else {
        return p.SSBB()
    }
}

func __asm_proxy_SSHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSHL takes 3 operands")
    } else {
        return p.SSHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSHLL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSHLL takes 3 operands")
    } else {
        return p.SSHLL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSHLL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSHLL2 takes 3 operands")
    } else {
        return p.SSHLL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSHR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSHR takes 3 operands")
    } else {
        return p.SSHR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSRA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSRA takes 3 operands")
    } else {
        return p.SSRA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSUBL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSUBL takes 3 operands")
    } else {
        return p.SSUBL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSUBL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSUBL2 takes 3 operands")
    } else {
        return p.SSUBL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSUBW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSUBW takes 3 operands")
    } else {
        return p.SSUBW(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SSUBW2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SSUBW2 takes 3 operands")
    } else {
        return p.SSUBW2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ST1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ST1 takes 2 operands")
    } else {
        return p.ST1(vv[0], vv[1])
    }
}

func __asm_proxy_ST2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ST2 takes 2 operands")
    } else {
        return p.ST2(vv[0], vv[1])
    }
}

func __asm_proxy_ST2G__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ST2G takes 2 operands")
    } else {
        return p.ST2G(vv[0], vv[1])
    }
}

func __asm_proxy_ST3__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ST3 takes 2 operands")
    } else {
        return p.ST3(vv[0], vv[1])
    }
}

func __asm_proxy_ST4__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ST4 takes 2 operands")
    } else {
        return p.ST4(vv[0], vv[1])
    }
}

func __asm_proxy_ST64B__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction ST64B takes 2 operands")
    } else {
        return p.ST64B(vv[0], vv[1])
    }
}

func __asm_proxy_ST64BV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ST64BV takes 3 operands")
    } else {
        return p.ST64BV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ST64BV0__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ST64BV0 takes 3 operands")
    } else {
        return p.ST64BV0(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STADD takes 2 operands")
    } else {
        return p.STADD(vv[0], vv[1])
    }
}

func __asm_proxy_STADDB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STADDB takes 2 operands")
    } else {
        return p.STADDB(vv[0], vv[1])
    }
}

func __asm_proxy_STADDH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STADDH takes 2 operands")
    } else {
        return p.STADDH(vv[0], vv[1])
    }
}

func __asm_proxy_STADDL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STADDL takes 2 operands")
    } else {
        return p.STADDL(vv[0], vv[1])
    }
}

func __asm_proxy_STADDLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STADDLB takes 2 operands")
    } else {
        return p.STADDLB(vv[0], vv[1])
    }
}

func __asm_proxy_STADDLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STADDLH takes 2 operands")
    } else {
        return p.STADDLH(vv[0], vv[1])
    }
}

func __asm_proxy_STCLR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STCLR takes 2 operands")
    } else {
        return p.STCLR(vv[0], vv[1])
    }
}

func __asm_proxy_STCLRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STCLRB takes 2 operands")
    } else {
        return p.STCLRB(vv[0], vv[1])
    }
}

func __asm_proxy_STCLRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STCLRH takes 2 operands")
    } else {
        return p.STCLRH(vv[0], vv[1])
    }
}

func __asm_proxy_STCLRL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STCLRL takes 2 operands")
    } else {
        return p.STCLRL(vv[0], vv[1])
    }
}

func __asm_proxy_STCLRLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STCLRLB takes 2 operands")
    } else {
        return p.STCLRLB(vv[0], vv[1])
    }
}

func __asm_proxy_STCLRLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STCLRLH takes 2 operands")
    } else {
        return p.STCLRLH(vv[0], vv[1])
    }
}

func __asm_proxy_STEOR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STEOR takes 2 operands")
    } else {
        return p.STEOR(vv[0], vv[1])
    }
}

func __asm_proxy_STEORB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STEORB takes 2 operands")
    } else {
        return p.STEORB(vv[0], vv[1])
    }
}

func __asm_proxy_STEORH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STEORH takes 2 operands")
    } else {
        return p.STEORH(vv[0], vv[1])
    }
}

func __asm_proxy_STEORL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STEORL takes 2 operands")
    } else {
        return p.STEORL(vv[0], vv[1])
    }
}

func __asm_proxy_STEORLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STEORLB takes 2 operands")
    } else {
        return p.STEORLB(vv[0], vv[1])
    }
}

func __asm_proxy_STEORLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STEORLH takes 2 operands")
    } else {
        return p.STEORLH(vv[0], vv[1])
    }
}

func __asm_proxy_STG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STG takes 2 operands")
    } else {
        return p.STG(vv[0], vv[1])
    }
}

func __asm_proxy_STGM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STGM takes 2 operands")
    } else {
        return p.STGM(vv[0], vv[1])
    }
}

func __asm_proxy_STGP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STGP takes 3 operands")
    } else {
        return p.STGP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STILP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STILP takes 3 operands")
    } else {
        return p.STILP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STL1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STL1 takes 2 operands")
    } else {
        return p.STL1(vv[0], vv[1])
    }
}

func __asm_proxy_STLLR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLLR takes 2 operands")
    } else {
        return p.STLLR(vv[0], vv[1])
    }
}

func __asm_proxy_STLLRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLLRB takes 2 operands")
    } else {
        return p.STLLRB(vv[0], vv[1])
    }
}

func __asm_proxy_STLLRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLLRH takes 2 operands")
    } else {
        return p.STLLRH(vv[0], vv[1])
    }
}

func __asm_proxy_STLR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLR takes 2 operands")
    } else {
        return p.STLR(vv[0], vv[1])
    }
}

func __asm_proxy_STLRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLRB takes 2 operands")
    } else {
        return p.STLRB(vv[0], vv[1])
    }
}

func __asm_proxy_STLRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLRH takes 2 operands")
    } else {
        return p.STLRH(vv[0], vv[1])
    }
}

func __asm_proxy_STLUR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLUR takes 2 operands")
    } else {
        return p.STLUR(vv[0], vv[1])
    }
}

func __asm_proxy_STLURB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLURB takes 2 operands")
    } else {
        return p.STLURB(vv[0], vv[1])
    }
}

func __asm_proxy_STLURH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STLURH takes 2 operands")
    } else {
        return p.STLURH(vv[0], vv[1])
    }
}

func __asm_proxy_STLXP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction STLXP takes 4 operands")
    } else {
        return p.STLXP(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_STLXR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STLXR takes 3 operands")
    } else {
        return p.STLXR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STLXRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STLXRB takes 3 operands")
    } else {
        return p.STLXRB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STLXRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STLXRH takes 3 operands")
    } else {
        return p.STLXRH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STNP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STNP takes 3 operands")
    } else {
        return p.STNP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STP takes 3 operands")
    } else {
        return p.STP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STR takes 2 operands")
    } else {
        return p.STR(vv[0], vv[1])
    }
}

func __asm_proxy_STRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STRB takes 2 operands")
    } else {
        return p.STRB(vv[0], vv[1])
    }
}

func __asm_proxy_STRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STRH takes 2 operands")
    } else {
        return p.STRH(vv[0], vv[1])
    }
}

func __asm_proxy_STSET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSET takes 2 operands")
    } else {
        return p.STSET(vv[0], vv[1])
    }
}

func __asm_proxy_STSETB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSETB takes 2 operands")
    } else {
        return p.STSETB(vv[0], vv[1])
    }
}

func __asm_proxy_STSETH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSETH takes 2 operands")
    } else {
        return p.STSETH(vv[0], vv[1])
    }
}

func __asm_proxy_STSETL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSETL takes 2 operands")
    } else {
        return p.STSETL(vv[0], vv[1])
    }
}

func __asm_proxy_STSETLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSETLB takes 2 operands")
    } else {
        return p.STSETLB(vv[0], vv[1])
    }
}

func __asm_proxy_STSETLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSETLH takes 2 operands")
    } else {
        return p.STSETLH(vv[0], vv[1])
    }
}

func __asm_proxy_STSMAX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMAX takes 2 operands")
    } else {
        return p.STSMAX(vv[0], vv[1])
    }
}

func __asm_proxy_STSMAXB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMAXB takes 2 operands")
    } else {
        return p.STSMAXB(vv[0], vv[1])
    }
}

func __asm_proxy_STSMAXH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMAXH takes 2 operands")
    } else {
        return p.STSMAXH(vv[0], vv[1])
    }
}

func __asm_proxy_STSMAXL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMAXL takes 2 operands")
    } else {
        return p.STSMAXL(vv[0], vv[1])
    }
}

func __asm_proxy_STSMAXLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMAXLB takes 2 operands")
    } else {
        return p.STSMAXLB(vv[0], vv[1])
    }
}

func __asm_proxy_STSMAXLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMAXLH takes 2 operands")
    } else {
        return p.STSMAXLH(vv[0], vv[1])
    }
}

func __asm_proxy_STSMIN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMIN takes 2 operands")
    } else {
        return p.STSMIN(vv[0], vv[1])
    }
}

func __asm_proxy_STSMINB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMINB takes 2 operands")
    } else {
        return p.STSMINB(vv[0], vv[1])
    }
}

func __asm_proxy_STSMINH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMINH takes 2 operands")
    } else {
        return p.STSMINH(vv[0], vv[1])
    }
}

func __asm_proxy_STSMINL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMINL takes 2 operands")
    } else {
        return p.STSMINL(vv[0], vv[1])
    }
}

func __asm_proxy_STSMINLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMINLB takes 2 operands")
    } else {
        return p.STSMINLB(vv[0], vv[1])
    }
}

func __asm_proxy_STSMINLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STSMINLH takes 2 operands")
    } else {
        return p.STSMINLH(vv[0], vv[1])
    }
}

func __asm_proxy_STTR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STTR takes 2 operands")
    } else {
        return p.STTR(vv[0], vv[1])
    }
}

func __asm_proxy_STTRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STTRB takes 2 operands")
    } else {
        return p.STTRB(vv[0], vv[1])
    }
}

func __asm_proxy_STTRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STTRH takes 2 operands")
    } else {
        return p.STTRH(vv[0], vv[1])
    }
}

func __asm_proxy_STUMAX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMAX takes 2 operands")
    } else {
        return p.STUMAX(vv[0], vv[1])
    }
}

func __asm_proxy_STUMAXB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMAXB takes 2 operands")
    } else {
        return p.STUMAXB(vv[0], vv[1])
    }
}

func __asm_proxy_STUMAXH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMAXH takes 2 operands")
    } else {
        return p.STUMAXH(vv[0], vv[1])
    }
}

func __asm_proxy_STUMAXL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMAXL takes 2 operands")
    } else {
        return p.STUMAXL(vv[0], vv[1])
    }
}

func __asm_proxy_STUMAXLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMAXLB takes 2 operands")
    } else {
        return p.STUMAXLB(vv[0], vv[1])
    }
}

func __asm_proxy_STUMAXLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMAXLH takes 2 operands")
    } else {
        return p.STUMAXLH(vv[0], vv[1])
    }
}

func __asm_proxy_STUMIN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMIN takes 2 operands")
    } else {
        return p.STUMIN(vv[0], vv[1])
    }
}

func __asm_proxy_STUMINB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMINB takes 2 operands")
    } else {
        return p.STUMINB(vv[0], vv[1])
    }
}

func __asm_proxy_STUMINH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMINH takes 2 operands")
    } else {
        return p.STUMINH(vv[0], vv[1])
    }
}

func __asm_proxy_STUMINL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMINL takes 2 operands")
    } else {
        return p.STUMINL(vv[0], vv[1])
    }
}

func __asm_proxy_STUMINLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMINLB takes 2 operands")
    } else {
        return p.STUMINLB(vv[0], vv[1])
    }
}

func __asm_proxy_STUMINLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUMINLH takes 2 operands")
    } else {
        return p.STUMINLH(vv[0], vv[1])
    }
}

func __asm_proxy_STUR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STUR takes 2 operands")
    } else {
        return p.STUR(vv[0], vv[1])
    }
}

func __asm_proxy_STURB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STURB takes 2 operands")
    } else {
        return p.STURB(vv[0], vv[1])
    }
}

func __asm_proxy_STURH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STURH takes 2 operands")
    } else {
        return p.STURH(vv[0], vv[1])
    }
}

func __asm_proxy_STXP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction STXP takes 4 operands")
    } else {
        return p.STXP(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_STXR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STXR takes 3 operands")
    } else {
        return p.STXR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STXRB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STXRB takes 3 operands")
    } else {
        return p.STXRB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STXRH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction STXRH takes 3 operands")
    } else {
        return p.STXRH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_STZ2G__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STZ2G takes 2 operands")
    } else {
        return p.STZ2G(vv[0], vv[1])
    }
}

func __asm_proxy_STZG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STZG takes 2 operands")
    } else {
        return p.STZG(vv[0], vv[1])
    }
}

func __asm_proxy_STZGM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction STZGM takes 2 operands")
    } else {
        return p.STZGM(vv[0], vv[1])
    }
}

func __asm_proxy_SUB__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.SUB(vv[0], vv[1], vv[2])
        case 4  : return p.SUB(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction SUB takes 3 or 4 operands")
    }
}

func __asm_proxy_SUBG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction SUBG takes 4 operands")
    } else {
        return p.SUBG(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_SUBHN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SUBHN takes 3 operands")
    } else {
        return p.SUBHN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SUBHN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SUBHN2 takes 3 operands")
    } else {
        return p.SUBHN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SUBP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SUBP takes 3 operands")
    } else {
        return p.SUBP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SUBPS__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SUBPS takes 3 operands")
    } else {
        return p.SUBPS(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SUBS__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 3  : return p.SUBS(vv[0], vv[1], vv[2])
        case 4  : return p.SUBS(vv[0], vv[1], vv[2], vv[3])
        default : panic("aarch64: instruction SUBS takes 3 or 4 operands")
    }
}

func __asm_proxy_SUDOT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SUDOT takes 3 operands")
    } else {
        return p.SUDOT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SUQADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SUQADD takes 2 operands")
    } else {
        return p.SUQADD(vv[0], vv[1])
    }
}

func __asm_proxy_SVC__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction SVC takes a single operand")
    } else {
        return p.SVC(vv[0])
    }
}

func __asm_proxy_SWP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWP takes 3 operands")
    } else {
        return p.SWP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPA takes 3 operands")
    } else {
        return p.SWPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPAB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPAB takes 3 operands")
    } else {
        return p.SWPAB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPAH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPAH takes 3 operands")
    } else {
        return p.SWPAH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPAL takes 3 operands")
    } else {
        return p.SWPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPALB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPALB takes 3 operands")
    } else {
        return p.SWPALB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPALH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPALH takes 3 operands")
    } else {
        return p.SWPALH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPB takes 3 operands")
    } else {
        return p.SWPB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPH takes 3 operands")
    } else {
        return p.SWPH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPL takes 3 operands")
    } else {
        return p.SWPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPLB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPLB takes 3 operands")
    } else {
        return p.SWPLB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPLH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPLH takes 3 operands")
    } else {
        return p.SWPLH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPP takes 3 operands")
    } else {
        return p.SWPP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPPA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPPA takes 3 operands")
    } else {
        return p.SWPPA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPPAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPPAL takes 3 operands")
    } else {
        return p.SWPPAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SWPPL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction SWPPL takes 3 operands")
    } else {
        return p.SWPPL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_SXTB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SXTB takes 2 operands")
    } else {
        return p.SXTB(vv[0], vv[1])
    }
}

func __asm_proxy_SXTH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SXTH takes 2 operands")
    } else {
        return p.SXTH(vv[0], vv[1])
    }
}

func __asm_proxy_SXTL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SXTL takes 2 operands")
    } else {
        return p.SXTL(vv[0], vv[1])
    }
}

func __asm_proxy_SXTL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SXTL2 takes 2 operands")
    } else {
        return p.SXTL2(vv[0], vv[1])
    }
}

func __asm_proxy_SXTW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction SXTW takes 2 operands")
    } else {
        return p.SXTW(vv[0], vv[1])
    }
}

func __asm_proxy_SYS__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 4  : return p.SYS(vv[0], vv[1], vv[2], vv[3])
        case 5  : return p.SYS(vv[0], vv[1], vv[2], vv[3], vv[4])
        default : panic("aarch64: instruction SYS takes 4 or 5 operands")
    }
}

func __asm_proxy_SYSL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 5 {
        panic("aarch64: instruction SYSL takes 5 operands")
    } else {
        return p.SYSL(vv[0], vv[1], vv[2], vv[3], vv[4])
    }
}

func __asm_proxy_SYSP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 4  : return p.SYSP(vv[0], vv[1], vv[2], vv[3])
        case 6  : return p.SYSP(vv[0], vv[1], vv[2], vv[3], vv[4], vv[5])
        default : panic("aarch64: instruction SYSP takes 4 or 6 operands")
    }
}

func __asm_proxy_TBL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction TBL takes 3 operands")
    } else {
        return p.TBL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_TBNZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction TBNZ takes 3 operands")
    } else {
        return p.TBNZ(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_TBX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction TBX takes 3 operands")
    } else {
        return p.TBX(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_TBZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction TBZ takes 3 operands")
    } else {
        return p.TBZ(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_TCANCEL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction TCANCEL takes a single operand")
    } else {
        return p.TCANCEL(vv[0])
    }
}

func __asm_proxy_TCOMMIT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction TCOMMIT takes no operands")
    } else {
        return p.TCOMMIT()
    }
}

func __asm_proxy_TLBI__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 1  : return p.TLBI(vv[0])
        case 2  : return p.TLBI(vv[0], vv[1])
        default : panic("aarch64: instruction TLBI takes 1 or 2 operands")
    }
}

func __asm_proxy_TLBIP__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 1  : return p.TLBIP(vv[0])
        case 3  : return p.TLBIP(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction TLBIP takes 1 or 3 operands")
    }
}

func __asm_proxy_TRCIT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction TRCIT takes a single operand")
    } else {
        return p.TRCIT(vv[0])
    }
}

func __asm_proxy_TRN1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction TRN1 takes 3 operands")
    } else {
        return p.TRN1(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_TRN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction TRN2 takes 3 operands")
    } else {
        return p.TRN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_TSB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction TSB takes a single operand")
    } else {
        return p.TSB(vv[0])
    }
}

func __asm_proxy_TST__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.TST(vv[0], vv[1])
        case 3  : return p.TST(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction TST takes 2 or 3 operands")
    }
}

func __asm_proxy_TSTART__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction TSTART takes a single operand")
    } else {
        return p.TSTART(vv[0])
    }
}

func __asm_proxy_TTEST__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction TTEST takes a single operand")
    } else {
        return p.TTEST(vv[0])
    }
}

func __asm_proxy_UABA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UABA takes 3 operands")
    } else {
        return p.UABA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UABAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UABAL takes 3 operands")
    } else {
        return p.UABAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UABAL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UABAL2 takes 3 operands")
    } else {
        return p.UABAL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UABD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UABD takes 3 operands")
    } else {
        return p.UABD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UABDL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UABDL takes 3 operands")
    } else {
        return p.UABDL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UABDL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UABDL2 takes 3 operands")
    } else {
        return p.UABDL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UADALP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UADALP takes 2 operands")
    } else {
        return p.UADALP(vv[0], vv[1])
    }
}

func __asm_proxy_UADDL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UADDL takes 3 operands")
    } else {
        return p.UADDL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UADDL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UADDL2 takes 3 operands")
    } else {
        return p.UADDL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UADDLP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UADDLP takes 2 operands")
    } else {
        return p.UADDLP(vv[0], vv[1])
    }
}

func __asm_proxy_UADDLV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UADDLV takes 2 operands")
    } else {
        return p.UADDLV(vv[0], vv[1])
    }
}

func __asm_proxy_UADDW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UADDW takes 3 operands")
    } else {
        return p.UADDW(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UADDW2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UADDW2 takes 3 operands")
    } else {
        return p.UADDW2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UBFIZ__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction UBFIZ takes 4 operands")
    } else {
        return p.UBFIZ(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_UBFM__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction UBFM takes 4 operands")
    } else {
        return p.UBFM(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_UBFX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction UBFX takes 4 operands")
    } else {
        return p.UBFX(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_UCVTF__(p *Program, vv ...interface{}) *Instruction {
    switch len(vv) {
        case 2  : return p.UCVTF(vv[0], vv[1])
        case 3  : return p.UCVTF(vv[0], vv[1], vv[2])
        default : panic("aarch64: instruction UCVTF takes 2 or 3 operands")
    }
}

func __asm_proxy_UDF__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction UDF takes a single operand")
    } else {
        return p.UDF(vv[0])
    }
}

func __asm_proxy_UDIV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UDIV takes 3 operands")
    } else {
        return p.UDIV(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UDOT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UDOT takes 3 operands")
    } else {
        return p.UDOT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UHADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UHADD takes 3 operands")
    } else {
        return p.UHADD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UHSUB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UHSUB takes 3 operands")
    } else {
        return p.UHSUB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMADDL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction UMADDL takes 4 operands")
    } else {
        return p.UMADDL(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_UMAX__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMAX takes 3 operands")
    } else {
        return p.UMAX(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMAXP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMAXP takes 3 operands")
    } else {
        return p.UMAXP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMAXV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UMAXV takes 2 operands")
    } else {
        return p.UMAXV(vv[0], vv[1])
    }
}

func __asm_proxy_UMIN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMIN takes 3 operands")
    } else {
        return p.UMIN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMINP__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMINP takes 3 operands")
    } else {
        return p.UMINP(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMINV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UMINV takes 2 operands")
    } else {
        return p.UMINV(vv[0], vv[1])
    }
}

func __asm_proxy_UMLAL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMLAL takes 3 operands")
    } else {
        return p.UMLAL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMLAL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMLAL2 takes 3 operands")
    } else {
        return p.UMLAL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMLSL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMLSL takes 3 operands")
    } else {
        return p.UMLSL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMLSL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMLSL2 takes 3 operands")
    } else {
        return p.UMLSL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMMLA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMMLA takes 3 operands")
    } else {
        return p.UMMLA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMNEGL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMNEGL takes 3 operands")
    } else {
        return p.UMNEGL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMOV__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UMOV takes 2 operands")
    } else {
        return p.UMOV(vv[0], vv[1])
    }
}

func __asm_proxy_UMSUBL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction UMSUBL takes 4 operands")
    } else {
        return p.UMSUBL(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_UMULH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMULH takes 3 operands")
    } else {
        return p.UMULH(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMULL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMULL takes 3 operands")
    } else {
        return p.UMULL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UMULL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UMULL2 takes 3 operands")
    } else {
        return p.UMULL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UQADD takes 3 operands")
    } else {
        return p.UQADD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQRSHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UQRSHL takes 3 operands")
    } else {
        return p.UQRSHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQRSHRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UQRSHRN takes 3 operands")
    } else {
        return p.UQRSHRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQRSHRN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UQRSHRN2 takes 3 operands")
    } else {
        return p.UQRSHRN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQSHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UQSHL takes 3 operands")
    } else {
        return p.UQSHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQSHRN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UQSHRN takes 3 operands")
    } else {
        return p.UQSHRN(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQSHRN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UQSHRN2 takes 3 operands")
    } else {
        return p.UQSHRN2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQSUB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UQSUB takes 3 operands")
    } else {
        return p.UQSUB(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UQXTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UQXTN takes 2 operands")
    } else {
        return p.UQXTN(vv[0], vv[1])
    }
}

func __asm_proxy_UQXTN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UQXTN2 takes 2 operands")
    } else {
        return p.UQXTN2(vv[0], vv[1])
    }
}

func __asm_proxy_URECPE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction URECPE takes 2 operands")
    } else {
        return p.URECPE(vv[0], vv[1])
    }
}

func __asm_proxy_URHADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction URHADD takes 3 operands")
    } else {
        return p.URHADD(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_URSHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction URSHL takes 3 operands")
    } else {
        return p.URSHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_URSHR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction URSHR takes 3 operands")
    } else {
        return p.URSHR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_URSQRTE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction URSQRTE takes 2 operands")
    } else {
        return p.URSQRTE(vv[0], vv[1])
    }
}

func __asm_proxy_URSRA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction URSRA takes 3 operands")
    } else {
        return p.URSRA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USDOT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USDOT takes 3 operands")
    } else {
        return p.USDOT(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USHL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USHL takes 3 operands")
    } else {
        return p.USHL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USHLL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USHLL takes 3 operands")
    } else {
        return p.USHLL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USHLL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USHLL2 takes 3 operands")
    } else {
        return p.USHLL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USHR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USHR takes 3 operands")
    } else {
        return p.USHR(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USMMLA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USMMLA takes 3 operands")
    } else {
        return p.USMMLA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USQADD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction USQADD takes 2 operands")
    } else {
        return p.USQADD(vv[0], vv[1])
    }
}

func __asm_proxy_USRA__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USRA takes 3 operands")
    } else {
        return p.USRA(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USUBL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USUBL takes 3 operands")
    } else {
        return p.USUBL(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USUBL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USUBL2 takes 3 operands")
    } else {
        return p.USUBL2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USUBW__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USUBW takes 3 operands")
    } else {
        return p.USUBW(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_USUBW2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction USUBW2 takes 3 operands")
    } else {
        return p.USUBW2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UXTB__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UXTB takes 2 operands")
    } else {
        return p.UXTB(vv[0], vv[1])
    }
}

func __asm_proxy_UXTH__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UXTH takes 2 operands")
    } else {
        return p.UXTH(vv[0], vv[1])
    }
}

func __asm_proxy_UXTL__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UXTL takes 2 operands")
    } else {
        return p.UXTL(vv[0], vv[1])
    }
}

func __asm_proxy_UXTL2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction UXTL2 takes 2 operands")
    } else {
        return p.UXTL2(vv[0], vv[1])
    }
}

func __asm_proxy_UZP1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UZP1 takes 3 operands")
    } else {
        return p.UZP1(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_UZP2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction UZP2 takes 3 operands")
    } else {
        return p.UZP2(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_WFE__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction WFE takes no operands")
    } else {
        return p.WFE()
    }
}

func __asm_proxy_WFET__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction WFET takes a single operand")
    } else {
        return p.WFET(vv[0])
    }
}

func __asm_proxy_WFI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction WFI takes no operands")
    } else {
        return p.WFI()
    }
}

func __asm_proxy_WFIT__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction WFIT takes a single operand")
    } else {
        return p.WFIT(vv[0])
    }
}

func __asm_proxy_XAFLAG__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction XAFLAG takes no operands")
    } else {
        return p.XAFLAG()
    }
}

func __asm_proxy_XAR__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 4 {
        panic("aarch64: instruction XAR takes 4 operands")
    } else {
        return p.XAR(vv[0], vv[1], vv[2], vv[3])
    }
}

func __asm_proxy_XPACD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction XPACD takes a single operand")
    } else {
        return p.XPACD(vv[0])
    }
}

func __asm_proxy_XPACI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 1 {
        panic("aarch64: instruction XPACI takes a single operand")
    } else {
        return p.XPACI(vv[0])
    }
}

func __asm_proxy_XPACLRI__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction XPACLRI takes no operands")
    } else {
        return p.XPACLRI()
    }
}

func __asm_proxy_XTN__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction XTN takes 2 operands")
    } else {
        return p.XTN(vv[0], vv[1])
    }
}

func __asm_proxy_XTN2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 2 {
        panic("aarch64: instruction XTN2 takes 2 operands")
    } else {
        return p.XTN2(vv[0], vv[1])
    }
}

func __asm_proxy_YIELD__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 0 {
        panic("aarch64: instruction YIELD takes no operands")
    } else {
        return p.YIELD()
    }
}

func __asm_proxy_ZIP1__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ZIP1 takes 3 operands")
    } else {
        return p.ZIP1(vv[0], vv[1], vv[2])
    }
}

func __asm_proxy_ZIP2__(p *Program, vv ...interface{}) *Instruction {
    if len(vv) != 3 {
        panic("aarch64: instruction ZIP2 takes 3 operands")
    } else {
        return p.ZIP2(vv[0], vv[1], vv[2])
    }
}
