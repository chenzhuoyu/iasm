// Code generated by "mkasm_aarch64.py", DO NOT EDIT.

package aarch64

// addsub_carry: Add/subtract (with carry)
func addsub_carry(sf, op, S, Rm, Rn, Rd uint32) uint32 {
    ret := uint32(0x1a000000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (Rm & 0x1f) << 16
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// addsub_ext: Add/subtract (extended register)
func addsub_ext(sf, op, S, opt, Rm, option, imm3, Rn, Rd uint32) uint32 {
    ret := uint32(0x0b200000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (opt & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (option & 0x7) << 13
    ret |= (imm3 & 0x7) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// addsub_imm: Add/subtract (immediate)
func addsub_imm(sf, op, S, sh, imm12, Rn, Rd uint32) uint32 {
    ret := uint32(0x11000000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (sh & 0x1) << 22
    ret |= (imm12 & 0xfff) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// addsub_immtags: Add/subtract (immediate, with tags)
func addsub_immtags(sf, op, S, uimm6, op3, uimm4, Rn, Rd uint32) uint32 {
    ret := uint32(0x11800000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (uimm6 & 0x3f) << 16
    ret |= (op3 & 0x3) << 14
    ret |= (uimm4 & 0xf) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// addsub_shift: Add/subtract (shifted register)
func addsub_shift(sf, op, S, shift, Rm, imm6, Rn, Rd uint32) uint32 {
    ret := uint32(0x0b000000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (shift & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (imm6 & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdall: Advanced SIMD across lanes
func asimdall(Q, U, size, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e300800)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (opcode & 0x1f) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimddiff: Advanced SIMD three different
func asimddiff(Q, U, size, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e200000)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0xf) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdelem: Advanced SIMD vector x indexed element
func asimdelem(Q, U, size, L, M, Rm, opcode, H, Rn, Rd uint32) uint32 {
    ret := uint32(0x0f000000)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (L & 0x1) << 21
    ret |= (M & 0x1) << 20
    ret |= (Rm & 0xf) << 16
    ret |= (opcode & 0xf) << 12
    ret |= (H & 0x1) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdext: Advanced SIMD extract
func asimdext(Q, op2, Rm, imm4, Rn, Rd uint32) uint32 {
    ret := uint32(0x2e000000)
    ret |= (Q & 0x1) << 30
    ret |= (op2 & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (imm4 & 0xf) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdimm: Advanced SIMD modified immediate
func asimdimm(Q, op, a, b, c, cmode, o2, d, e, f, g, h, Rd uint32) uint32 {
    ret := uint32(0x0f000400)
    ret |= (Q & 0x1) << 30
    ret |= (op & 0x1) << 29
    ret |= (a & 0x1) << 18
    ret |= (b & 0x1) << 17
    ret |= (c & 0x1) << 16
    ret |= (cmode & 0xf) << 12
    ret |= (o2 & 0x1) << 11
    ret |= (d & 0x1) << 9
    ret |= (e & 0x1) << 8
    ret |= (f & 0x1) << 7
    ret |= (g & 0x1) << 6
    ret |= (h & 0x1) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdins: Advanced SIMD copy
func asimdins(Q, op, imm5, imm4, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e000400)
    ret |= (Q & 0x1) << 30
    ret |= (op & 0x1) << 29
    ret |= (imm5 & 0x1f) << 16
    ret |= (imm4 & 0xf) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdmisc: Advanced SIMD two-register miscellaneous
func asimdmisc(Q, U, size, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e200800)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (opcode & 0x1f) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdmiscfp16: Advanced SIMD two-register miscellaneous (FP16)
func asimdmiscfp16(Q, U, a, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e780800)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (a & 0x1) << 23
    ret |= (opcode & 0x1f) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdperm: Advanced SIMD permute
func asimdperm(Q, size, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e000800)
    ret |= (Q & 0x1) << 30
    ret |= (size & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0x7) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdsame: Advanced SIMD three same
func asimdsame(Q, U, size, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e200400)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0x1f) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdsame2: Advanced SIMD three-register extension
func asimdsame2(Q, U, size, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e008400)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0xf) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdsamefp16: Advanced SIMD three same (FP16)
func asimdsamefp16(Q, U, a, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e400400)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (a & 0x1) << 23
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0x7) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdshf: Advanced SIMD shift by immediate
func asimdshf(Q, U, immh, immb, opcode, Rn, Rd uint32) uint32 {
    if immh == 0b0000 {
        panic("asimdshf: decode constraint is not satisfied: immh != 0000")
    }
    ret := uint32(0x0f000400)
    ret |= (Q & 0x1) << 30
    ret |= (U & 0x1) << 29
    ret |= (immh & 0xf) << 19
    ret |= (immb & 0x7) << 16
    ret |= (opcode & 0x1f) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asimdtbl: Advanced SIMD table lookup
func asimdtbl(Q, op2, Rm, len, op, Rn, Rd uint32) uint32 {
    ret := uint32(0x0e000000)
    ret |= (Q & 0x1) << 30
    ret |= (op2 & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (len & 0x3) << 13
    ret |= (op & 0x1) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisddiff: Advanced SIMD scalar three different
func asisddiff(U, size, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e200000)
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0xf) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdelem: Advanced SIMD scalar x indexed element
func asisdelem(U, size, L, M, Rm, opcode, H, Rn, Rd uint32) uint32 {
    ret := uint32(0x5f000000)
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (L & 0x1) << 21
    ret |= (M & 0x1) << 20
    ret |= (Rm & 0xf) << 16
    ret |= (opcode & 0xf) << 12
    ret |= (H & 0x1) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdlse: Advanced SIMD load/store multiple structures
func asisdlse(Q, L, opcode, size, Rn, Rt uint32) uint32 {
    ret := uint32(0x0c000000)
    ret |= (Q & 0x1) << 30
    ret |= (L & 0x1) << 22
    ret |= (opcode & 0xf) << 12
    ret |= (size & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// asisdlsep: Advanced SIMD load/store multiple structures (post-indexed)
func asisdlsep(Q, L, Rm, opcode, size, Rn, Rt uint32) uint32 {
    ret := uint32(0x0c800000)
    ret |= (Q & 0x1) << 30
    ret |= (L & 0x1) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0xf) << 12
    ret |= (size & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// asisdlso: Advanced SIMD load/store single structure
func asisdlso(Q, L, R, o2, opcode, S, size, Rn, Rt uint32) uint32 {
    ret := uint32(0x0d000000)
    ret |= (Q & 0x1) << 30
    ret |= (L & 0x1) << 22
    ret |= (R & 0x1) << 21
    ret |= (o2 & 0x1) << 16
    ret |= (opcode & 0x7) << 13
    ret |= (S & 0x1) << 12
    ret |= (size & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// asisdlsop: Advanced SIMD load/store single structure (post-indexed)
func asisdlsop(Q, L, R, Rm, opcode, S, size, Rn, Rt uint32) uint32 {
    ret := uint32(0x0d800000)
    ret |= (Q & 0x1) << 30
    ret |= (L & 0x1) << 22
    ret |= (R & 0x1) << 21
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0x7) << 13
    ret |= (S & 0x1) << 12
    ret |= (size & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// asisdmisc: Advanced SIMD scalar two-register miscellaneous
func asisdmisc(U, size, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e200800)
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (opcode & 0x1f) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdmiscfp16: Advanced SIMD scalar two-register miscellaneous FP16
func asisdmiscfp16(U, a, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e780800)
    ret |= (U & 0x1) << 29
    ret |= (a & 0x1) << 23
    ret |= (opcode & 0x1f) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdone: Advanced SIMD scalar copy
func asisdone(op, imm5, imm4, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e000400)
    ret |= (op & 0x1) << 29
    ret |= (imm5 & 0x1f) << 16
    ret |= (imm4 & 0xf) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdpair: Advanced SIMD scalar pairwise
func asisdpair(U, size, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e300800)
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (opcode & 0x1f) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdsame: Advanced SIMD scalar three same
func asisdsame(U, size, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e200400)
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0x1f) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdsame2: Advanced SIMD scalar three same extra
func asisdsame2(U, size, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e008400)
    ret |= (U & 0x1) << 29
    ret |= (size & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0xf) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdsamefp16: Advanced SIMD scalar three same FP16
func asisdsamefp16(U, a, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e400400)
    ret |= (U & 0x1) << 29
    ret |= (a & 0x1) << 23
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0x7) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// asisdshf: Advanced SIMD scalar shift by immediate
func asisdshf(U, immh, immb, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5f000400)
    ret |= (U & 0x1) << 29
    ret |= (immh & 0xf) << 19
    ret |= (immb & 0x7) << 16
    ret |= (opcode & 0x1f) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// barriers: Barriers
func barriers(CRm, op2, Rt uint32) uint32 {
    ret := uint32(0xd5033000)
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    ret |= Rt & 0x1f
    return ret;
}

// bitfield: Bitfield
func bitfield(sf, opc, N, immr, imms, Rn, Rd uint32) uint32 {
    ret := uint32(0x13000000)
    ret |= (sf & 0x1) << 31
    ret |= (opc & 0x3) << 29
    ret |= (N & 0x1) << 22
    ret |= (immr & 0x3f) << 16
    ret |= (imms & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// branch_imm: Unconditional branch (immediate)
func branch_imm(op, imm26 uint32) uint32 {
    ret := uint32(0x14000000)
    ret |= (op & 0x1) << 31
    ret |= imm26 & 0x3ffffff
    return ret;
}

// branch_reg: Unconditional branch (register)
func branch_reg(opc, op2, op3, Rn, op4 uint32) uint32 {
    ret := uint32(0xd6000000)
    ret |= (opc & 0xf) << 21
    ret |= (op2 & 0x1f) << 16
    ret |= (op3 & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= op4 & 0x1f
    return ret;
}

// compbranch: Compare and branch (immediate)
func compbranch(sf, op, imm19, Rt uint32) uint32 {
    ret := uint32(0x34000000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 24
    ret |= (imm19 & 0x7ffff) << 5
    ret |= Rt & 0x1f
    return ret;
}

// comswap: Compare and swap
func comswap(size, L, Rs, o0, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x08a00000)
    ret |= (size & 0x3) << 30
    ret |= (L & 0x1) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (o0 & 0x1) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// comswappr: Compare and swap pair
func comswappr(sz, L, Rs, o0, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x08200000)
    ret |= (sz & 0x1) << 30
    ret |= (L & 0x1) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (o0 & 0x1) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// condbranch: Conditional branch (immediate)
func condbranch(o1, imm19, o0, cond uint32) uint32 {
    ret := uint32(0x54000000)
    ret |= (o1 & 0x1) << 24
    ret |= (imm19 & 0x7ffff) << 5
    ret |= (o0 & 0x1) << 4
    ret |= cond & 0xf
    return ret;
}

// condcmp_imm: Conditional compare (immediate)
func condcmp_imm(sf, op, S, imm5, cond, o2, Rn, o3, nzcv uint32) uint32 {
    ret := uint32(0x1a400800)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (imm5 & 0x1f) << 16
    ret |= (cond & 0xf) << 12
    ret |= (o2 & 0x1) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= (o3 & 0x1) << 4
    ret |= nzcv & 0xf
    return ret;
}

// condcmp_reg: Conditional compare (register)
func condcmp_reg(sf, op, S, Rm, cond, o2, Rn, o3, nzcv uint32) uint32 {
    ret := uint32(0x1a400000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (Rm & 0x1f) << 16
    ret |= (cond & 0xf) << 12
    ret |= (o2 & 0x1) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= (o3 & 0x1) << 4
    ret |= nzcv & 0xf
    return ret;
}

// condsel: Conditional select
func condsel(sf, op, S, Rm, cond, op2, Rn, Rd uint32) uint32 {
    ret := uint32(0x1a800000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (Rm & 0x1f) << 16
    ret |= (cond & 0xf) << 12
    ret |= (op2 & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// crypto3_imm2: Cryptographic three-register, imm2
func crypto3_imm2(Rm, imm2, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0xce408000)
    ret |= (Rm & 0x1f) << 16
    ret |= (imm2 & 0x3) << 12
    ret |= (opcode & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// crypto3_imm6: Cryptographic three-register, imm6
func crypto3_imm6(Rm, imm6, Rn, Rd uint32) uint32 {
    ret := uint32(0xce800000)
    ret |= (Rm & 0x1f) << 16
    ret |= (imm6 & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// crypto4: Cryptographic four-register
func crypto4(Op0, Rm, Ra, Rn, Rd uint32) uint32 {
    ret := uint32(0xce000000)
    ret |= (Op0 & 0x3) << 21
    ret |= (Rm & 0x1f) << 16
    ret |= (Ra & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// cryptoaes: Cryptographic AES
func cryptoaes(size, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x4e280800)
    ret |= (size & 0x3) << 22
    ret |= (opcode & 0x1f) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// cryptosha2: Cryptographic two-register SHA
func cryptosha2(size, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e280800)
    ret |= (size & 0x3) << 22
    ret |= (opcode & 0x1f) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// cryptosha3: Cryptographic three-register SHA
func cryptosha3(size, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5e000000)
    ret |= (size & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0x7) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// cryptosha512_2: Cryptographic two-register SHA 512
func cryptosha512_2(opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0xcec08000)
    ret |= (opcode & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// cryptosha512_3: Cryptographic three-register SHA 512
func cryptosha512_3(Rm, O, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0xce608000)
    ret |= (Rm & 0x1f) << 16
    ret |= (O & 0x1) << 14
    ret |= (opcode & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// dp_1src: Data-processing (1 source)
func dp_1src(sf, S, opcode2, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x5ac00000)
    ret |= (sf & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (opcode2 & 0x1f) << 16
    ret |= (opcode & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// dp_2src: Data-processing (2 source)
func dp_2src(sf, S, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x1ac00000)
    ret |= (sf & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// dp_3src: Data-processing (3 source)
func dp_3src(sf, op54, op31, Rm, o0, Ra, Rn, Rd uint32) uint32 {
    ret := uint32(0x1b000000)
    ret |= (sf & 0x1) << 31
    ret |= (op54 & 0x3) << 29
    ret |= (op31 & 0x7) << 21
    ret |= (Rm & 0x1f) << 16
    ret |= (o0 & 0x1) << 15
    ret |= (Ra & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// exception: Exception generation
func exception(opc, imm16, op2, LL uint32) uint32 {
    ret := uint32(0xd4000000)
    ret |= (opc & 0x7) << 21
    ret |= (imm16 & 0xffff) << 5
    ret |= (op2 & 0x7) << 2
    ret |= LL & 0x3
    return ret;
}

// extract: Extract
func extract(sf, op21, N, o0, Rm, imms, Rn, Rd uint32) uint32 {
    ret := uint32(0x13800000)
    ret |= (sf & 0x1) << 31
    ret |= (op21 & 0x3) << 29
    ret |= (N & 0x1) << 22
    ret |= (o0 & 0x1) << 21
    ret |= (Rm & 0x1f) << 16
    ret |= (imms & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// float2fix: Conversion between floating-point and fixed-point
func float2fix(sf, S, ftype, rmode, opcode, scale, Rn, Rd uint32) uint32 {
    ret := uint32(0x1e000000)
    ret |= (sf & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (rmode & 0x3) << 19
    ret |= (opcode & 0x7) << 16
    ret |= (scale & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// float2int: Conversion between floating-point and integer
func float2int(sf, S, ftype, rmode, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x1e200000)
    ret |= (sf & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (rmode & 0x3) << 19
    ret |= (opcode & 0x7) << 16
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// floatccmp: Floating-point conditional compare
func floatccmp(M, S, ftype, Rm, cond, Rn, op, nzcv uint32) uint32 {
    ret := uint32(0x1e200400)
    ret |= (M & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (cond & 0xf) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= (op & 0x1) << 4
    ret |= nzcv & 0xf
    return ret;
}

// floatcmp: Floating-point compare
func floatcmp(M, S, ftype, Rm, op, Rn, opcode2 uint32) uint32 {
    ret := uint32(0x1e202000)
    ret |= (M & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (op & 0x3) << 14
    ret |= (Rn & 0x1f) << 5
    ret |= opcode2 & 0x1f
    return ret;
}

// floatdp1: Floating-point data-processing (1 source)
func floatdp1(M, S, ftype, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x1e204000)
    ret |= (M & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (opcode & 0x3f) << 15
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// floatdp2: Floating-point data-processing (2 source)
func floatdp2(M, S, ftype, Rm, opcode, Rn, Rd uint32) uint32 {
    ret := uint32(0x1e200800)
    ret |= (M & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (opcode & 0xf) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// floatdp3: Floating-point data-processing (3 source)
func floatdp3(M, S, ftype, o1, Rm, o0, Ra, Rn, Rd uint32) uint32 {
    ret := uint32(0x1f000000)
    ret |= (M & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (o1 & 0x1) << 21
    ret |= (Rm & 0x1f) << 16
    ret |= (o0 & 0x1) << 15
    ret |= (Ra & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// floatimm: Floating-point immediate
func floatimm(M, S, ftype, imm8, imm5, Rd uint32) uint32 {
    ret := uint32(0x1e201000)
    ret |= (M & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (imm8 & 0xff) << 13
    ret |= (imm5 & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// floatsel: Floating-point conditional select
func floatsel(M, S, ftype, Rm, cond, Rn, Rd uint32) uint32 {
    ret := uint32(0x1e200c00)
    ret |= (M & 0x1) << 31
    ret |= (S & 0x1) << 29
    ret |= (ftype & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (cond & 0xf) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// hints: Hints
func hints(CRm, op2 uint32) uint32 {
    ret := uint32(0xd503201f)
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    return ret;
}

// ldapstl_simd: LDAPR/STLR (SIMD&FP)
func ldapstl_simd(size, opc, imm9, Rn, Rt uint32) uint32 {
    ret := uint32(0x1d000800)
    ret |= (size & 0x3) << 30
    ret |= (opc & 0x3) << 22
    ret |= (imm9 & 0x1ff) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldapstl_unscaled: LDAPR/STLR (unscaled immediate)
func ldapstl_unscaled(size, opc, imm9, Rn, Rt uint32) uint32 {
    ret := uint32(0x19000000)
    ret |= (size & 0x3) << 30
    ret |= (opc & 0x3) << 22
    ret |= (imm9 & 0x1ff) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldapstl_writeback: LDAPR/STLR (writeback)
func ldapstl_writeback(size, L, Rn, Rt uint32) uint32 {
    ret := uint32(0x19800800)
    ret |= (size & 0x3) << 30
    ret |= (L & 0x1) << 22
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldiappstilp: LDIAPP/STILP
func ldiappstilp(size, L, Rt2, opc2, Rn, Rt uint32) uint32 {
    ret := uint32(0x19000800)
    ret |= (size & 0x3) << 30
    ret |= (L & 0x1) << 22
    ret |= (Rt2 & 0x1f) << 16
    ret |= (opc2 & 0xf) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldst_gcs: GCS load/store
func ldst_gcs(opc, Rn, Rt uint32) uint32 {
    ret := uint32(0xd91f0c00)
    ret |= (opc & 0x7) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldst_immpost: Load/store register (immediate post-indexed)
func ldst_immpost(size, V, opc, imm9, Rn, Rt uint32) uint32 {
    ret := uint32(0x38000400)
    ret |= (size & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (opc & 0x3) << 22
    ret |= (imm9 & 0x1ff) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldst_immpre: Load/store register (immediate pre-indexed)
func ldst_immpre(size, V, opc, imm9, Rn, Rt uint32) uint32 {
    ret := uint32(0x38000c00)
    ret |= (size & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (opc & 0x3) << 22
    ret |= (imm9 & 0x1ff) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldst_pac: Load/store register (pac)
func ldst_pac(size, V, M, S, imm9, W, Rn, Rt uint32) uint32 {
    ret := uint32(0x38200400)
    ret |= (size & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (M & 0x1) << 23
    ret |= (S & 0x1) << 22
    ret |= (imm9 & 0x1ff) << 12
    ret |= (W & 0x1) << 11
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldst_pos: Load/store register (unsigned immediate)
func ldst_pos(size, V, opc, imm12, Rn, Rt uint32) uint32 {
    ret := uint32(0x39000000)
    ret |= (size & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (opc & 0x3) << 22
    ret |= (imm12 & 0xfff) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldst_regoff: Load/store register (register offset)
func ldst_regoff(size, V, opc, Rm, option, S, Rn, Rt uint32) uint32 {
    ret := uint32(0x38200800)
    ret |= (size & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (opc & 0x3) << 22
    ret |= (Rm & 0x1f) << 16
    ret |= (option & 0x7) << 13
    ret |= (S & 0x1) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldst_unpriv: Load/store register (unprivileged)
func ldst_unpriv(size, V, opc, imm9, Rn, Rt uint32) uint32 {
    ret := uint32(0x38000800)
    ret |= (size & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (opc & 0x3) << 22
    ret |= (imm9 & 0x1ff) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldst_unscaled: Load/store register (unscaled immediate)
func ldst_unscaled(size, V, opc, imm9, Rn, Rt uint32) uint32 {
    ret := uint32(0x38000000)
    ret |= (size & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (opc & 0x3) << 22
    ret |= (imm9 & 0x1ff) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldstexclp: Load/store exclusive pair
func ldstexclp(sz, L, Rs, o0, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x88200000)
    ret |= (sz & 0x1) << 30
    ret |= (L & 0x1) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (o0 & 0x1) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldstexclr: Load/store exclusive register
func ldstexclr(size, L, Rs, o0, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x08000000)
    ret |= (size & 0x3) << 30
    ret |= (L & 0x1) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (o0 & 0x1) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldstnapair_offs: Load/store no-allocate pair (offset)
func ldstnapair_offs(opc, V, L, imm7, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x28000000)
    ret |= (opc & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (L & 0x1) << 22
    ret |= (imm7 & 0x7f) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldstord: Load/store ordered
func ldstord(size, L, Rs, o0, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x08800000)
    ret |= (size & 0x3) << 30
    ret |= (L & 0x1) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (o0 & 0x1) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldstpair_off: Load/store register pair (offset)
func ldstpair_off(opc, V, L, imm7, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x29000000)
    ret |= (opc & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (L & 0x1) << 22
    ret |= (imm7 & 0x7f) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldstpair_post: Load/store register pair (post-indexed)
func ldstpair_post(opc, V, L, imm7, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x28800000)
    ret |= (opc & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (L & 0x1) << 22
    ret |= (imm7 & 0x7f) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldstpair_pre: Load/store register pair (pre-indexed)
func ldstpair_pre(opc, V, L, imm7, Rt2, Rn, Rt uint32) uint32 {
    ret := uint32(0x29800000)
    ret |= (opc & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (L & 0x1) << 22
    ret |= (imm7 & 0x7f) << 15
    ret |= (Rt2 & 0x1f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// ldsttags: Load/store memory tags
func ldsttags(opc, imm9, op2, Rn, Rt uint32) uint32 {
    ret := uint32(0xd9200000)
    ret |= (opc & 0x3) << 22
    ret |= (imm9 & 0x1ff) << 12
    ret |= (op2 & 0x3) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// loadlit: Load register (literal)
func loadlit(opc, V, imm19, Rt uint32) uint32 {
    ret := uint32(0x18000000)
    ret |= (opc & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (imm19 & 0x7ffff) << 5
    ret |= Rt & 0x1f
    return ret;
}

// log_imm: Logical (immediate)
func log_imm(sf, opc, N, immr, imms, Rn, Rd uint32) uint32 {
    ret := uint32(0x12000000)
    ret |= (sf & 0x1) << 31
    ret |= (opc & 0x3) << 29
    ret |= (N & 0x1) << 22
    ret |= (immr & 0x3f) << 16
    ret |= (imms & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// log_shift: Logical (shifted register)
func log_shift(sf, opc, shift, N, Rm, imm6, Rn, Rd uint32) uint32 {
    ret := uint32(0x0a000000)
    ret |= (sf & 0x1) << 31
    ret |= (opc & 0x3) << 29
    ret |= (shift & 0x3) << 22
    ret |= (N & 0x1) << 21
    ret |= (Rm & 0x1f) << 16
    ret |= (imm6 & 0x3f) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// memcms: Memory Copy and Memory Set
func memcms(size, o0, op1, Rs, op2, Rn, Rd uint32) uint32 {
    ret := uint32(0x19000400)
    ret |= (size & 0x3) << 30
    ret |= (o0 & 0x1) << 26
    ret |= (op1 & 0x3) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (op2 & 0xf) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// memop: Atomic memory operations
func memop(size, V, A, R, Rs, o3, opc, Rn, Rt uint32) uint32 {
    ret := uint32(0x38200000)
    ret |= (size & 0x3) << 30
    ret |= (V & 0x1) << 26
    ret |= (A & 0x1) << 23
    ret |= (R & 0x1) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (o3 & 0x1) << 15
    ret |= (opc & 0x7) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// memop_128: 128-bit atomic memory operations
func memop_128(S, A, R, Rt2, o3, opc, Rn, Rt uint32) uint32 {
    ret := uint32(0x19200000)
    ret |= (S & 0x1) << 30
    ret |= (A & 0x1) << 23
    ret |= (R & 0x1) << 22
    ret |= (Rt2 & 0x1f) << 16
    ret |= (o3 & 0x1) << 15
    ret |= (opc & 0x7) << 12
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// minmax_imm: Min/max (immediate)
func minmax_imm(sf, op, S, opc, imm8, Rn, Rd uint32) uint32 {
    ret := uint32(0x11c00000)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (opc & 0xf) << 18
    ret |= (imm8 & 0xff) << 10
    ret |= (Rn & 0x1f) << 5
    ret |= Rd & 0x1f
    return ret;
}

// movewide: Move wide (immediate)
func movewide(sf, opc, hw, imm16, Rd uint32) uint32 {
    ret := uint32(0x12800000)
    ret |= (sf & 0x1) << 31
    ret |= (opc & 0x3) << 29
    ret |= (hw & 0x3) << 21
    ret |= (imm16 & 0xffff) << 5
    ret |= Rd & 0x1f
    return ret;
}

// pcreladdr: PC-rel. addressing
func pcreladdr(op, immlo, immhi, Rd uint32) uint32 {
    ret := uint32(0x10000000)
    ret |= (op & 0x1) << 31
    ret |= (immlo & 0x3) << 29
    ret |= (immhi & 0x7ffff) << 5
    ret |= Rd & 0x1f
    return ret;
}

// perm_undef: Reserved
func perm_undef(imm16 uint32) uint32 {
    ret := uint32(0x00000000)
    ret |= imm16 & 0xffff
    return ret;
}

// pstate: PSTATE
func pstate(op1, CRm, op2, Rt uint32) uint32 {
    ret := uint32(0xd5004000)
    ret |= (op1 & 0x7) << 16
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    ret |= Rt & 0x1f
    return ret;
}

// rcwcomswap: RCW compare and swap
func rcwcomswap(S, A, R, Rs, Rn, Rt uint32) uint32 {
    ret := uint32(0x19200800)
    ret |= (S & 0x1) << 30
    ret |= (A & 0x1) << 23
    ret |= (R & 0x1) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// rcwcomswappr: RCW compare and swap pair
func rcwcomswappr(S, A, R, Rs, Rn, Rt uint32) uint32 {
    ret := uint32(0x19200c00)
    ret |= (S & 0x1) << 30
    ret |= (A & 0x1) << 23
    ret |= (R & 0x1) << 22
    ret |= (Rs & 0x1f) << 16
    ret |= (Rn & 0x1f) << 5
    ret |= Rt & 0x1f
    return ret;
}

// rmif: Rotate right into flags
func rmif(sf, op, S, imm6, Rn, o2, mask uint32) uint32 {
    ret := uint32(0x1a000400)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (imm6 & 0x3f) << 15
    ret |= (Rn & 0x1f) << 5
    ret |= (o2 & 0x1) << 4
    ret |= mask & 0xf
    return ret;
}

// setf: Evaluate into flags
func setf(sf, op, S, opcode2, sz, Rn, o3, mask uint32) uint32 {
    ret := uint32(0x1a000800)
    ret |= (sf & 0x1) << 31
    ret |= (op & 0x1) << 30
    ret |= (S & 0x1) << 29
    ret |= (opcode2 & 0x3f) << 15
    ret |= (sz & 0x1) << 14
    ret |= (Rn & 0x1f) << 5
    ret |= (o3 & 0x1) << 4
    ret |= mask & 0xf
    return ret;
}

// syspairinstrs: System pair instructions
func syspairinstrs(L, op1, CRn, CRm, op2, Rt uint32) uint32 {
    ret := uint32(0xd5480000)
    ret |= (L & 0x1) << 21
    ret |= (op1 & 0x7) << 16
    ret |= (CRn & 0xf) << 12
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    ret |= Rt & 0x1f
    return ret;
}

// systeminstrs: System instructions
func systeminstrs(L, op1, CRn, CRm, op2, Rt uint32) uint32 {
    ret := uint32(0xd5080000)
    ret |= (L & 0x1) << 21
    ret |= (op1 & 0x7) << 16
    ret |= (CRn & 0xf) << 12
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    ret |= Rt & 0x1f
    return ret;
}

// systeminstrswithreg: System instructions with register argument
func systeminstrswithreg(CRm, op2, Rt uint32) uint32 {
    ret := uint32(0xd5031000)
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    ret |= Rt & 0x1f
    return ret;
}

// systemmove: System register move
func systemmove(L, o0, op1, CRn, CRm, op2, Rt uint32) uint32 {
    ret := uint32(0xd5100000)
    ret |= (L & 0x1) << 21
    ret |= (o0 & 0x1) << 19
    ret |= (op1 & 0x7) << 16
    ret |= (CRn & 0xf) << 12
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    ret |= Rt & 0x1f
    return ret;
}

// systemmovepr: System register pair move
func systemmovepr(L, o0, op1, CRn, CRm, op2, Rt uint32) uint32 {
    ret := uint32(0xd5500000)
    ret |= (L & 0x1) << 21
    ret |= (o0 & 0x1) << 19
    ret |= (op1 & 0x7) << 16
    ret |= (CRn & 0xf) << 12
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    ret |= Rt & 0x1f
    return ret;
}

// systemresult: System with result
func systemresult(op1, CRn, CRm, op2, Rt uint32) uint32 {
    ret := uint32(0xd5200000)
    ret |= (op1 & 0x7) << 16
    ret |= (CRn & 0xf) << 12
    ret |= (CRm & 0xf) << 8
    ret |= (op2 & 0x7) << 5
    ret |= Rt & 0x1f
    return ret;
}

// testbranch: Test and branch (immediate)
func testbranch(b5, op, b40, imm14, Rt uint32) uint32 {
    ret := uint32(0x36000000)
    ret |= (b5 & 0x1) << 31
    ret |= (op & 0x1) << 24
    ret |= (b40 & 0x1f) << 19
    ret |= (imm14 & 0x3fff) << 5
    ret |= Rt & 0x1f
    return ret;
}
