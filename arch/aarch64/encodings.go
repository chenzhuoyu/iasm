// Code generated by "mkasm_aarch64.py", DO NOT EDIT.

package aarch64

// addsub_carry: Add/subtract (with carry)
func addsub_carry(sf, op, S, Rm, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("addsub_carry: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("addsub_carry: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("addsub_carry: invalid S")
    }
    if Rm &^ 0b11111 != 0 {
        panic("addsub_carry: invalid Rm")
    }
    if Rn &^ 0b11111 != 0 {
        panic("addsub_carry: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("addsub_carry: invalid Rd")
    }
    ret := uint32(0x1a000000)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= Rm << 16
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// addsub_ext: Add/subtract (extended register)
func addsub_ext(sf, op, S, opt, Rm, option, imm3, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("addsub_ext: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("addsub_ext: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("addsub_ext: invalid S")
    }
    if opt &^ 0b11 != 0 {
        panic("addsub_ext: invalid opt")
    }
    if Rm &^ 0b11111 != 0 {
        panic("addsub_ext: invalid Rm")
    }
    if option &^ 0b111 != 0 {
        panic("addsub_ext: invalid option")
    }
    if imm3 &^ 0b111 != 0 {
        panic("addsub_ext: invalid imm3")
    }
    if Rn &^ 0b11111 != 0 {
        panic("addsub_ext: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("addsub_ext: invalid Rd")
    }
    ret := uint32(0x0b200000)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= opt << 22
    ret |= Rm << 16
    ret |= option << 13
    ret |= imm3 << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// addsub_imm: Add/subtract (immediate)
func addsub_imm(sf, op, S, sh, imm12, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("addsub_imm: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("addsub_imm: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("addsub_imm: invalid S")
    }
    if sh &^ 0b1 != 0 {
        panic("addsub_imm: invalid sh")
    }
    if imm12 &^ 0b111111111111 != 0 {
        panic("addsub_imm: invalid imm12")
    }
    if Rn &^ 0b11111 != 0 {
        panic("addsub_imm: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("addsub_imm: invalid Rd")
    }
    ret := uint32(0x11000000)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= sh << 22
    ret |= imm12 << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// addsub_immtags: Add/subtract (immediate, with tags)
func addsub_immtags(sf, op, S, o2, uimm6, op3, uimm4, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("addsub_immtags: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("addsub_immtags: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("addsub_immtags: invalid S")
    }
    if o2 &^ 0b1 != 0 {
        panic("addsub_immtags: invalid o2")
    }
    if uimm6 &^ 0b111111 != 0 {
        panic("addsub_immtags: invalid uimm6")
    }
    if op3 &^ 0b11 != 0 {
        panic("addsub_immtags: invalid op3")
    }
    if uimm4 &^ 0b1111 != 0 {
        panic("addsub_immtags: invalid uimm4")
    }
    if Rn &^ 0b11111 != 0 {
        panic("addsub_immtags: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("addsub_immtags: invalid Rd")
    }
    ret := uint32(0x11800000)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= o2 << 22
    ret |= uimm6 << 16
    ret |= op3 << 14
    ret |= uimm4 << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// addsub_shift: Add/subtract (shifted register)
func addsub_shift(sf, op, S, shift, Rm, imm6, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("addsub_shift: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("addsub_shift: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("addsub_shift: invalid S")
    }
    if shift &^ 0b11 != 0 {
        panic("addsub_shift: invalid shift")
    }
    if Rm &^ 0b11111 != 0 {
        panic("addsub_shift: invalid Rm")
    }
    if imm6 &^ 0b111111 != 0 {
        panic("addsub_shift: invalid imm6")
    }
    if Rn &^ 0b11111 != 0 {
        panic("addsub_shift: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("addsub_shift: invalid Rd")
    }
    ret := uint32(0x0b000000)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= shift << 22
    ret |= Rm << 16
    ret |= imm6 << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdall: Advanced SIMD across lanes
func asimdall(Q, U, size, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdall: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimdall: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asimdall: invalid size")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asimdall: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdall: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdall: invalid Rd")
    }
    ret := uint32(0x0e300800)
    ret |= Q << 30
    ret |= U << 29
    ret |= size << 22
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimddiff: Advanced SIMD three different
func asimddiff(Q, U, size, Rm, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimddiff: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimddiff: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asimddiff: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asimddiff: invalid Rm")
    }
    if opcode &^ 0b1111 != 0 {
        panic("asimddiff: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimddiff: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimddiff: invalid Rd")
    }
    ret := uint32(0x0e200000)
    ret |= Q << 30
    ret |= U << 29
    ret |= size << 22
    ret |= Rm << 16
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdelem: Advanced SIMD vector x indexed element
func asimdelem(Q, U, size, L, M, Rm, opcode, H, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdelem: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimdelem: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asimdelem: invalid size")
    }
    if L &^ 0b1 != 0 {
        panic("asimdelem: invalid L")
    }
    if M &^ 0b1 != 0 {
        panic("asimdelem: invalid M")
    }
    if Rm &^ 0b1111 != 0 {
        panic("asimdelem: invalid Rm")
    }
    if opcode &^ 0b1111 != 0 {
        panic("asimdelem: invalid opcode")
    }
    if H &^ 0b1 != 0 {
        panic("asimdelem: invalid H")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdelem: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdelem: invalid Rd")
    }
    ret := uint32(0x0f000000)
    ret |= Q << 30
    ret |= U << 29
    ret |= size << 22
    ret |= L << 21
    ret |= M << 20
    ret |= Rm << 16
    ret |= opcode << 12
    ret |= H << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdext: Advanced SIMD extract
func asimdext(Q, op2, Rm, imm4, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdext: invalid Q")
    }
    if op2 &^ 0b11 != 0 {
        panic("asimdext: invalid op2")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asimdext: invalid Rm")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("asimdext: invalid imm4")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdext: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdext: invalid Rd")
    }
    ret := uint32(0x2e000000)
    ret |= Q << 30
    ret |= op2 << 22
    ret |= Rm << 16
    ret |= imm4 << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdimm: Advanced SIMD modified immediate
func asimdimm(Q, op, a, b, c, cmode, o2, d, e, f, g, h, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdimm: invalid Q")
    }
    if op &^ 0b1 != 0 {
        panic("asimdimm: invalid op")
    }
    if a &^ 0b1 != 0 {
        panic("asimdimm: invalid a")
    }
    if b &^ 0b1 != 0 {
        panic("asimdimm: invalid b")
    }
    if c &^ 0b1 != 0 {
        panic("asimdimm: invalid c")
    }
    if cmode &^ 0b1111 != 0 {
        panic("asimdimm: invalid cmode")
    }
    if o2 &^ 0b1 != 0 {
        panic("asimdimm: invalid o2")
    }
    if d &^ 0b1 != 0 {
        panic("asimdimm: invalid d")
    }
    if e &^ 0b1 != 0 {
        panic("asimdimm: invalid e")
    }
    if f &^ 0b1 != 0 {
        panic("asimdimm: invalid f")
    }
    if g &^ 0b1 != 0 {
        panic("asimdimm: invalid g")
    }
    if h &^ 0b1 != 0 {
        panic("asimdimm: invalid h")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdimm: invalid Rd")
    }
    ret := uint32(0x0f000400)
    ret |= Q << 30
    ret |= op << 29
    ret |= a << 18
    ret |= b << 17
    ret |= c << 16
    ret |= cmode << 12
    ret |= o2 << 11
    ret |= d << 9
    ret |= e << 8
    ret |= f << 7
    ret |= g << 6
    ret |= h << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdins: Advanced SIMD copy
func asimdins(Q, op, imm5, imm4, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdins: invalid Q")
    }
    if op &^ 0b1 != 0 {
        panic("asimdins: invalid op")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("asimdins: invalid imm5")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("asimdins: invalid imm4")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdins: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdins: invalid Rd")
    }
    ret := uint32(0x0e000400)
    ret |= Q << 30
    ret |= op << 29
    ret |= imm5 << 16
    ret |= imm4 << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdmisc: Advanced SIMD two-register miscellaneous
func asimdmisc(Q, U, size, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdmisc: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimdmisc: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asimdmisc: invalid size")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asimdmisc: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdmisc: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdmisc: invalid Rd")
    }
    ret := uint32(0x0e200800)
    ret |= Q << 30
    ret |= U << 29
    ret |= size << 22
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdmiscfp16: Advanced SIMD two-register miscellaneous (FP16)
func asimdmiscfp16(Q, U, a, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdmiscfp16: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimdmiscfp16: invalid U")
    }
    if a &^ 0b1 != 0 {
        panic("asimdmiscfp16: invalid a")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asimdmiscfp16: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdmiscfp16: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdmiscfp16: invalid Rd")
    }
    ret := uint32(0x0e780800)
    ret |= Q << 30
    ret |= U << 29
    ret |= a << 23
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdperm: Advanced SIMD permute
func asimdperm(Q, size, Rm, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdperm: invalid Q")
    }
    if size &^ 0b11 != 0 {
        panic("asimdperm: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asimdperm: invalid Rm")
    }
    if opcode &^ 0b111 != 0 {
        panic("asimdperm: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdperm: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdperm: invalid Rd")
    }
    ret := uint32(0x0e000800)
    ret |= Q << 30
    ret |= size << 22
    ret |= Rm << 16
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdsame: Advanced SIMD three same
func asimdsame(Q, U, size, Rm, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdsame: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimdsame: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asimdsame: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asimdsame: invalid Rm")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asimdsame: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdsame: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdsame: invalid Rd")
    }
    ret := uint32(0x0e200400)
    ret |= Q << 30
    ret |= U << 29
    ret |= size << 22
    ret |= Rm << 16
    ret |= opcode << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdsame2: Advanced SIMD three-register extension
func asimdsame2(Q, U, size, Rm, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdsame2: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimdsame2: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asimdsame2: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asimdsame2: invalid Rm")
    }
    if opcode &^ 0b1111 != 0 {
        panic("asimdsame2: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdsame2: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdsame2: invalid Rd")
    }
    ret := uint32(0x0e008400)
    ret |= Q << 30
    ret |= U << 29
    ret |= size << 22
    ret |= Rm << 16
    ret |= opcode << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdsamefp16: Advanced SIMD three same (FP16)
func asimdsamefp16(Q, U, a, Rm, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdsamefp16: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimdsamefp16: invalid U")
    }
    if a &^ 0b1 != 0 {
        panic("asimdsamefp16: invalid a")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asimdsamefp16: invalid Rm")
    }
    if opcode &^ 0b111 != 0 {
        panic("asimdsamefp16: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdsamefp16: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdsamefp16: invalid Rd")
    }
    ret := uint32(0x0e400400)
    ret |= Q << 30
    ret |= U << 29
    ret |= a << 23
    ret |= Rm << 16
    ret |= opcode << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdshf: Advanced SIMD shift by immediate
func asimdshf(Q, U, immh, immb, opcode, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdshf: invalid Q")
    }
    if U &^ 0b1 != 0 {
        panic("asimdshf: invalid U")
    }
    if immh &^ 0b1111 != 0 {
        panic("asimdshf: invalid immh")
    }
    if immb &^ 0b111 != 0 {
        panic("asimdshf: invalid immb")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asimdshf: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdshf: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdshf: invalid Rd")
    }
    ret := uint32(0x0f000400)
    ret |= Q << 30
    ret |= U << 29
    ret |= immh << 19
    ret |= immb << 16
    ret |= opcode << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asimdtbl: Advanced SIMD table lookup
func asimdtbl(Q, op2, Rm, len, op, Rn, Rd uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asimdtbl: invalid Q")
    }
    if op2 &^ 0b11 != 0 {
        panic("asimdtbl: invalid op2")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asimdtbl: invalid Rm")
    }
    if len &^ 0b11 != 0 {
        panic("asimdtbl: invalid len")
    }
    if op &^ 0b1 != 0 {
        panic("asimdtbl: invalid op")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asimdtbl: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asimdtbl: invalid Rd")
    }
    ret := uint32(0x0e000000)
    ret |= Q << 30
    ret |= op2 << 22
    ret |= Rm << 16
    ret |= len << 13
    ret |= op << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisddiff: Advanced SIMD scalar three different
func asisddiff(U, size, Rm, opcode, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisddiff: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asisddiff: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asisddiff: invalid Rm")
    }
    if opcode &^ 0b1111 != 0 {
        panic("asisddiff: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisddiff: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisddiff: invalid Rd")
    }
    ret := uint32(0x5e200000)
    ret |= U << 29
    ret |= size << 22
    ret |= Rm << 16
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdelem: Advanced SIMD scalar x indexed element
func asisdelem(U, size, L, M, Rm, opcode, H, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisdelem: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asisdelem: invalid size")
    }
    if L &^ 0b1 != 0 {
        panic("asisdelem: invalid L")
    }
    if M &^ 0b1 != 0 {
        panic("asisdelem: invalid M")
    }
    if Rm &^ 0b1111 != 0 {
        panic("asisdelem: invalid Rm")
    }
    if opcode &^ 0b1111 != 0 {
        panic("asisdelem: invalid opcode")
    }
    if H &^ 0b1 != 0 {
        panic("asisdelem: invalid H")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdelem: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdelem: invalid Rd")
    }
    ret := uint32(0x5f000000)
    ret |= U << 29
    ret |= size << 22
    ret |= L << 21
    ret |= M << 20
    ret |= Rm << 16
    ret |= opcode << 12
    ret |= H << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdlse: Advanced SIMD load/store multiple structures
func asisdlse(Q, L, opcode, size, Rn, Rt uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asisdlse: invalid Q")
    }
    if L &^ 0b1 != 0 {
        panic("asisdlse: invalid L")
    }
    if opcode &^ 0b1111 != 0 {
        panic("asisdlse: invalid opcode")
    }
    if size &^ 0b11 != 0 {
        panic("asisdlse: invalid size")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdlse: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("asisdlse: invalid Rt")
    }
    ret := uint32(0x0c000000)
    ret |= Q << 30
    ret |= L << 22
    ret |= opcode << 12
    ret |= size << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// asisdlsep: Advanced SIMD load/store multiple structures (post-indexed)
func asisdlsep(Q, L, Rm, opcode, size, Rn, Rt uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asisdlsep: invalid Q")
    }
    if L &^ 0b1 != 0 {
        panic("asisdlsep: invalid L")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asisdlsep: invalid Rm")
    }
    if opcode &^ 0b1111 != 0 {
        panic("asisdlsep: invalid opcode")
    }
    if size &^ 0b11 != 0 {
        panic("asisdlsep: invalid size")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdlsep: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("asisdlsep: invalid Rt")
    }
    ret := uint32(0x0c800000)
    ret |= Q << 30
    ret |= L << 22
    ret |= Rm << 16
    ret |= opcode << 12
    ret |= size << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// asisdlso: Advanced SIMD load/store single structure
func asisdlso(Q, L, R, opcode, S, size, Rn, Rt uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asisdlso: invalid Q")
    }
    if L &^ 0b1 != 0 {
        panic("asisdlso: invalid L")
    }
    if R &^ 0b1 != 0 {
        panic("asisdlso: invalid R")
    }
    if opcode &^ 0b111 != 0 {
        panic("asisdlso: invalid opcode")
    }
    if S &^ 0b1 != 0 {
        panic("asisdlso: invalid S")
    }
    if size &^ 0b11 != 0 {
        panic("asisdlso: invalid size")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdlso: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("asisdlso: invalid Rt")
    }
    ret := uint32(0x0d000000)
    ret |= Q << 30
    ret |= L << 22
    ret |= R << 21
    ret |= opcode << 13
    ret |= S << 12
    ret |= size << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// asisdlsop: Advanced SIMD load/store single structure (post-indexed)
func asisdlsop(Q, L, R, Rm, opcode, S, size, Rn, Rt uint32) Instruction {
    if Q &^ 0b1 != 0 {
        panic("asisdlsop: invalid Q")
    }
    if L &^ 0b1 != 0 {
        panic("asisdlsop: invalid L")
    }
    if R &^ 0b1 != 0 {
        panic("asisdlsop: invalid R")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asisdlsop: invalid Rm")
    }
    if opcode &^ 0b111 != 0 {
        panic("asisdlsop: invalid opcode")
    }
    if S &^ 0b1 != 0 {
        panic("asisdlsop: invalid S")
    }
    if size &^ 0b11 != 0 {
        panic("asisdlsop: invalid size")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdlsop: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("asisdlsop: invalid Rt")
    }
    ret := uint32(0x0d800000)
    ret |= Q << 30
    ret |= L << 22
    ret |= R << 21
    ret |= Rm << 16
    ret |= opcode << 13
    ret |= S << 12
    ret |= size << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// asisdmisc: Advanced SIMD scalar two-register miscellaneous
func asisdmisc(U, size, opcode, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisdmisc: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asisdmisc: invalid size")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asisdmisc: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdmisc: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdmisc: invalid Rd")
    }
    ret := uint32(0x5e200800)
    ret |= U << 29
    ret |= size << 22
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdmiscfp16: Advanced SIMD scalar two-register miscellaneous FP16
func asisdmiscfp16(U, a, opcode, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisdmiscfp16: invalid U")
    }
    if a &^ 0b1 != 0 {
        panic("asisdmiscfp16: invalid a")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asisdmiscfp16: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdmiscfp16: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdmiscfp16: invalid Rd")
    }
    ret := uint32(0x5e780800)
    ret |= U << 29
    ret |= a << 23
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdone: Advanced SIMD scalar copy
func asisdone(op, imm5, imm4, Rn, Rd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("asisdone: invalid op")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("asisdone: invalid imm5")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("asisdone: invalid imm4")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdone: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdone: invalid Rd")
    }
    ret := uint32(0x5e000400)
    ret |= op << 29
    ret |= imm5 << 16
    ret |= imm4 << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdpair: Advanced SIMD scalar pairwise
func asisdpair(U, size, opcode, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisdpair: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asisdpair: invalid size")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asisdpair: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdpair: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdpair: invalid Rd")
    }
    ret := uint32(0x5e300800)
    ret |= U << 29
    ret |= size << 22
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdsame: Advanced SIMD scalar three same
func asisdsame(U, size, Rm, opcode, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisdsame: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asisdsame: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asisdsame: invalid Rm")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asisdsame: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdsame: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdsame: invalid Rd")
    }
    ret := uint32(0x5e200400)
    ret |= U << 29
    ret |= size << 22
    ret |= Rm << 16
    ret |= opcode << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdsame2: Advanced SIMD scalar three same extra
func asisdsame2(U, size, Rm, opcode, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisdsame2: invalid U")
    }
    if size &^ 0b11 != 0 {
        panic("asisdsame2: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asisdsame2: invalid Rm")
    }
    if opcode &^ 0b1111 != 0 {
        panic("asisdsame2: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdsame2: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdsame2: invalid Rd")
    }
    ret := uint32(0x5e008400)
    ret |= U << 29
    ret |= size << 22
    ret |= Rm << 16
    ret |= opcode << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdsamefp16: Advanced SIMD scalar three same FP16
func asisdsamefp16(U, a, Rm, opcode, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisdsamefp16: invalid U")
    }
    if a &^ 0b1 != 0 {
        panic("asisdsamefp16: invalid a")
    }
    if Rm &^ 0b11111 != 0 {
        panic("asisdsamefp16: invalid Rm")
    }
    if opcode &^ 0b111 != 0 {
        panic("asisdsamefp16: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdsamefp16: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdsamefp16: invalid Rd")
    }
    ret := uint32(0x5e400400)
    ret |= U << 29
    ret |= a << 23
    ret |= Rm << 16
    ret |= opcode << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// asisdshf: Advanced SIMD scalar shift by immediate
func asisdshf(U, immh, immb, opcode, Rn, Rd uint32) Instruction {
    if U &^ 0b1 != 0 {
        panic("asisdshf: invalid U")
    }
    if immh &^ 0b1111 != 0 {
        panic("asisdshf: invalid immh")
    }
    if immb &^ 0b111 != 0 {
        panic("asisdshf: invalid immb")
    }
    if opcode &^ 0b11111 != 0 {
        panic("asisdshf: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("asisdshf: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("asisdshf: invalid Rd")
    }
    ret := uint32(0x5f000400)
    ret |= U << 29
    ret |= immh << 19
    ret |= immb << 16
    ret |= opcode << 11
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// barriers: Barriers
func barriers(CRm, op2, Rt uint32) Instruction {
    if CRm &^ 0b1111 != 0 {
        panic("barriers: invalid CRm")
    }
    if op2 &^ 0b111 != 0 {
        panic("barriers: invalid op2")
    }
    if Rt &^ 0b11111 != 0 {
        panic("barriers: invalid Rt")
    }
    ret := uint32(0xd5033000)
    ret |= CRm << 8
    ret |= op2 << 5
    ret |= Rt
    return Instruction(ret);
}

// bitfield: Bitfield
func bitfield(sf, opc, N, immr, imms, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("bitfield: invalid sf")
    }
    if opc &^ 0b11 != 0 {
        panic("bitfield: invalid opc")
    }
    if N &^ 0b1 != 0 {
        panic("bitfield: invalid N")
    }
    if immr &^ 0b111111 != 0 {
        panic("bitfield: invalid immr")
    }
    if imms &^ 0b111111 != 0 {
        panic("bitfield: invalid imms")
    }
    if Rn &^ 0b11111 != 0 {
        panic("bitfield: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("bitfield: invalid Rd")
    }
    ret := uint32(0x13000000)
    ret |= sf << 31
    ret |= opc << 29
    ret |= N << 22
    ret |= immr << 16
    ret |= imms << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// branch_imm: Unconditional branch (immediate)
func branch_imm(op, imm26 uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("branch_imm: invalid op")
    }
    if imm26 &^ 0b11111111111111111111111111 != 0 {
        panic("branch_imm: invalid imm26")
    }
    ret := uint32(0x14000000)
    ret |= op << 31
    ret |= imm26
    return Instruction(ret);
}

// branch_reg: Unconditional branch (register)
func branch_reg(opc, op2, op3, Rn, op4 uint32) Instruction {
    if opc &^ 0b1111 != 0 {
        panic("branch_reg: invalid opc")
    }
    if op2 &^ 0b11111 != 0 {
        panic("branch_reg: invalid op2")
    }
    if op3 &^ 0b111111 != 0 {
        panic("branch_reg: invalid op3")
    }
    if Rn &^ 0b11111 != 0 {
        panic("branch_reg: invalid Rn")
    }
    if op4 &^ 0b11111 != 0 {
        panic("branch_reg: invalid op4")
    }
    ret := uint32(0xd6000000)
    ret |= opc << 21
    ret |= op2 << 16
    ret |= op3 << 10
    ret |= Rn << 5
    ret |= op4
    return Instruction(ret);
}

// compbranch: Compare and branch (immediate)
func compbranch(sf, op, imm19, Rt uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("compbranch: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("compbranch: invalid op")
    }
    if imm19 &^ 0b1111111111111111111 != 0 {
        panic("compbranch: invalid imm19")
    }
    if Rt &^ 0b11111 != 0 {
        panic("compbranch: invalid Rt")
    }
    ret := uint32(0x34000000)
    ret |= sf << 31
    ret |= op << 24
    ret |= imm19 << 5
    ret |= Rt
    return Instruction(ret);
}

// condbranch: Conditional branch (immediate)
func condbranch(o1, imm19, o0, cond uint32) Instruction {
    if o1 &^ 0b1 != 0 {
        panic("condbranch: invalid o1")
    }
    if imm19 &^ 0b1111111111111111111 != 0 {
        panic("condbranch: invalid imm19")
    }
    if o0 &^ 0b1 != 0 {
        panic("condbranch: invalid o0")
    }
    if cond &^ 0b1111 != 0 {
        panic("condbranch: invalid cond")
    }
    ret := uint32(0x54000000)
    ret |= o1 << 24
    ret |= imm19 << 5
    ret |= o0 << 4
    ret |= cond
    return Instruction(ret);
}

// condcmp_imm: Conditional compare (immediate)
func condcmp_imm(sf, op, S, imm5, cond, o2, Rn, o3, nzcv uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("condcmp_imm: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("condcmp_imm: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("condcmp_imm: invalid S")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("condcmp_imm: invalid imm5")
    }
    if cond &^ 0b1111 != 0 {
        panic("condcmp_imm: invalid cond")
    }
    if o2 &^ 0b1 != 0 {
        panic("condcmp_imm: invalid o2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("condcmp_imm: invalid Rn")
    }
    if o3 &^ 0b1 != 0 {
        panic("condcmp_imm: invalid o3")
    }
    if nzcv &^ 0b1111 != 0 {
        panic("condcmp_imm: invalid nzcv")
    }
    ret := uint32(0x1a400800)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= imm5 << 16
    ret |= cond << 12
    ret |= o2 << 10
    ret |= Rn << 5
    ret |= o3 << 4
    ret |= nzcv
    return Instruction(ret);
}

// condcmp_reg: Conditional compare (register)
func condcmp_reg(sf, op, S, Rm, cond, o2, Rn, o3, nzcv uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("condcmp_reg: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("condcmp_reg: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("condcmp_reg: invalid S")
    }
    if Rm &^ 0b11111 != 0 {
        panic("condcmp_reg: invalid Rm")
    }
    if cond &^ 0b1111 != 0 {
        panic("condcmp_reg: invalid cond")
    }
    if o2 &^ 0b1 != 0 {
        panic("condcmp_reg: invalid o2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("condcmp_reg: invalid Rn")
    }
    if o3 &^ 0b1 != 0 {
        panic("condcmp_reg: invalid o3")
    }
    if nzcv &^ 0b1111 != 0 {
        panic("condcmp_reg: invalid nzcv")
    }
    ret := uint32(0x1a400000)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= Rm << 16
    ret |= cond << 12
    ret |= o2 << 10
    ret |= Rn << 5
    ret |= o3 << 4
    ret |= nzcv
    return Instruction(ret);
}

// condsel: Conditional select
func condsel(sf, op, S, Rm, cond, op2, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("condsel: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("condsel: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("condsel: invalid S")
    }
    if Rm &^ 0b11111 != 0 {
        panic("condsel: invalid Rm")
    }
    if cond &^ 0b1111 != 0 {
        panic("condsel: invalid cond")
    }
    if op2 &^ 0b11 != 0 {
        panic("condsel: invalid op2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("condsel: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("condsel: invalid Rd")
    }
    ret := uint32(0x1a800000)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= Rm << 16
    ret |= cond << 12
    ret |= op2 << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// crypto3_imm2: Cryptographic three-register, imm2
func crypto3_imm2(Rm, imm2, opcode, Rn, Rd uint32) Instruction {
    if Rm &^ 0b11111 != 0 {
        panic("crypto3_imm2: invalid Rm")
    }
    if imm2 &^ 0b11 != 0 {
        panic("crypto3_imm2: invalid imm2")
    }
    if opcode &^ 0b11 != 0 {
        panic("crypto3_imm2: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("crypto3_imm2: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("crypto3_imm2: invalid Rd")
    }
    ret := uint32(0xce408000)
    ret |= Rm << 16
    ret |= imm2 << 12
    ret |= opcode << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// crypto3_imm6: Cryptographic three-register, imm6
func crypto3_imm6(Rm, imm6, Rn, Rd uint32) Instruction {
    if Rm &^ 0b11111 != 0 {
        panic("crypto3_imm6: invalid Rm")
    }
    if imm6 &^ 0b111111 != 0 {
        panic("crypto3_imm6: invalid imm6")
    }
    if Rn &^ 0b11111 != 0 {
        panic("crypto3_imm6: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("crypto3_imm6: invalid Rd")
    }
    ret := uint32(0xce800000)
    ret |= Rm << 16
    ret |= imm6 << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// crypto4: Cryptographic four-register
func crypto4(Op0, Rm, Ra, Rn, Rd uint32) Instruction {
    if Op0 &^ 0b11 != 0 {
        panic("crypto4: invalid Op0")
    }
    if Rm &^ 0b11111 != 0 {
        panic("crypto4: invalid Rm")
    }
    if Ra &^ 0b11111 != 0 {
        panic("crypto4: invalid Ra")
    }
    if Rn &^ 0b11111 != 0 {
        panic("crypto4: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("crypto4: invalid Rd")
    }
    ret := uint32(0xce000000)
    ret |= Op0 << 21
    ret |= Rm << 16
    ret |= Ra << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// cryptoaes: Cryptographic AES
func cryptoaes(size, opcode, Rn, Rd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("cryptoaes: invalid size")
    }
    if opcode &^ 0b11111 != 0 {
        panic("cryptoaes: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("cryptoaes: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("cryptoaes: invalid Rd")
    }
    ret := uint32(0x4e280800)
    ret |= size << 22
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// cryptosha2: Cryptographic two-register SHA
func cryptosha2(size, opcode, Rn, Rd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("cryptosha2: invalid size")
    }
    if opcode &^ 0b11111 != 0 {
        panic("cryptosha2: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("cryptosha2: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("cryptosha2: invalid Rd")
    }
    ret := uint32(0x5e280800)
    ret |= size << 22
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// cryptosha3: Cryptographic three-register SHA
func cryptosha3(size, Rm, opcode, Rn, Rd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("cryptosha3: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("cryptosha3: invalid Rm")
    }
    if opcode &^ 0b111 != 0 {
        panic("cryptosha3: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("cryptosha3: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("cryptosha3: invalid Rd")
    }
    ret := uint32(0x5e000000)
    ret |= size << 22
    ret |= Rm << 16
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// cryptosha512_2: Cryptographic two-register SHA 512
func cryptosha512_2(opcode, Rn, Rd uint32) Instruction {
    if opcode &^ 0b11 != 0 {
        panic("cryptosha512_2: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("cryptosha512_2: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("cryptosha512_2: invalid Rd")
    }
    ret := uint32(0xcec08000)
    ret |= opcode << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// cryptosha512_3: Cryptographic three-register SHA 512
func cryptosha512_3(Rm, O, opcode, Rn, Rd uint32) Instruction {
    if Rm &^ 0b11111 != 0 {
        panic("cryptosha512_3: invalid Rm")
    }
    if O &^ 0b1 != 0 {
        panic("cryptosha512_3: invalid O")
    }
    if opcode &^ 0b11 != 0 {
        panic("cryptosha512_3: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("cryptosha512_3: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("cryptosha512_3: invalid Rd")
    }
    ret := uint32(0xce608000)
    ret |= Rm << 16
    ret |= O << 14
    ret |= opcode << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// dp_1src: Data-processing (1 source)
func dp_1src(sf, S, opcode2, opcode, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("dp_1src: invalid sf")
    }
    if S &^ 0b1 != 0 {
        panic("dp_1src: invalid S")
    }
    if opcode2 &^ 0b11111 != 0 {
        panic("dp_1src: invalid opcode2")
    }
    if opcode &^ 0b111111 != 0 {
        panic("dp_1src: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("dp_1src: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("dp_1src: invalid Rd")
    }
    ret := uint32(0x5ac00000)
    ret |= sf << 31
    ret |= S << 29
    ret |= opcode2 << 16
    ret |= opcode << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// dp_2src: Data-processing (2 source)
func dp_2src(sf, S, Rm, opcode, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("dp_2src: invalid sf")
    }
    if S &^ 0b1 != 0 {
        panic("dp_2src: invalid S")
    }
    if Rm &^ 0b11111 != 0 {
        panic("dp_2src: invalid Rm")
    }
    if opcode &^ 0b111111 != 0 {
        panic("dp_2src: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("dp_2src: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("dp_2src: invalid Rd")
    }
    ret := uint32(0x1ac00000)
    ret |= sf << 31
    ret |= S << 29
    ret |= Rm << 16
    ret |= opcode << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// dp_3src: Data-processing (3 source)
func dp_3src(sf, op54, op31, Rm, o0, Ra, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("dp_3src: invalid sf")
    }
    if op54 &^ 0b11 != 0 {
        panic("dp_3src: invalid op54")
    }
    if op31 &^ 0b111 != 0 {
        panic("dp_3src: invalid op31")
    }
    if Rm &^ 0b11111 != 0 {
        panic("dp_3src: invalid Rm")
    }
    if o0 &^ 0b1 != 0 {
        panic("dp_3src: invalid o0")
    }
    if Ra &^ 0b11111 != 0 {
        panic("dp_3src: invalid Ra")
    }
    if Rn &^ 0b11111 != 0 {
        panic("dp_3src: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("dp_3src: invalid Rd")
    }
    ret := uint32(0x1b000000)
    ret |= sf << 31
    ret |= op54 << 29
    ret |= op31 << 21
    ret |= Rm << 16
    ret |= o0 << 15
    ret |= Ra << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// exception: Exception generation
func exception(opc, imm16, op2, LL uint32) Instruction {
    if opc &^ 0b111 != 0 {
        panic("exception: invalid opc")
    }
    if imm16 &^ 0b1111111111111111 != 0 {
        panic("exception: invalid imm16")
    }
    if op2 &^ 0b111 != 0 {
        panic("exception: invalid op2")
    }
    if LL &^ 0b11 != 0 {
        panic("exception: invalid LL")
    }
    ret := uint32(0xd4000000)
    ret |= opc << 21
    ret |= imm16 << 5
    ret |= op2 << 2
    ret |= LL
    return Instruction(ret);
}

// extract: Extract
func extract(sf, op21, N, o0, Rm, imms, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("extract: invalid sf")
    }
    if op21 &^ 0b11 != 0 {
        panic("extract: invalid op21")
    }
    if N &^ 0b1 != 0 {
        panic("extract: invalid N")
    }
    if o0 &^ 0b1 != 0 {
        panic("extract: invalid o0")
    }
    if Rm &^ 0b11111 != 0 {
        panic("extract: invalid Rm")
    }
    if imms &^ 0b111111 != 0 {
        panic("extract: invalid imms")
    }
    if Rn &^ 0b11111 != 0 {
        panic("extract: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("extract: invalid Rd")
    }
    ret := uint32(0x13800000)
    ret |= sf << 31
    ret |= op21 << 29
    ret |= N << 22
    ret |= o0 << 21
    ret |= Rm << 16
    ret |= imms << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// float2fix: Conversion between floating-point and fixed-point
func float2fix(sf, S, ptype, rmode, opcode, scale, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("float2fix: invalid sf")
    }
    if S &^ 0b1 != 0 {
        panic("float2fix: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("float2fix: invalid ptype")
    }
    if rmode &^ 0b11 != 0 {
        panic("float2fix: invalid rmode")
    }
    if opcode &^ 0b111 != 0 {
        panic("float2fix: invalid opcode")
    }
    if scale &^ 0b111111 != 0 {
        panic("float2fix: invalid scale")
    }
    if Rn &^ 0b11111 != 0 {
        panic("float2fix: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("float2fix: invalid Rd")
    }
    ret := uint32(0x1e000000)
    ret |= sf << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= rmode << 19
    ret |= opcode << 16
    ret |= scale << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// float2int: Conversion between floating-point and integer
func float2int(sf, S, ptype, rmode, opcode, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("float2int: invalid sf")
    }
    if S &^ 0b1 != 0 {
        panic("float2int: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("float2int: invalid ptype")
    }
    if rmode &^ 0b11 != 0 {
        panic("float2int: invalid rmode")
    }
    if opcode &^ 0b111 != 0 {
        panic("float2int: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("float2int: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("float2int: invalid Rd")
    }
    ret := uint32(0x1e200000)
    ret |= sf << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= rmode << 19
    ret |= opcode << 16
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// floatccmp: Floating-point conditional compare
func floatccmp(M, S, ptype, Rm, cond, Rn, op, nzcv uint32) Instruction {
    if M &^ 0b1 != 0 {
        panic("floatccmp: invalid M")
    }
    if S &^ 0b1 != 0 {
        panic("floatccmp: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("floatccmp: invalid ptype")
    }
    if Rm &^ 0b11111 != 0 {
        panic("floatccmp: invalid Rm")
    }
    if cond &^ 0b1111 != 0 {
        panic("floatccmp: invalid cond")
    }
    if Rn &^ 0b11111 != 0 {
        panic("floatccmp: invalid Rn")
    }
    if op &^ 0b1 != 0 {
        panic("floatccmp: invalid op")
    }
    if nzcv &^ 0b1111 != 0 {
        panic("floatccmp: invalid nzcv")
    }
    ret := uint32(0x1e200400)
    ret |= M << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= Rm << 16
    ret |= cond << 12
    ret |= Rn << 5
    ret |= op << 4
    ret |= nzcv
    return Instruction(ret);
}

// floatcmp: Floating-point compare
func floatcmp(M, S, ptype, Rm, op, Rn, opcode2 uint32) Instruction {
    if M &^ 0b1 != 0 {
        panic("floatcmp: invalid M")
    }
    if S &^ 0b1 != 0 {
        panic("floatcmp: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("floatcmp: invalid ptype")
    }
    if Rm &^ 0b11111 != 0 {
        panic("floatcmp: invalid Rm")
    }
    if op &^ 0b11 != 0 {
        panic("floatcmp: invalid op")
    }
    if Rn &^ 0b11111 != 0 {
        panic("floatcmp: invalid Rn")
    }
    if opcode2 &^ 0b11111 != 0 {
        panic("floatcmp: invalid opcode2")
    }
    ret := uint32(0x1e202000)
    ret |= M << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= Rm << 16
    ret |= op << 14
    ret |= Rn << 5
    ret |= opcode2
    return Instruction(ret);
}

// floatdp1: Floating-point data-processing (1 source)
func floatdp1(M, S, ptype, opcode, Rn, Rd uint32) Instruction {
    if M &^ 0b1 != 0 {
        panic("floatdp1: invalid M")
    }
    if S &^ 0b1 != 0 {
        panic("floatdp1: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("floatdp1: invalid ptype")
    }
    if opcode &^ 0b111111 != 0 {
        panic("floatdp1: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("floatdp1: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("floatdp1: invalid Rd")
    }
    ret := uint32(0x1e204000)
    ret |= M << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= opcode << 15
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// floatdp2: Floating-point data-processing (2 source)
func floatdp2(M, S, ptype, Rm, opcode, Rn, Rd uint32) Instruction {
    if M &^ 0b1 != 0 {
        panic("floatdp2: invalid M")
    }
    if S &^ 0b1 != 0 {
        panic("floatdp2: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("floatdp2: invalid ptype")
    }
    if Rm &^ 0b11111 != 0 {
        panic("floatdp2: invalid Rm")
    }
    if opcode &^ 0b1111 != 0 {
        panic("floatdp2: invalid opcode")
    }
    if Rn &^ 0b11111 != 0 {
        panic("floatdp2: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("floatdp2: invalid Rd")
    }
    ret := uint32(0x1e200800)
    ret |= M << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= Rm << 16
    ret |= opcode << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// floatdp3: Floating-point data-processing (3 source)
func floatdp3(M, S, ptype, o1, Rm, o0, Ra, Rn, Rd uint32) Instruction {
    if M &^ 0b1 != 0 {
        panic("floatdp3: invalid M")
    }
    if S &^ 0b1 != 0 {
        panic("floatdp3: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("floatdp3: invalid ptype")
    }
    if o1 &^ 0b1 != 0 {
        panic("floatdp3: invalid o1")
    }
    if Rm &^ 0b11111 != 0 {
        panic("floatdp3: invalid Rm")
    }
    if o0 &^ 0b1 != 0 {
        panic("floatdp3: invalid o0")
    }
    if Ra &^ 0b11111 != 0 {
        panic("floatdp3: invalid Ra")
    }
    if Rn &^ 0b11111 != 0 {
        panic("floatdp3: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("floatdp3: invalid Rd")
    }
    ret := uint32(0x1f000000)
    ret |= M << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= o1 << 21
    ret |= Rm << 16
    ret |= o0 << 15
    ret |= Ra << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// floatimm: Floating-point immediate
func floatimm(M, S, ptype, imm8, imm5, Rd uint32) Instruction {
    if M &^ 0b1 != 0 {
        panic("floatimm: invalid M")
    }
    if S &^ 0b1 != 0 {
        panic("floatimm: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("floatimm: invalid ptype")
    }
    if imm8 &^ 0b11111111 != 0 {
        panic("floatimm: invalid imm8")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("floatimm: invalid imm5")
    }
    if Rd &^ 0b11111 != 0 {
        panic("floatimm: invalid Rd")
    }
    ret := uint32(0x1e201000)
    ret |= M << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= imm8 << 13
    ret |= imm5 << 5
    ret |= Rd
    return Instruction(ret);
}

// floatsel: Floating-point conditional select
func floatsel(M, S, ptype, Rm, cond, Rn, Rd uint32) Instruction {
    if M &^ 0b1 != 0 {
        panic("floatsel: invalid M")
    }
    if S &^ 0b1 != 0 {
        panic("floatsel: invalid S")
    }
    if ptype &^ 0b11 != 0 {
        panic("floatsel: invalid ptype")
    }
    if Rm &^ 0b11111 != 0 {
        panic("floatsel: invalid Rm")
    }
    if cond &^ 0b1111 != 0 {
        panic("floatsel: invalid cond")
    }
    if Rn &^ 0b11111 != 0 {
        panic("floatsel: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("floatsel: invalid Rd")
    }
    ret := uint32(0x1e200c00)
    ret |= M << 31
    ret |= S << 29
    ret |= ptype << 22
    ret |= Rm << 16
    ret |= cond << 12
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// hints: Hints
func hints(CRm, op2 uint32) Instruction {
    if CRm &^ 0b1111 != 0 {
        panic("hints: invalid CRm")
    }
    if op2 &^ 0b111 != 0 {
        panic("hints: invalid op2")
    }
    ret := uint32(0xd503201f)
    ret |= CRm << 8
    ret |= op2 << 5
    return Instruction(ret);
}

// ldapstl_unscaled: LDAPR/STLR (unscaled immediate)
func ldapstl_unscaled(size, opc, imm9, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldapstl_unscaled: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("ldapstl_unscaled: invalid opc")
    }
    if imm9 &^ 0b111111111 != 0 {
        panic("ldapstl_unscaled: invalid imm9")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldapstl_unscaled: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldapstl_unscaled: invalid Rt")
    }
    ret := uint32(0x19000000)
    ret |= size << 30
    ret |= opc << 22
    ret |= imm9 << 12
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldst_immpost: Load/store register (immediate post-indexed)
func ldst_immpost(size, V, opc, imm9, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldst_immpost: invalid size")
    }
    if V &^ 0b1 != 0 {
        panic("ldst_immpost: invalid V")
    }
    if opc &^ 0b11 != 0 {
        panic("ldst_immpost: invalid opc")
    }
    if imm9 &^ 0b111111111 != 0 {
        panic("ldst_immpost: invalid imm9")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldst_immpost: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldst_immpost: invalid Rt")
    }
    ret := uint32(0x38000400)
    ret |= size << 30
    ret |= V << 26
    ret |= opc << 22
    ret |= imm9 << 12
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldst_immpre: Load/store register (immediate pre-indexed)
func ldst_immpre(size, V, opc, imm9, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldst_immpre: invalid size")
    }
    if V &^ 0b1 != 0 {
        panic("ldst_immpre: invalid V")
    }
    if opc &^ 0b11 != 0 {
        panic("ldst_immpre: invalid opc")
    }
    if imm9 &^ 0b111111111 != 0 {
        panic("ldst_immpre: invalid imm9")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldst_immpre: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldst_immpre: invalid Rt")
    }
    ret := uint32(0x38000c00)
    ret |= size << 30
    ret |= V << 26
    ret |= opc << 22
    ret |= imm9 << 12
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldst_pac: Load/store register (pac)
func ldst_pac(size, V, M, S, imm9, W, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldst_pac: invalid size")
    }
    if V &^ 0b1 != 0 {
        panic("ldst_pac: invalid V")
    }
    if M &^ 0b1 != 0 {
        panic("ldst_pac: invalid M")
    }
    if S &^ 0b1 != 0 {
        panic("ldst_pac: invalid S")
    }
    if imm9 &^ 0b111111111 != 0 {
        panic("ldst_pac: invalid imm9")
    }
    if W &^ 0b1 != 0 {
        panic("ldst_pac: invalid W")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldst_pac: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldst_pac: invalid Rt")
    }
    ret := uint32(0x38200400)
    ret |= size << 30
    ret |= V << 26
    ret |= M << 23
    ret |= S << 22
    ret |= imm9 << 12
    ret |= W << 11
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldst_pos: Load/store register (unsigned immediate)
func ldst_pos(size, V, opc, imm12, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldst_pos: invalid size")
    }
    if V &^ 0b1 != 0 {
        panic("ldst_pos: invalid V")
    }
    if opc &^ 0b11 != 0 {
        panic("ldst_pos: invalid opc")
    }
    if imm12 &^ 0b111111111111 != 0 {
        panic("ldst_pos: invalid imm12")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldst_pos: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldst_pos: invalid Rt")
    }
    ret := uint32(0x39000000)
    ret |= size << 30
    ret |= V << 26
    ret |= opc << 22
    ret |= imm12 << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldst_regoff: Load/store register (register offset)
func ldst_regoff(size, V, opc, Rm, option, S, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldst_regoff: invalid size")
    }
    if V &^ 0b1 != 0 {
        panic("ldst_regoff: invalid V")
    }
    if opc &^ 0b11 != 0 {
        panic("ldst_regoff: invalid opc")
    }
    if Rm &^ 0b11111 != 0 {
        panic("ldst_regoff: invalid Rm")
    }
    if option &^ 0b111 != 0 {
        panic("ldst_regoff: invalid option")
    }
    if S &^ 0b1 != 0 {
        panic("ldst_regoff: invalid S")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldst_regoff: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldst_regoff: invalid Rt")
    }
    ret := uint32(0x38200800)
    ret |= size << 30
    ret |= V << 26
    ret |= opc << 22
    ret |= Rm << 16
    ret |= option << 13
    ret |= S << 12
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldst_unpriv: Load/store register (unprivileged)
func ldst_unpriv(size, V, opc, imm9, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldst_unpriv: invalid size")
    }
    if V &^ 0b1 != 0 {
        panic("ldst_unpriv: invalid V")
    }
    if opc &^ 0b11 != 0 {
        panic("ldst_unpriv: invalid opc")
    }
    if imm9 &^ 0b111111111 != 0 {
        panic("ldst_unpriv: invalid imm9")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldst_unpriv: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldst_unpriv: invalid Rt")
    }
    ret := uint32(0x38000800)
    ret |= size << 30
    ret |= V << 26
    ret |= opc << 22
    ret |= imm9 << 12
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldst_unscaled: Load/store register (unscaled immediate)
func ldst_unscaled(size, V, opc, imm9, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldst_unscaled: invalid size")
    }
    if V &^ 0b1 != 0 {
        panic("ldst_unscaled: invalid V")
    }
    if opc &^ 0b11 != 0 {
        panic("ldst_unscaled: invalid opc")
    }
    if imm9 &^ 0b111111111 != 0 {
        panic("ldst_unscaled: invalid imm9")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldst_unscaled: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldst_unscaled: invalid Rt")
    }
    ret := uint32(0x38000000)
    ret |= size << 30
    ret |= V << 26
    ret |= opc << 22
    ret |= imm9 << 12
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldstexcl: Load/store exclusive
func ldstexcl(size, o2, L, o1, Rs, o0, Rt2, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("ldstexcl: invalid size")
    }
    if o2 &^ 0b1 != 0 {
        panic("ldstexcl: invalid o2")
    }
    if L &^ 0b1 != 0 {
        panic("ldstexcl: invalid L")
    }
    if o1 &^ 0b1 != 0 {
        panic("ldstexcl: invalid o1")
    }
    if Rs &^ 0b11111 != 0 {
        panic("ldstexcl: invalid Rs")
    }
    if o0 &^ 0b1 != 0 {
        panic("ldstexcl: invalid o0")
    }
    if Rt2 &^ 0b11111 != 0 {
        panic("ldstexcl: invalid Rt2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldstexcl: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldstexcl: invalid Rt")
    }
    ret := uint32(0x08000000)
    ret |= size << 30
    ret |= o2 << 23
    ret |= L << 22
    ret |= o1 << 21
    ret |= Rs << 16
    ret |= o0 << 15
    ret |= Rt2 << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldstnapair_offs: Load/store no-allocate pair (offset)
func ldstnapair_offs(opc, V, L, imm7, Rt2, Rn, Rt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("ldstnapair_offs: invalid opc")
    }
    if V &^ 0b1 != 0 {
        panic("ldstnapair_offs: invalid V")
    }
    if L &^ 0b1 != 0 {
        panic("ldstnapair_offs: invalid L")
    }
    if imm7 &^ 0b1111111 != 0 {
        panic("ldstnapair_offs: invalid imm7")
    }
    if Rt2 &^ 0b11111 != 0 {
        panic("ldstnapair_offs: invalid Rt2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldstnapair_offs: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldstnapair_offs: invalid Rt")
    }
    ret := uint32(0x28000000)
    ret |= opc << 30
    ret |= V << 26
    ret |= L << 22
    ret |= imm7 << 15
    ret |= Rt2 << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldstpair_off: Load/store register pair (offset)
func ldstpair_off(opc, V, L, imm7, Rt2, Rn, Rt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("ldstpair_off: invalid opc")
    }
    if V &^ 0b1 != 0 {
        panic("ldstpair_off: invalid V")
    }
    if L &^ 0b1 != 0 {
        panic("ldstpair_off: invalid L")
    }
    if imm7 &^ 0b1111111 != 0 {
        panic("ldstpair_off: invalid imm7")
    }
    if Rt2 &^ 0b11111 != 0 {
        panic("ldstpair_off: invalid Rt2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldstpair_off: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldstpair_off: invalid Rt")
    }
    ret := uint32(0x29000000)
    ret |= opc << 30
    ret |= V << 26
    ret |= L << 22
    ret |= imm7 << 15
    ret |= Rt2 << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldstpair_post: Load/store register pair (post-indexed)
func ldstpair_post(opc, V, L, imm7, Rt2, Rn, Rt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("ldstpair_post: invalid opc")
    }
    if V &^ 0b1 != 0 {
        panic("ldstpair_post: invalid V")
    }
    if L &^ 0b1 != 0 {
        panic("ldstpair_post: invalid L")
    }
    if imm7 &^ 0b1111111 != 0 {
        panic("ldstpair_post: invalid imm7")
    }
    if Rt2 &^ 0b11111 != 0 {
        panic("ldstpair_post: invalid Rt2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldstpair_post: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldstpair_post: invalid Rt")
    }
    ret := uint32(0x28800000)
    ret |= opc << 30
    ret |= V << 26
    ret |= L << 22
    ret |= imm7 << 15
    ret |= Rt2 << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldstpair_pre: Load/store register pair (pre-indexed)
func ldstpair_pre(opc, V, L, imm7, Rt2, Rn, Rt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("ldstpair_pre: invalid opc")
    }
    if V &^ 0b1 != 0 {
        panic("ldstpair_pre: invalid V")
    }
    if L &^ 0b1 != 0 {
        panic("ldstpair_pre: invalid L")
    }
    if imm7 &^ 0b1111111 != 0 {
        panic("ldstpair_pre: invalid imm7")
    }
    if Rt2 &^ 0b11111 != 0 {
        panic("ldstpair_pre: invalid Rt2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldstpair_pre: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldstpair_pre: invalid Rt")
    }
    ret := uint32(0x29800000)
    ret |= opc << 30
    ret |= V << 26
    ret |= L << 22
    ret |= imm7 << 15
    ret |= Rt2 << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// ldsttags: Load/store memory tags
func ldsttags(opc, imm9, op2, Rn, Rt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("ldsttags: invalid opc")
    }
    if imm9 &^ 0b111111111 != 0 {
        panic("ldsttags: invalid imm9")
    }
    if op2 &^ 0b11 != 0 {
        panic("ldsttags: invalid op2")
    }
    if Rn &^ 0b11111 != 0 {
        panic("ldsttags: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("ldsttags: invalid Rt")
    }
    ret := uint32(0xd9200000)
    ret |= opc << 22
    ret |= imm9 << 12
    ret |= op2 << 10
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// loadlit: Load register (literal)
func loadlit(opc, V, imm19, Rt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("loadlit: invalid opc")
    }
    if V &^ 0b1 != 0 {
        panic("loadlit: invalid V")
    }
    if imm19 &^ 0b1111111111111111111 != 0 {
        panic("loadlit: invalid imm19")
    }
    if Rt &^ 0b11111 != 0 {
        panic("loadlit: invalid Rt")
    }
    ret := uint32(0x18000000)
    ret |= opc << 30
    ret |= V << 26
    ret |= imm19 << 5
    ret |= Rt
    return Instruction(ret);
}

// log_imm: Logical (immediate)
func log_imm(sf, opc, N, immr, imms, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("log_imm: invalid sf")
    }
    if opc &^ 0b11 != 0 {
        panic("log_imm: invalid opc")
    }
    if N &^ 0b1 != 0 {
        panic("log_imm: invalid N")
    }
    if immr &^ 0b111111 != 0 {
        panic("log_imm: invalid immr")
    }
    if imms &^ 0b111111 != 0 {
        panic("log_imm: invalid imms")
    }
    if Rn &^ 0b11111 != 0 {
        panic("log_imm: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("log_imm: invalid Rd")
    }
    ret := uint32(0x12000000)
    ret |= sf << 31
    ret |= opc << 29
    ret |= N << 22
    ret |= immr << 16
    ret |= imms << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// log_shift: Logical (shifted register)
func log_shift(sf, opc, shift, N, Rm, imm6, Rn, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("log_shift: invalid sf")
    }
    if opc &^ 0b11 != 0 {
        panic("log_shift: invalid opc")
    }
    if shift &^ 0b11 != 0 {
        panic("log_shift: invalid shift")
    }
    if N &^ 0b1 != 0 {
        panic("log_shift: invalid N")
    }
    if Rm &^ 0b11111 != 0 {
        panic("log_shift: invalid Rm")
    }
    if imm6 &^ 0b111111 != 0 {
        panic("log_shift: invalid imm6")
    }
    if Rn &^ 0b11111 != 0 {
        panic("log_shift: invalid Rn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("log_shift: invalid Rd")
    }
    ret := uint32(0x0a000000)
    ret |= sf << 31
    ret |= opc << 29
    ret |= shift << 22
    ret |= N << 21
    ret |= Rm << 16
    ret |= imm6 << 10
    ret |= Rn << 5
    ret |= Rd
    return Instruction(ret);
}

// memop: Atomic memory operations
func memop(size, V, A, R, Rs, o3, opc, Rn, Rt uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("memop: invalid size")
    }
    if V &^ 0b1 != 0 {
        panic("memop: invalid V")
    }
    if A &^ 0b1 != 0 {
        panic("memop: invalid A")
    }
    if R &^ 0b1 != 0 {
        panic("memop: invalid R")
    }
    if Rs &^ 0b11111 != 0 {
        panic("memop: invalid Rs")
    }
    if o3 &^ 0b1 != 0 {
        panic("memop: invalid o3")
    }
    if opc &^ 0b111 != 0 {
        panic("memop: invalid opc")
    }
    if Rn &^ 0b11111 != 0 {
        panic("memop: invalid Rn")
    }
    if Rt &^ 0b11111 != 0 {
        panic("memop: invalid Rt")
    }
    ret := uint32(0x38200000)
    ret |= size << 30
    ret |= V << 26
    ret |= A << 23
    ret |= R << 22
    ret |= Rs << 16
    ret |= o3 << 15
    ret |= opc << 12
    ret |= Rn << 5
    ret |= Rt
    return Instruction(ret);
}

// movewide: Move wide (immediate)
func movewide(sf, opc, hw, imm16, Rd uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("movewide: invalid sf")
    }
    if opc &^ 0b11 != 0 {
        panic("movewide: invalid opc")
    }
    if hw &^ 0b11 != 0 {
        panic("movewide: invalid hw")
    }
    if imm16 &^ 0b1111111111111111 != 0 {
        panic("movewide: invalid imm16")
    }
    if Rd &^ 0b11111 != 0 {
        panic("movewide: invalid Rd")
    }
    ret := uint32(0x12800000)
    ret |= sf << 31
    ret |= opc << 29
    ret |= hw << 21
    ret |= imm16 << 5
    ret |= Rd
    return Instruction(ret);
}

// pcreladdr: PC-rel. addressing
func pcreladdr(op, immlo, immhi, Rd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("pcreladdr: invalid op")
    }
    if immlo &^ 0b11 != 0 {
        panic("pcreladdr: invalid immlo")
    }
    if immhi &^ 0b1111111111111111111 != 0 {
        panic("pcreladdr: invalid immhi")
    }
    if Rd &^ 0b11111 != 0 {
        panic("pcreladdr: invalid Rd")
    }
    ret := uint32(0x10000000)
    ret |= op << 31
    ret |= immlo << 29
    ret |= immhi << 5
    ret |= Rd
    return Instruction(ret);
}

// perm_undef: Reserved
func perm_undef(imm16 uint32) Instruction {
    if imm16 &^ 0b1111111111111111 != 0 {
        panic("perm_undef: invalid imm16")
    }
    ret := uint32(0x00000000)
    ret |= imm16
    return Instruction(ret);
}

// pstate: PSTATE
func pstate(op1, CRm, op2, Rt uint32) Instruction {
    if op1 &^ 0b111 != 0 {
        panic("pstate: invalid op1")
    }
    if CRm &^ 0b1111 != 0 {
        panic("pstate: invalid CRm")
    }
    if op2 &^ 0b111 != 0 {
        panic("pstate: invalid op2")
    }
    if Rt &^ 0b11111 != 0 {
        panic("pstate: invalid Rt")
    }
    ret := uint32(0xd5004000)
    ret |= op1 << 16
    ret |= CRm << 8
    ret |= op2 << 5
    ret |= Rt
    return Instruction(ret);
}

// rmif: Rotate right into flags
func rmif(sf, op, S, imm6, Rn, o2, mask uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("rmif: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("rmif: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("rmif: invalid S")
    }
    if imm6 &^ 0b111111 != 0 {
        panic("rmif: invalid imm6")
    }
    if Rn &^ 0b11111 != 0 {
        panic("rmif: invalid Rn")
    }
    if o2 &^ 0b1 != 0 {
        panic("rmif: invalid o2")
    }
    if mask &^ 0b1111 != 0 {
        panic("rmif: invalid mask")
    }
    ret := uint32(0x1a000400)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= imm6 << 15
    ret |= Rn << 5
    ret |= o2 << 4
    ret |= mask
    return Instruction(ret);
}

// setf: Evaluate into flags
func setf(sf, op, S, opcode2, sz, Rn, o3, mask uint32) Instruction {
    if sf &^ 0b1 != 0 {
        panic("setf: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("setf: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("setf: invalid S")
    }
    if opcode2 &^ 0b111111 != 0 {
        panic("setf: invalid opcode2")
    }
    if sz &^ 0b1 != 0 {
        panic("setf: invalid sz")
    }
    if Rn &^ 0b11111 != 0 {
        panic("setf: invalid Rn")
    }
    if o3 &^ 0b1 != 0 {
        panic("setf: invalid o3")
    }
    if mask &^ 0b1111 != 0 {
        panic("setf: invalid mask")
    }
    ret := uint32(0x1a000800)
    ret |= sf << 31
    ret |= op << 30
    ret |= S << 29
    ret |= opcode2 << 15
    ret |= sz << 14
    ret |= Rn << 5
    ret |= o3 << 4
    ret |= mask
    return Instruction(ret);
}

// sve_fp_2op_i_p_zds: SVE floating-point arithmetic with immediate (predicated)
func sve_fp_2op_i_p_zds(size, opc, Pg, i1, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_2op_i_p_zds: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_fp_2op_i_p_zds: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_i_p_zds: invalid Pg")
    }
    if i1 &^ 0b1 != 0 {
        panic("sve_fp_2op_i_p_zds: invalid i1")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_fp_2op_i_p_zds: invalid Zdn")
    }
    ret := uint32(0x65188000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= i1 << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_fp_2op_p_pd: SVE floating-point compare with zero
func sve_fp_2op_p_pd(size, eq, lt, Pg, Zn, ne, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_2op_p_pd: invalid size")
    }
    if eq &^ 0b1 != 0 {
        panic("sve_fp_2op_p_pd: invalid eq")
    }
    if lt &^ 0b1 != 0 {
        panic("sve_fp_2op_p_pd: invalid lt")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_p_pd: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_pd: invalid Zn")
    }
    if ne &^ 0b1 != 0 {
        panic("sve_fp_2op_p_pd: invalid ne")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_fp_2op_p_pd: invalid Pd")
    }
    ret := uint32(0x65102000)
    ret |= size << 22
    ret |= eq << 17
    ret |= lt << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= ne << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_fp_2op_p_vd: SVE floating-point serial reduction (predicated)
func sve_fp_2op_p_vd(size, opc, Pg, Zm, Vdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_2op_p_vd: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_fp_2op_p_vd: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_p_vd: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_vd: invalid Zm")
    }
    if Vdn &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_vd: invalid Vdn")
    }
    ret := uint32(0x65182000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Vdn
    return Instruction(ret);
}

// sve_fp_2op_p_zd_a: SVE floating-point round to integral value
func sve_fp_2op_p_zd_a(size, opc, Pg, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_a: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_fp_2op_p_zd_a: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_p_zd_a: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_a: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_a: invalid Zd")
    }
    ret := uint32(0x6500a000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_2op_p_zd_b_0: SVE floating-point convert precision
func sve_fp_2op_p_zd_b_0(opc, opc2, Pg, Zn, Zd uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_b_0: invalid opc")
    }
    if opc2 &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_b_0: invalid opc2")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_p_zd_b_0: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_b_0: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_b_0: invalid Zd")
    }
    ret := uint32(0x6508a000)
    ret |= opc << 22
    ret |= opc2 << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_2op_p_zd_b_1: SVE floating-point unary operations
func sve_fp_2op_p_zd_b_1(size, opc, Pg, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_b_1: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_b_1: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_p_zd_b_1: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_b_1: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_b_1: invalid Zd")
    }
    ret := uint32(0x650ca000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_2op_p_zd_c: SVE integer convert to floating-point
func sve_fp_2op_p_zd_c(opc, opc2, U, Pg, Zn, Zd uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_c: invalid opc")
    }
    if opc2 &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_c: invalid opc2")
    }
    if U &^ 0b1 != 0 {
        panic("sve_fp_2op_p_zd_c: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_p_zd_c: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_c: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_c: invalid Zd")
    }
    ret := uint32(0x6510a000)
    ret |= opc << 22
    ret |= opc2 << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_2op_p_zd_d: SVE floating-point convert to integer
func sve_fp_2op_p_zd_d(opc, opc2, U, Pg, Zn, Zd uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_d: invalid opc")
    }
    if opc2 &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zd_d: invalid opc2")
    }
    if U &^ 0b1 != 0 {
        panic("sve_fp_2op_p_zd_d: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_p_zd_d: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_d: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zd_d: invalid Zd")
    }
    ret := uint32(0x6518a000)
    ret |= opc << 22
    ret |= opc2 << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_2op_p_zds: SVE floating-point arithmetic (predicated)
func sve_fp_2op_p_zds(size, opc, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_2op_p_zds: invalid size")
    }
    if opc &^ 0b1111 != 0 {
        panic("sve_fp_2op_p_zds: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_2op_p_zds: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zds: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_fp_2op_p_zds: invalid Zdn")
    }
    ret := uint32(0x65008000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_fp_2op_u_zd: SVE floating-point reciprocal estimate (unpredicated)
func sve_fp_2op_u_zd(size, opc, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_2op_u_zd: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_fp_2op_u_zd: invalid opc")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_2op_u_zd: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_2op_u_zd: invalid Zd")
    }
    ret := uint32(0x65083000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_3op_p_pd: SVE floating-point compare vectors
func sve_fp_3op_p_pd(size, Zm, op, o2, Pg, Zn, o3, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_3op_p_pd: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_3op_p_pd: invalid Zm")
    }
    if op &^ 0b1 != 0 {
        panic("sve_fp_3op_p_pd: invalid op")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_fp_3op_p_pd: invalid o2")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_3op_p_pd: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_3op_p_pd: invalid Zn")
    }
    if o3 &^ 0b1 != 0 {
        panic("sve_fp_3op_p_pd: invalid o3")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_fp_3op_p_pd: invalid Pd")
    }
    ret := uint32(0x65004000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= op << 15
    ret |= o2 << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= o3 << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_fp_3op_p_zds_a: SVE floating-point multiply-accumulate writing addend
func sve_fp_3op_p_zds_a(size, Zm, opc, Pg, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_3op_p_zds_a: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_3op_p_zds_a: invalid Zm")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_fp_3op_p_zds_a: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_3op_p_zds_a: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_3op_p_zds_a: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_3op_p_zds_a: invalid Zda")
    }
    ret := uint32(0x65200000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= opc << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_3op_p_zds_b: SVE floating-point multiply-accumulate writing multiplicand
func sve_fp_3op_p_zds_b(size, Za, opc, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_3op_p_zds_b: invalid size")
    }
    if Za &^ 0b11111 != 0 {
        panic("sve_fp_3op_p_zds_b: invalid Za")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_fp_3op_p_zds_b: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_3op_p_zds_b: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_3op_p_zds_b: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_fp_3op_p_zds_b: invalid Zdn")
    }
    ret := uint32(0x65208000)
    ret |= size << 22
    ret |= Za << 16
    ret |= opc << 13
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_fp_3op_u_zd: SVE floating-point arithmetic (unpredicated)
func sve_fp_3op_u_zd(size, Zm, opc, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_3op_u_zd: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_3op_u_zd: invalid Zm")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_fp_3op_u_zd: invalid opc")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_3op_u_zd: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_3op_u_zd: invalid Zd")
    }
    ret := uint32(0x65000000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= opc << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_fast_red: SVE floating-point recursive reduction
func sve_fp_fast_red(size, opc, Pg, Zn, Vd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_fast_red: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_fp_fast_red: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_fast_red: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fast_red: invalid Zn")
    }
    if Vd &^ 0b11111 != 0 {
        panic("sve_fp_fast_red: invalid Vd")
    }
    ret := uint32(0x65002000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Vd
    return Instruction(ret);
}

// sve_fp_fcadd: SVE floating-point complex add (predicated)
func sve_fp_fcadd(size, rot, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_fcadd: invalid size")
    }
    if rot &^ 0b1 != 0 {
        panic("sve_fp_fcadd: invalid rot")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_fcadd: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_fcadd: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_fp_fcadd: invalid Zdn")
    }
    ret := uint32(0x64008000)
    ret |= size << 22
    ret |= rot << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_fp_fcmla: SVE floating-point complex multiply-add (predicated)
func sve_fp_fcmla(size, Zm, rot, Pg, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_fcmla: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_fcmla: invalid Zm")
    }
    if rot &^ 0b11 != 0 {
        panic("sve_fp_fcmla: invalid rot")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_fcmla: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fcmla: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_fcmla: invalid Zda")
    }
    ret := uint32(0x64000000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= rot << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_fcmla_by_indexed_elem: SVE floating-point complex multiply-add (indexed)
func sve_fp_fcmla_by_indexed_elem(size, opc, rot, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_fcmla_by_indexed_elem: invalid size")
    }
    if opc &^ 0b11111 != 0 {
        panic("sve_fp_fcmla_by_indexed_elem: invalid opc")
    }
    if rot &^ 0b11 != 0 {
        panic("sve_fp_fcmla_by_indexed_elem: invalid rot")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fcmla_by_indexed_elem: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_fcmla_by_indexed_elem: invalid Zda")
    }
    ret := uint32(0x64201000)
    ret |= size << 22
    ret |= opc << 16
    ret |= rot << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_fcvt2: SVE floating-point convert precision odd elements
func sve_fp_fcvt2(opc, opc2, Pg, Zn, Zd uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_fp_fcvt2: invalid opc")
    }
    if opc2 &^ 0b11 != 0 {
        panic("sve_fp_fcvt2: invalid opc2")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_fp_fcvt2: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fcvt2: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_fcvt2: invalid Zd")
    }
    ret := uint32(0x6408a000)
    ret |= opc << 22
    ret |= opc2 << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_fdot: SVE BFloat16 floating-point dot product
func sve_fp_fdot(op, Zm, Zn, Zda uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_fp_fdot: invalid op")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_fdot: invalid Zm")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fdot: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_fdot: invalid Zda")
    }
    ret := uint32(0x64208000)
    ret |= op << 22
    ret |= Zm << 16
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_fdot_by_indexed_elem: SVE BFloat16 floating-point dot product (indexed)
func sve_fp_fdot_by_indexed_elem(op, i2, Zm, Zn, Zda uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_fp_fdot_by_indexed_elem: invalid op")
    }
    if i2 &^ 0b11 != 0 {
        panic("sve_fp_fdot_by_indexed_elem: invalid i2")
    }
    if Zm &^ 0b111 != 0 {
        panic("sve_fp_fdot_by_indexed_elem: invalid Zm")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fdot_by_indexed_elem: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_fdot_by_indexed_elem: invalid Zda")
    }
    ret := uint32(0x64204000)
    ret |= op << 22
    ret |= i2 << 19
    ret |= Zm << 16
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_fma_by_indexed_elem: SVE floating-point multiply-add (indexed)
func sve_fp_fma_by_indexed_elem(size, opc, op, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_fma_by_indexed_elem: invalid size")
    }
    if opc &^ 0b11111 != 0 {
        panic("sve_fp_fma_by_indexed_elem: invalid opc")
    }
    if op &^ 0b1 != 0 {
        panic("sve_fp_fma_by_indexed_elem: invalid op")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fma_by_indexed_elem: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_fma_by_indexed_elem: invalid Zda")
    }
    ret := uint32(0x64200000)
    ret |= size << 22
    ret |= opc << 16
    ret |= op << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_fma_long: SVE floating-point multiply-add long
func sve_fp_fma_long(o2, Zm, op, T, Zn, Zda uint32) Instruction {
    if o2 &^ 0b1 != 0 {
        panic("sve_fp_fma_long: invalid o2")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_fma_long: invalid Zm")
    }
    if op &^ 0b1 != 0 {
        panic("sve_fp_fma_long: invalid op")
    }
    if T &^ 0b1 != 0 {
        panic("sve_fp_fma_long: invalid T")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fma_long: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_fma_long: invalid Zda")
    }
    ret := uint32(0x64a08000)
    ret |= o2 << 22
    ret |= Zm << 16
    ret |= op << 13
    ret |= T << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_fma_long_by_indexed_elem: SVE floating-point multiply-add long (indexed)
func sve_fp_fma_long_by_indexed_elem(o2, i3h, Zm, op, i3l, T, Zn, Zda uint32) Instruction {
    if o2 &^ 0b1 != 0 {
        panic("sve_fp_fma_long_by_indexed_elem: invalid o2")
    }
    if i3h &^ 0b11 != 0 {
        panic("sve_fp_fma_long_by_indexed_elem: invalid i3h")
    }
    if Zm &^ 0b111 != 0 {
        panic("sve_fp_fma_long_by_indexed_elem: invalid Zm")
    }
    if op &^ 0b1 != 0 {
        panic("sve_fp_fma_long_by_indexed_elem: invalid op")
    }
    if i3l &^ 0b1 != 0 {
        panic("sve_fp_fma_long_by_indexed_elem: invalid i3l")
    }
    if T &^ 0b1 != 0 {
        panic("sve_fp_fma_long_by_indexed_elem: invalid T")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fma_long_by_indexed_elem: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_fma_long_by_indexed_elem: invalid Zda")
    }
    ret := uint32(0x64a04000)
    ret |= o2 << 22
    ret |= i3h << 19
    ret |= Zm << 16
    ret |= op << 13
    ret |= i3l << 11
    ret |= T << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_fmmla: SVE floating point matrix multiply accumulate
func sve_fp_fmmla(opc, Zm, Zn, Zda uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_fp_fmmla: invalid opc")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_fmmla: invalid Zm")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fmmla: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_fp_fmmla: invalid Zda")
    }
    ret := uint32(0x6420e400)
    ret |= opc << 22
    ret |= Zm << 16
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_fp_fmul_by_indexed_elem: SVE floating-point multiply (indexed)
func sve_fp_fmul_by_indexed_elem(size, opc, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_fmul_by_indexed_elem: invalid size")
    }
    if opc &^ 0b11111 != 0 {
        panic("sve_fp_fmul_by_indexed_elem: invalid opc")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_fp_fmul_by_indexed_elem: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_fp_fmul_by_indexed_elem: invalid Zd")
    }
    ret := uint32(0x64202000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_fp_ftmad: SVE floating-point trig multiply-add coefficient
func sve_fp_ftmad(size, imm3, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_fp_ftmad: invalid size")
    }
    if imm3 &^ 0b111 != 0 {
        panic("sve_fp_ftmad: invalid imm3")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_fp_ftmad: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_fp_ftmad: invalid Zdn")
    }
    ret := uint32(0x65108000)
    ret |= size << 22
    ret |= imm3 << 16
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_arith_imm0: SVE integer add/subtract immediate (unpredicated)
func sve_int_arith_imm0(size, opc, sh, imm8, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_arith_imm0: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_arith_imm0: invalid opc")
    }
    if sh &^ 0b1 != 0 {
        panic("sve_int_arith_imm0: invalid sh")
    }
    if imm8 &^ 0b11111111 != 0 {
        panic("sve_int_arith_imm0: invalid imm8")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_arith_imm0: invalid Zdn")
    }
    ret := uint32(0x2520c000)
    ret |= size << 22
    ret |= opc << 16
    ret |= sh << 13
    ret |= imm8 << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_arith_imm1: SVE integer min/max immediate (unpredicated)
func sve_int_arith_imm1(size, opc, o2, imm8, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_arith_imm1: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_arith_imm1: invalid opc")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_int_arith_imm1: invalid o2")
    }
    if imm8 &^ 0b11111111 != 0 {
        panic("sve_int_arith_imm1: invalid imm8")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_arith_imm1: invalid Zdn")
    }
    ret := uint32(0x2528c000)
    ret |= size << 22
    ret |= opc << 16
    ret |= o2 << 13
    ret |= imm8 << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_arith_imm2: SVE integer multiply immediate (unpredicated)
func sve_int_arith_imm2(size, opc, o2, imm8, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_arith_imm2: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_arith_imm2: invalid opc")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_int_arith_imm2: invalid o2")
    }
    if imm8 &^ 0b11111111 != 0 {
        panic("sve_int_arith_imm2: invalid imm8")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_arith_imm2: invalid Zdn")
    }
    ret := uint32(0x2530c000)
    ret |= size << 22
    ret |= opc << 16
    ret |= o2 << 13
    ret |= imm8 << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_arith_vl: SVE stack frame adjustment
func sve_int_arith_vl(op, Rn, imm6, Rd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_arith_vl: invalid op")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_int_arith_vl: invalid Rn")
    }
    if imm6 &^ 0b111111 != 0 {
        panic("sve_int_arith_vl: invalid imm6")
    }
    if Rd &^ 0b11111 != 0 {
        panic("sve_int_arith_vl: invalid Rd")
    }
    ret := uint32(0x04205000)
    ret |= op << 22
    ret |= Rn << 16
    ret |= imm6 << 5
    ret |= Rd
    return Instruction(ret);
}

// sve_int_bin_cons_arit_0: SVE integer add/subtract vectors (unpredicated)
func sve_int_bin_cons_arit_0(size, Zm, opc, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_cons_arit_0: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_arit_0: invalid Zm")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_bin_cons_arit_0: invalid opc")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_arit_0: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_arit_0: invalid Zd")
    }
    ret := uint32(0x04200000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= opc << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_bin_cons_log: SVE bitwise logical operations (unpredicated)
func sve_int_bin_cons_log(opc, Zm, Zn, Zd uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_int_bin_cons_log: invalid opc")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_log: invalid Zm")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_log: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_log: invalid Zd")
    }
    ret := uint32(0x04203000)
    ret |= opc << 22
    ret |= Zm << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_bin_cons_misc_0_a: SVE address generation
func sve_int_bin_cons_misc_0_a(opc, Zm, msz, Zn, Zd uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_int_bin_cons_misc_0_a: invalid opc")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_a: invalid Zm")
    }
    if msz &^ 0b11 != 0 {
        panic("sve_int_bin_cons_misc_0_a: invalid msz")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_a: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_a: invalid Zd")
    }
    ret := uint32(0x0420a000)
    ret |= opc << 22
    ret |= Zm << 16
    ret |= msz << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_bin_cons_misc_0_b: SVE floating-point trig select coefficient
func sve_int_bin_cons_misc_0_b(size, Zm, op, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_cons_misc_0_b: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_b: invalid Zm")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_bin_cons_misc_0_b: invalid op")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_b: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_b: invalid Zd")
    }
    ret := uint32(0x0420b000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= op << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_bin_cons_misc_0_c: SVE floating-point exponential accelerator
func sve_int_bin_cons_misc_0_c(size, opc, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_cons_misc_0_c: invalid size")
    }
    if opc &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_c: invalid opc")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_c: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_c: invalid Zd")
    }
    ret := uint32(0x0420b800)
    ret |= size << 22
    ret |= opc << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_bin_cons_misc_0_d: SVE constructive prefix (unpredicated)
func sve_int_bin_cons_misc_0_d(opc, opc2, Zn, Zd uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_int_bin_cons_misc_0_d: invalid opc")
    }
    if opc2 &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_d: invalid opc2")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_d: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_misc_0_d: invalid Zd")
    }
    ret := uint32(0x0420bc00)
    ret |= opc << 22
    ret |= opc2 << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_bin_cons_shift_a: SVE bitwise shift by wide elements (unpredicated)
func sve_int_bin_cons_shift_a(size, Zm, opc, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_cons_shift_a: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_shift_a: invalid Zm")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_bin_cons_shift_a: invalid opc")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_shift_a: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_shift_a: invalid Zd")
    }
    ret := uint32(0x04208000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= opc << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_bin_cons_shift_b: SVE bitwise shift by immediate (unpredicated)
func sve_int_bin_cons_shift_b(tszh, tszl, imm3, opc, Zn, Zd uint32) Instruction {
    if tszh &^ 0b11 != 0 {
        panic("sve_int_bin_cons_shift_b: invalid tszh")
    }
    if tszl &^ 0b11 != 0 {
        panic("sve_int_bin_cons_shift_b: invalid tszl")
    }
    if imm3 &^ 0b111 != 0 {
        panic("sve_int_bin_cons_shift_b: invalid imm3")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_bin_cons_shift_b: invalid opc")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_shift_b: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_bin_cons_shift_b: invalid Zd")
    }
    ret := uint32(0x04209000)
    ret |= tszh << 22
    ret |= tszl << 19
    ret |= imm3 << 16
    ret |= opc << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_bin_pred_arit_0: SVE integer add/subtract vectors (predicated)
func sve_int_bin_pred_arit_0(size, opc, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_pred_arit_0: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_bin_pred_arit_0: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_bin_pred_arit_0: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_arit_0: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_arit_0: invalid Zdn")
    }
    ret := uint32(0x04000000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_bin_pred_arit_1: SVE integer min/max/difference (predicated)
func sve_int_bin_pred_arit_1(size, opc, U, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_pred_arit_1: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_bin_pred_arit_1: invalid opc")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_bin_pred_arit_1: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_bin_pred_arit_1: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_arit_1: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_arit_1: invalid Zdn")
    }
    ret := uint32(0x04080000)
    ret |= size << 22
    ret |= opc << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_bin_pred_arit_2: SVE integer multiply vectors (predicated)
func sve_int_bin_pred_arit_2(size, H, U, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_pred_arit_2: invalid size")
    }
    if H &^ 0b1 != 0 {
        panic("sve_int_bin_pred_arit_2: invalid H")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_bin_pred_arit_2: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_bin_pred_arit_2: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_arit_2: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_arit_2: invalid Zdn")
    }
    ret := uint32(0x04100000)
    ret |= size << 22
    ret |= H << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_bin_pred_div: SVE integer divide vectors (predicated)
func sve_int_bin_pred_div(size, R, U, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_pred_div: invalid size")
    }
    if R &^ 0b1 != 0 {
        panic("sve_int_bin_pred_div: invalid R")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_bin_pred_div: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_bin_pred_div: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_div: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_div: invalid Zdn")
    }
    ret := uint32(0x04140000)
    ret |= size << 22
    ret |= R << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_bin_pred_log: SVE bitwise logical operations (predicated)
func sve_int_bin_pred_log(size, opc, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_pred_log: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_bin_pred_log: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_bin_pred_log: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_log: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_log: invalid Zdn")
    }
    ret := uint32(0x04180000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_bin_pred_shift_0: SVE bitwise shift by immediate (predicated)
func sve_int_bin_pred_shift_0(tszh, opc, L, U, Pg, tszl, imm3, Zdn uint32) Instruction {
    if tszh &^ 0b11 != 0 {
        panic("sve_int_bin_pred_shift_0: invalid tszh")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_bin_pred_shift_0: invalid opc")
    }
    if L &^ 0b1 != 0 {
        panic("sve_int_bin_pred_shift_0: invalid L")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_bin_pred_shift_0: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_bin_pred_shift_0: invalid Pg")
    }
    if tszl &^ 0b11 != 0 {
        panic("sve_int_bin_pred_shift_0: invalid tszl")
    }
    if imm3 &^ 0b111 != 0 {
        panic("sve_int_bin_pred_shift_0: invalid imm3")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_shift_0: invalid Zdn")
    }
    ret := uint32(0x04008000)
    ret |= tszh << 22
    ret |= opc << 18
    ret |= L << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= tszl << 8
    ret |= imm3 << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_bin_pred_shift_1: SVE bitwise shift by vector (predicated)
func sve_int_bin_pred_shift_1(size, R, L, U, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_pred_shift_1: invalid size")
    }
    if R &^ 0b1 != 0 {
        panic("sve_int_bin_pred_shift_1: invalid R")
    }
    if L &^ 0b1 != 0 {
        panic("sve_int_bin_pred_shift_1: invalid L")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_bin_pred_shift_1: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_bin_pred_shift_1: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_shift_1: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_shift_1: invalid Zdn")
    }
    ret := uint32(0x04108000)
    ret |= size << 22
    ret |= R << 18
    ret |= L << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_bin_pred_shift_2: SVE bitwise shift by wide elements (predicated)
func sve_int_bin_pred_shift_2(size, R, L, U, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_bin_pred_shift_2: invalid size")
    }
    if R &^ 0b1 != 0 {
        panic("sve_int_bin_pred_shift_2: invalid R")
    }
    if L &^ 0b1 != 0 {
        panic("sve_int_bin_pred_shift_2: invalid L")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_bin_pred_shift_2: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_bin_pred_shift_2: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_shift_2: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_bin_pred_shift_2: invalid Zdn")
    }
    ret := uint32(0x04188000)
    ret |= size << 22
    ret |= R << 18
    ret |= L << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_break: SVE partition break condition
func sve_int_break(B, S, Pg, Pn, M, Pd uint32) Instruction {
    if B &^ 0b1 != 0 {
        panic("sve_int_break: invalid B")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_break: invalid S")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_break: invalid Pg")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_break: invalid Pn")
    }
    if M &^ 0b1 != 0 {
        panic("sve_int_break: invalid M")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_break: invalid Pd")
    }
    ret := uint32(0x25104000)
    ret |= B << 23
    ret |= S << 22
    ret |= Pg << 10
    ret |= Pn << 5
    ret |= M << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_int_brkn: SVE propagate break to next partition
func sve_int_brkn(S, Pg, Pn, Pdm uint32) Instruction {
    if S &^ 0b1 != 0 {
        panic("sve_int_brkn: invalid S")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_brkn: invalid Pg")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_brkn: invalid Pn")
    }
    if Pdm &^ 0b1111 != 0 {
        panic("sve_int_brkn: invalid Pdm")
    }
    ret := uint32(0x25184000)
    ret |= S << 22
    ret |= Pg << 10
    ret |= Pn << 5
    ret |= Pdm
    return Instruction(ret);
}

// sve_int_brkp: SVE propagate break from previous partition
func sve_int_brkp(op, S, Pm, Pg, Pn, B, Pd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_brkp: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_brkp: invalid S")
    }
    if Pm &^ 0b1111 != 0 {
        panic("sve_int_brkp: invalid Pm")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_brkp: invalid Pg")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_brkp: invalid Pn")
    }
    if B &^ 0b1 != 0 {
        panic("sve_int_brkp: invalid B")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_brkp: invalid Pd")
    }
    ret := uint32(0x2500c000)
    ret |= op << 23
    ret |= S << 22
    ret |= Pm << 16
    ret |= Pg << 10
    ret |= Pn << 5
    ret |= B << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_int_cmp_0: SVE integer compare vectors
func sve_int_cmp_0(size, Zm, op, o2, Pg, Zn, ne, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_cmp_0: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_cmp_0: invalid Zm")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_cmp_0: invalid op")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_int_cmp_0: invalid o2")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_cmp_0: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_cmp_0: invalid Zn")
    }
    if ne &^ 0b1 != 0 {
        panic("sve_int_cmp_0: invalid ne")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_cmp_0: invalid Pd")
    }
    ret := uint32(0x24000000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= op << 15
    ret |= o2 << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= ne << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_int_cmp_1: SVE integer compare with wide elements
func sve_int_cmp_1(size, Zm, U, lt, Pg, Zn, ne, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_cmp_1: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_cmp_1: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_cmp_1: invalid U")
    }
    if lt &^ 0b1 != 0 {
        panic("sve_int_cmp_1: invalid lt")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_cmp_1: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_cmp_1: invalid Zn")
    }
    if ne &^ 0b1 != 0 {
        panic("sve_int_cmp_1: invalid ne")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_cmp_1: invalid Pd")
    }
    ret := uint32(0x24004000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= U << 15
    ret |= lt << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= ne << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_int_count: SVE element count
func sve_int_count(size, imm4, op, pattern, Rd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_count: invalid size")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_int_count: invalid imm4")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_count: invalid op")
    }
    if pattern &^ 0b11111 != 0 {
        panic("sve_int_count: invalid pattern")
    }
    if Rd &^ 0b11111 != 0 {
        panic("sve_int_count: invalid Rd")
    }
    ret := uint32(0x0420e000)
    ret |= size << 22
    ret |= imm4 << 16
    ret |= op << 10
    ret |= pattern << 5
    ret |= Rd
    return Instruction(ret);
}

// sve_int_count_r: SVE inc/dec register by predicate count
func sve_int_count_r(size, op, D, opc2, Pm, Rdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_count_r: invalid size")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_count_r: invalid op")
    }
    if D &^ 0b1 != 0 {
        panic("sve_int_count_r: invalid D")
    }
    if opc2 &^ 0b11 != 0 {
        panic("sve_int_count_r: invalid opc2")
    }
    if Pm &^ 0b1111 != 0 {
        panic("sve_int_count_r: invalid Pm")
    }
    if Rdn &^ 0b11111 != 0 {
        panic("sve_int_count_r: invalid Rdn")
    }
    ret := uint32(0x252c8800)
    ret |= size << 22
    ret |= op << 17
    ret |= D << 16
    ret |= opc2 << 9
    ret |= Pm << 5
    ret |= Rdn
    return Instruction(ret);
}

// sve_int_count_r_sat: SVE saturating inc/dec register by predicate count
func sve_int_count_r_sat(size, D, U, sf, op, Pm, Rdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_count_r_sat: invalid size")
    }
    if D &^ 0b1 != 0 {
        panic("sve_int_count_r_sat: invalid D")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_count_r_sat: invalid U")
    }
    if sf &^ 0b1 != 0 {
        panic("sve_int_count_r_sat: invalid sf")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_count_r_sat: invalid op")
    }
    if Pm &^ 0b1111 != 0 {
        panic("sve_int_count_r_sat: invalid Pm")
    }
    if Rdn &^ 0b11111 != 0 {
        panic("sve_int_count_r_sat: invalid Rdn")
    }
    ret := uint32(0x25288800)
    ret |= size << 22
    ret |= D << 17
    ret |= U << 16
    ret |= sf << 10
    ret |= op << 9
    ret |= Pm << 5
    ret |= Rdn
    return Instruction(ret);
}

// sve_int_count_v: SVE inc/dec vector by predicate count
func sve_int_count_v(size, op, D, opc2, Pm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_count_v: invalid size")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_count_v: invalid op")
    }
    if D &^ 0b1 != 0 {
        panic("sve_int_count_v: invalid D")
    }
    if opc2 &^ 0b11 != 0 {
        panic("sve_int_count_v: invalid opc2")
    }
    if Pm &^ 0b1111 != 0 {
        panic("sve_int_count_v: invalid Pm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_count_v: invalid Zdn")
    }
    ret := uint32(0x252c8000)
    ret |= size << 22
    ret |= op << 17
    ret |= D << 16
    ret |= opc2 << 9
    ret |= Pm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_count_v_sat: SVE saturating inc/dec vector by predicate count
func sve_int_count_v_sat(size, D, U, opc, Pm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_count_v_sat: invalid size")
    }
    if D &^ 0b1 != 0 {
        panic("sve_int_count_v_sat: invalid D")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_count_v_sat: invalid U")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_count_v_sat: invalid opc")
    }
    if Pm &^ 0b1111 != 0 {
        panic("sve_int_count_v_sat: invalid Pm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_count_v_sat: invalid Zdn")
    }
    ret := uint32(0x25288000)
    ret |= size << 22
    ret |= D << 17
    ret |= U << 16
    ret |= opc << 9
    ret |= Pm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_countvlv0: SVE saturating inc/dec vector by element count
func sve_int_countvlv0(size, imm4, D, U, pattern, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_countvlv0: invalid size")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_int_countvlv0: invalid imm4")
    }
    if D &^ 0b1 != 0 {
        panic("sve_int_countvlv0: invalid D")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_countvlv0: invalid U")
    }
    if pattern &^ 0b11111 != 0 {
        panic("sve_int_countvlv0: invalid pattern")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_countvlv0: invalid Zdn")
    }
    ret := uint32(0x0420c000)
    ret |= size << 22
    ret |= imm4 << 16
    ret |= D << 11
    ret |= U << 10
    ret |= pattern << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_countvlv1: SVE inc/dec vector by element count
func sve_int_countvlv1(size, imm4, D, pattern, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_countvlv1: invalid size")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_int_countvlv1: invalid imm4")
    }
    if D &^ 0b1 != 0 {
        panic("sve_int_countvlv1: invalid D")
    }
    if pattern &^ 0b11111 != 0 {
        panic("sve_int_countvlv1: invalid pattern")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_countvlv1: invalid Zdn")
    }
    ret := uint32(0x0430c000)
    ret |= size << 22
    ret |= imm4 << 16
    ret |= D << 10
    ret |= pattern << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_cterm: SVE conditionally terminate scalars
func sve_int_cterm(op, sz, Rm, Rn, ne uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_cterm: invalid op")
    }
    if sz &^ 0b1 != 0 {
        panic("sve_int_cterm: invalid sz")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_int_cterm: invalid Rm")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_int_cterm: invalid Rn")
    }
    if ne &^ 0b1 != 0 {
        panic("sve_int_cterm: invalid ne")
    }
    ret := uint32(0x25202000)
    ret |= op << 23
    ret |= sz << 22
    ret |= Rm << 16
    ret |= Rn << 5
    ret |= ne << 4
    return Instruction(ret);
}

// sve_int_dup_fpimm: SVE broadcast floating-point immediate (unpredicated)
func sve_int_dup_fpimm(size, opc, o2, imm8, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_dup_fpimm: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_dup_fpimm: invalid opc")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_int_dup_fpimm: invalid o2")
    }
    if imm8 &^ 0b11111111 != 0 {
        panic("sve_int_dup_fpimm: invalid imm8")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_dup_fpimm: invalid Zd")
    }
    ret := uint32(0x2539c000)
    ret |= size << 22
    ret |= opc << 17
    ret |= o2 << 13
    ret |= imm8 << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_dup_fpimm_pred: SVE copy floating-point immediate (predicated)
func sve_int_dup_fpimm_pred(size, Pg, imm8, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_dup_fpimm_pred: invalid size")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_dup_fpimm_pred: invalid Pg")
    }
    if imm8 &^ 0b11111111 != 0 {
        panic("sve_int_dup_fpimm_pred: invalid imm8")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_dup_fpimm_pred: invalid Zd")
    }
    ret := uint32(0x0510c000)
    ret |= size << 22
    ret |= Pg << 16
    ret |= imm8 << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_dup_imm: SVE broadcast integer immediate (unpredicated)
func sve_int_dup_imm(size, opc, sh, imm8, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_dup_imm: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_dup_imm: invalid opc")
    }
    if sh &^ 0b1 != 0 {
        panic("sve_int_dup_imm: invalid sh")
    }
    if imm8 &^ 0b11111111 != 0 {
        panic("sve_int_dup_imm: invalid imm8")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_dup_imm: invalid Zd")
    }
    ret := uint32(0x2538c000)
    ret |= size << 22
    ret |= opc << 17
    ret |= sh << 13
    ret |= imm8 << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_dup_imm_pred: SVE copy integer immediate (predicated)
func sve_int_dup_imm_pred(size, Pg, M, sh, imm8, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_dup_imm_pred: invalid size")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_dup_imm_pred: invalid Pg")
    }
    if M &^ 0b1 != 0 {
        panic("sve_int_dup_imm_pred: invalid M")
    }
    if sh &^ 0b1 != 0 {
        panic("sve_int_dup_imm_pred: invalid sh")
    }
    if imm8 &^ 0b11111111 != 0 {
        panic("sve_int_dup_imm_pred: invalid imm8")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_dup_imm_pred: invalid Zd")
    }
    ret := uint32(0x05100000)
    ret |= size << 22
    ret |= Pg << 16
    ret |= M << 14
    ret |= sh << 13
    ret |= imm8 << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_dup_mask_imm: SVE broadcast bitmask immediate
func sve_int_dup_mask_imm(imm13, Zd uint32) Instruction {
    if imm13 &^ 0b1111111111111 != 0 {
        panic("sve_int_dup_mask_imm: invalid imm13")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_dup_mask_imm: invalid Zd")
    }
    ret := uint32(0x05c00000)
    ret |= imm13 << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_index_ii: SVE index generation (immediate start, immediate increment)
func sve_int_index_ii(size, imm5b, imm5, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_index_ii: invalid size")
    }
    if imm5b &^ 0b11111 != 0 {
        panic("sve_int_index_ii: invalid imm5b")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_int_index_ii: invalid imm5")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_index_ii: invalid Zd")
    }
    ret := uint32(0x04204000)
    ret |= size << 22
    ret |= imm5b << 16
    ret |= imm5 << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_index_ir: SVE index generation (immediate start, register increment)
func sve_int_index_ir(size, Rm, imm5, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_index_ir: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_int_index_ir: invalid Rm")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_int_index_ir: invalid imm5")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_index_ir: invalid Zd")
    }
    ret := uint32(0x04204800)
    ret |= size << 22
    ret |= Rm << 16
    ret |= imm5 << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_index_ri: SVE index generation (register start, immediate increment)
func sve_int_index_ri(size, imm5, Rn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_index_ri: invalid size")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_int_index_ri: invalid imm5")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_int_index_ri: invalid Rn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_index_ri: invalid Zd")
    }
    ret := uint32(0x04204400)
    ret |= size << 22
    ret |= imm5 << 16
    ret |= Rn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_index_rr: SVE index generation (register start, register increment)
func sve_int_index_rr(size, Rm, Rn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_index_rr: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_int_index_rr: invalid Rm")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_int_index_rr: invalid Rn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_index_rr: invalid Zd")
    }
    ret := uint32(0x04204c00)
    ret |= size << 22
    ret |= Rm << 16
    ret |= Rn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_log_imm: SVE bitwise logical with immediate (unpredicated)
func sve_int_log_imm(opc, imm13, Zdn uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_int_log_imm: invalid opc")
    }
    if imm13 &^ 0b1111111111111 != 0 {
        panic("sve_int_log_imm: invalid imm13")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_log_imm: invalid Zdn")
    }
    ret := uint32(0x05000000)
    ret |= opc << 22
    ret |= imm13 << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_mladdsub_vvv_pred: SVE integer multiply-add writing multiplicand (predicated)
func sve_int_mladdsub_vvv_pred(size, Zm, op, Pg, Za, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_mladdsub_vvv_pred: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_mladdsub_vvv_pred: invalid Zm")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_mladdsub_vvv_pred: invalid op")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_mladdsub_vvv_pred: invalid Pg")
    }
    if Za &^ 0b11111 != 0 {
        panic("sve_int_mladdsub_vvv_pred: invalid Za")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_mladdsub_vvv_pred: invalid Zdn")
    }
    ret := uint32(0x0400c000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= op << 13
    ret |= Pg << 10
    ret |= Za << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_mlas_vvv_pred: SVE integer multiply-accumulate writing addend (predicated)
func sve_int_mlas_vvv_pred(size, Zm, op, Pg, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_mlas_vvv_pred: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_mlas_vvv_pred: invalid Zm")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_mlas_vvv_pred: invalid op")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_mlas_vvv_pred: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_mlas_vvv_pred: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_int_mlas_vvv_pred: invalid Zda")
    }
    ret := uint32(0x04004000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= op << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_int_movprfx_pred: SVE constructive prefix (predicated)
func sve_int_movprfx_pred(size, opc, M, Pg, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_movprfx_pred: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_movprfx_pred: invalid opc")
    }
    if M &^ 0b1 != 0 {
        panic("sve_int_movprfx_pred: invalid M")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_movprfx_pred: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_movprfx_pred: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_movprfx_pred: invalid Zd")
    }
    ret := uint32(0x04102000)
    ret |= size << 22
    ret |= opc << 17
    ret |= M << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_pcount_pred: SVE predicate count
func sve_int_pcount_pred(size, opc, Pg, o2, Pn, Rd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_pcount_pred: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_pcount_pred: invalid opc")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_pcount_pred: invalid Pg")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_int_pcount_pred: invalid o2")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_pcount_pred: invalid Pn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("sve_int_pcount_pred: invalid Rd")
    }
    ret := uint32(0x25208000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= o2 << 9
    ret |= Pn << 5
    ret |= Rd
    return Instruction(ret);
}

// sve_int_perm_bin_long_perm_zz: SVE permute vector segments
func sve_int_perm_bin_long_perm_zz(op, Zm, opc2, Zn, Zd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_perm_bin_long_perm_zz: invalid op")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_perm_bin_long_perm_zz: invalid Zm")
    }
    if opc2 &^ 0b111 != 0 {
        panic("sve_int_perm_bin_long_perm_zz: invalid opc2")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_bin_long_perm_zz: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_bin_long_perm_zz: invalid Zd")
    }
    ret := uint32(0x05a00000)
    ret |= op << 22
    ret |= Zm << 16
    ret |= opc2 << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_bin_perm_pp: SVE permute predicate elements
func sve_int_perm_bin_perm_pp(size, Pm, opc, H, Pn, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_bin_perm_pp: invalid size")
    }
    if Pm &^ 0b1111 != 0 {
        panic("sve_int_perm_bin_perm_pp: invalid Pm")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_perm_bin_perm_pp: invalid opc")
    }
    if H &^ 0b1 != 0 {
        panic("sve_int_perm_bin_perm_pp: invalid H")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_perm_bin_perm_pp: invalid Pn")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_perm_bin_perm_pp: invalid Pd")
    }
    ret := uint32(0x05204000)
    ret |= size << 22
    ret |= Pm << 16
    ret |= opc << 11
    ret |= H << 10
    ret |= Pn << 5
    ret |= Pd
    return Instruction(ret);
}

// sve_int_perm_bin_perm_zz: SVE permute vector elements
func sve_int_perm_bin_perm_zz(size, Zm, opc, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_bin_perm_zz: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_perm_bin_perm_zz: invalid Zm")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_perm_bin_perm_zz: invalid opc")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_bin_perm_zz: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_bin_perm_zz: invalid Zd")
    }
    ret := uint32(0x05206000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= opc << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_clast_rz: SVE conditionally extract element to general register
func sve_int_perm_clast_rz(size, B, Pg, Zm, Rdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_clast_rz: invalid size")
    }
    if B &^ 0b1 != 0 {
        panic("sve_int_perm_clast_rz: invalid B")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_clast_rz: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_perm_clast_rz: invalid Zm")
    }
    if Rdn &^ 0b11111 != 0 {
        panic("sve_int_perm_clast_rz: invalid Rdn")
    }
    ret := uint32(0x0530a000)
    ret |= size << 22
    ret |= B << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Rdn
    return Instruction(ret);
}

// sve_int_perm_clast_vz: SVE conditionally extract element to SIMD&FP scalar
func sve_int_perm_clast_vz(size, B, Pg, Zm, Vdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_clast_vz: invalid size")
    }
    if B &^ 0b1 != 0 {
        panic("sve_int_perm_clast_vz: invalid B")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_clast_vz: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_perm_clast_vz: invalid Zm")
    }
    if Vdn &^ 0b11111 != 0 {
        panic("sve_int_perm_clast_vz: invalid Vdn")
    }
    ret := uint32(0x052a8000)
    ret |= size << 22
    ret |= B << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Vdn
    return Instruction(ret);
}

// sve_int_perm_clast_zz: SVE conditionally broadcast element to vector
func sve_int_perm_clast_zz(size, B, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_clast_zz: invalid size")
    }
    if B &^ 0b1 != 0 {
        panic("sve_int_perm_clast_zz: invalid B")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_clast_zz: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_perm_clast_zz: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_perm_clast_zz: invalid Zdn")
    }
    ret := uint32(0x05288000)
    ret |= size << 22
    ret |= B << 16
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_perm_compact: SVE compress active elements
func sve_int_perm_compact(size, Pg, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_compact: invalid size")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_compact: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_compact: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_compact: invalid Zd")
    }
    ret := uint32(0x05218000)
    ret |= size << 22
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_cpy_r: SVE copy general register to vector (predicated)
func sve_int_perm_cpy_r(size, Pg, Rn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_cpy_r: invalid size")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_cpy_r: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_int_perm_cpy_r: invalid Rn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_cpy_r: invalid Zd")
    }
    ret := uint32(0x0528a000)
    ret |= size << 22
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_cpy_v: SVE copy SIMD&FP scalar register to vector (predicated)
func sve_int_perm_cpy_v(size, Pg, Vn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_cpy_v: invalid size")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_cpy_v: invalid Pg")
    }
    if Vn &^ 0b11111 != 0 {
        panic("sve_int_perm_cpy_v: invalid Vn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_cpy_v: invalid Zd")
    }
    ret := uint32(0x05208000)
    ret |= size << 22
    ret |= Pg << 10
    ret |= Vn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_dup_i: SVE broadcast indexed element
func sve_int_perm_dup_i(imm2, tsz, Zn, Zd uint32) Instruction {
    if imm2 &^ 0b11 != 0 {
        panic("sve_int_perm_dup_i: invalid imm2")
    }
    if tsz &^ 0b11111 != 0 {
        panic("sve_int_perm_dup_i: invalid tsz")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_dup_i: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_dup_i: invalid Zd")
    }
    ret := uint32(0x05202000)
    ret |= imm2 << 22
    ret |= tsz << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_dup_r: SVE broadcast general register
func sve_int_perm_dup_r(size, Rn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_dup_r: invalid size")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_int_perm_dup_r: invalid Rn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_dup_r: invalid Zd")
    }
    ret := uint32(0x05203800)
    ret |= size << 22
    ret |= Rn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_extract_i: SVE extract vector (immediate offset, destructive)
func sve_int_perm_extract_i(imm8h, imm8l, Zm, Zdn uint32) Instruction {
    if imm8h &^ 0b11111 != 0 {
        panic("sve_int_perm_extract_i: invalid imm8h")
    }
    if imm8l &^ 0b111 != 0 {
        panic("sve_int_perm_extract_i: invalid imm8l")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_perm_extract_i: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_perm_extract_i: invalid Zdn")
    }
    ret := uint32(0x05200000)
    ret |= imm8h << 16
    ret |= imm8l << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_perm_insrs: SVE insert general register
func sve_int_perm_insrs(size, Rm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_insrs: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_int_perm_insrs: invalid Rm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_perm_insrs: invalid Zdn")
    }
    ret := uint32(0x05243800)
    ret |= size << 22
    ret |= Rm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_perm_insrv: SVE insert SIMD&FP scalar register
func sve_int_perm_insrv(size, Vm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_insrv: invalid size")
    }
    if Vm &^ 0b11111 != 0 {
        panic("sve_int_perm_insrv: invalid Vm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_perm_insrv: invalid Zdn")
    }
    ret := uint32(0x05343800)
    ret |= size << 22
    ret |= Vm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_perm_last_r: SVE extract element to general register
func sve_int_perm_last_r(size, B, Pg, Zn, Rd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_last_r: invalid size")
    }
    if B &^ 0b1 != 0 {
        panic("sve_int_perm_last_r: invalid B")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_last_r: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_last_r: invalid Zn")
    }
    if Rd &^ 0b11111 != 0 {
        panic("sve_int_perm_last_r: invalid Rd")
    }
    ret := uint32(0x0520a000)
    ret |= size << 22
    ret |= B << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Rd
    return Instruction(ret);
}

// sve_int_perm_last_v: SVE extract element to SIMD&FP scalar register
func sve_int_perm_last_v(size, B, Pg, Zn, Vd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_last_v: invalid size")
    }
    if B &^ 0b1 != 0 {
        panic("sve_int_perm_last_v: invalid B")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_last_v: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_last_v: invalid Zn")
    }
    if Vd &^ 0b11111 != 0 {
        panic("sve_int_perm_last_v: invalid Vd")
    }
    ret := uint32(0x05228000)
    ret |= size << 22
    ret |= B << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Vd
    return Instruction(ret);
}

// sve_int_perm_punpk: SVE unpack predicate elements
func sve_int_perm_punpk(H, Pn, Pd uint32) Instruction {
    if H &^ 0b1 != 0 {
        panic("sve_int_perm_punpk: invalid H")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_perm_punpk: invalid Pn")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_perm_punpk: invalid Pd")
    }
    ret := uint32(0x05304000)
    ret |= H << 16
    ret |= Pn << 5
    ret |= Pd
    return Instruction(ret);
}

// sve_int_perm_rev: SVE reverse within elements
func sve_int_perm_rev(size, opc, Pg, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_rev: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_perm_rev: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_rev: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_rev: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_rev: invalid Zd")
    }
    ret := uint32(0x05248000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_reverse_p: SVE reverse predicate elements
func sve_int_perm_reverse_p(size, Pn, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_reverse_p: invalid size")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_perm_reverse_p: invalid Pn")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_perm_reverse_p: invalid Pd")
    }
    ret := uint32(0x05344000)
    ret |= size << 22
    ret |= Pn << 5
    ret |= Pd
    return Instruction(ret);
}

// sve_int_perm_reverse_z: SVE reverse vector elements
func sve_int_perm_reverse_z(size, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_reverse_z: invalid size")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_reverse_z: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_reverse_z: invalid Zd")
    }
    ret := uint32(0x05383800)
    ret |= size << 22
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_splice: SVE vector splice (destructive)
func sve_int_perm_splice(size, Pg, Zm, Zdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_splice: invalid size")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_perm_splice: invalid Pg")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_perm_splice: invalid Zm")
    }
    if Zdn &^ 0b11111 != 0 {
        panic("sve_int_perm_splice: invalid Zdn")
    }
    ret := uint32(0x052c8000)
    ret |= size << 22
    ret |= Pg << 10
    ret |= Zm << 5
    ret |= Zdn
    return Instruction(ret);
}

// sve_int_perm_tbl: SVE table lookup
func sve_int_perm_tbl(size, Zm, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_tbl: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_perm_tbl: invalid Zm")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_tbl: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_tbl: invalid Zd")
    }
    ret := uint32(0x05203000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_perm_unpk: SVE unpack vector elements
func sve_int_perm_unpk(size, U, H, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_perm_unpk: invalid size")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_perm_unpk: invalid U")
    }
    if H &^ 0b1 != 0 {
        panic("sve_int_perm_unpk: invalid H")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_perm_unpk: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_perm_unpk: invalid Zd")
    }
    ret := uint32(0x05303800)
    ret |= size << 22
    ret |= U << 17
    ret |= H << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_pfalse: SVE predicate zero
func sve_int_pfalse(op, S, Pd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_pfalse: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_pfalse: invalid S")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_pfalse: invalid Pd")
    }
    ret := uint32(0x2518e400)
    ret |= op << 23
    ret |= S << 22
    ret |= Pd
    return Instruction(ret);
}

// sve_int_pfirst: SVE predicate first active
func sve_int_pfirst(op, S, Pg, Pdn uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_pfirst: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_pfirst: invalid S")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_pfirst: invalid Pg")
    }
    if Pdn &^ 0b1111 != 0 {
        panic("sve_int_pfirst: invalid Pdn")
    }
    ret := uint32(0x2518c000)
    ret |= op << 23
    ret |= S << 22
    ret |= Pg << 5
    ret |= Pdn
    return Instruction(ret);
}

// sve_int_pnext: SVE predicate next active
func sve_int_pnext(size, Pg, Pdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_pnext: invalid size")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_pnext: invalid Pg")
    }
    if Pdn &^ 0b1111 != 0 {
        panic("sve_int_pnext: invalid Pdn")
    }
    ret := uint32(0x2519c400)
    ret |= size << 22
    ret |= Pg << 5
    ret |= Pdn
    return Instruction(ret);
}

// sve_int_pred_log: SVE predicate logical operations
func sve_int_pred_log(op, S, Pm, Pg, o2, Pn, o3, Pd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_pred_log: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_pred_log: invalid S")
    }
    if Pm &^ 0b1111 != 0 {
        panic("sve_int_pred_log: invalid Pm")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_pred_log: invalid Pg")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_int_pred_log: invalid o2")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_pred_log: invalid Pn")
    }
    if o3 &^ 0b1 != 0 {
        panic("sve_int_pred_log: invalid o3")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_pred_log: invalid Pd")
    }
    ret := uint32(0x25004000)
    ret |= op << 23
    ret |= S << 22
    ret |= Pm << 16
    ret |= Pg << 10
    ret |= o2 << 9
    ret |= Pn << 5
    ret |= o3 << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_int_pred_pattern_a: SVE inc/dec register by element count
func sve_int_pred_pattern_a(size, imm4, D, pattern, Rdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_pred_pattern_a: invalid size")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_int_pred_pattern_a: invalid imm4")
    }
    if D &^ 0b1 != 0 {
        panic("sve_int_pred_pattern_a: invalid D")
    }
    if pattern &^ 0b11111 != 0 {
        panic("sve_int_pred_pattern_a: invalid pattern")
    }
    if Rdn &^ 0b11111 != 0 {
        panic("sve_int_pred_pattern_a: invalid Rdn")
    }
    ret := uint32(0x0430e000)
    ret |= size << 22
    ret |= imm4 << 16
    ret |= D << 10
    ret |= pattern << 5
    ret |= Rdn
    return Instruction(ret);
}

// sve_int_pred_pattern_b: SVE saturating inc/dec register by element count
func sve_int_pred_pattern_b(size, sf, imm4, D, U, pattern, Rdn uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_pred_pattern_b: invalid size")
    }
    if sf &^ 0b1 != 0 {
        panic("sve_int_pred_pattern_b: invalid sf")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_int_pred_pattern_b: invalid imm4")
    }
    if D &^ 0b1 != 0 {
        panic("sve_int_pred_pattern_b: invalid D")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_pred_pattern_b: invalid U")
    }
    if pattern &^ 0b11111 != 0 {
        panic("sve_int_pred_pattern_b: invalid pattern")
    }
    if Rdn &^ 0b11111 != 0 {
        panic("sve_int_pred_pattern_b: invalid Rdn")
    }
    ret := uint32(0x0420f000)
    ret |= size << 22
    ret |= sf << 20
    ret |= imm4 << 16
    ret |= D << 11
    ret |= U << 10
    ret |= pattern << 5
    ret |= Rdn
    return Instruction(ret);
}

// sve_int_ptest: SVE predicate test
func sve_int_ptest(op, S, Pg, Pn, opc2 uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_ptest: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_ptest: invalid S")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_ptest: invalid Pg")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_ptest: invalid Pn")
    }
    if opc2 &^ 0b1111 != 0 {
        panic("sve_int_ptest: invalid opc2")
    }
    ret := uint32(0x2510c000)
    ret |= op << 23
    ret |= S << 22
    ret |= Pg << 10
    ret |= Pn << 5
    ret |= opc2
    return Instruction(ret);
}

// sve_int_ptrue: SVE predicate initialize
func sve_int_ptrue(size, S, pattern, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_ptrue: invalid size")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_ptrue: invalid S")
    }
    if pattern &^ 0b11111 != 0 {
        panic("sve_int_ptrue: invalid pattern")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_ptrue: invalid Pd")
    }
    ret := uint32(0x2518e000)
    ret |= size << 22
    ret |= S << 16
    ret |= pattern << 5
    ret |= Pd
    return Instruction(ret);
}

// sve_int_rdffr: SVE predicate read from FFR (predicated)
func sve_int_rdffr(op, S, Pg, Pd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_rdffr: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_rdffr: invalid S")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_rdffr: invalid Pg")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_rdffr: invalid Pd")
    }
    ret := uint32(0x2518f000)
    ret |= op << 23
    ret |= S << 22
    ret |= Pg << 5
    ret |= Pd
    return Instruction(ret);
}

// sve_int_rdffr_2: SVE predicate read from FFR (unpredicated)
func sve_int_rdffr_2(op, S, Pd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_rdffr_2: invalid op")
    }
    if S &^ 0b1 != 0 {
        panic("sve_int_rdffr_2: invalid S")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_rdffr_2: invalid Pd")
    }
    ret := uint32(0x2519f000)
    ret |= op << 23
    ret |= S << 22
    ret |= Pd
    return Instruction(ret);
}

// sve_int_read_vl_a: SVE stack frame size
func sve_int_read_vl_a(op, opc2, imm6, Rd uint32) Instruction {
    if op &^ 0b1 != 0 {
        panic("sve_int_read_vl_a: invalid op")
    }
    if opc2 &^ 0b11111 != 0 {
        panic("sve_int_read_vl_a: invalid opc2")
    }
    if imm6 &^ 0b111111 != 0 {
        panic("sve_int_read_vl_a: invalid imm6")
    }
    if Rd &^ 0b11111 != 0 {
        panic("sve_int_read_vl_a: invalid Rd")
    }
    ret := uint32(0x04a05000)
    ret |= op << 22
    ret |= opc2 << 16
    ret |= imm6 << 5
    ret |= Rd
    return Instruction(ret);
}

// sve_int_reduce_0: SVE integer add reduction (predicated)
func sve_int_reduce_0(size, opc, U, Pg, Zn, Vd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_reduce_0: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_reduce_0: invalid opc")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_reduce_0: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_reduce_0: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_reduce_0: invalid Zn")
    }
    if Vd &^ 0b11111 != 0 {
        panic("sve_int_reduce_0: invalid Vd")
    }
    ret := uint32(0x04002000)
    ret |= size << 22
    ret |= opc << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Vd
    return Instruction(ret);
}

// sve_int_reduce_1: SVE integer min/max reduction (predicated)
func sve_int_reduce_1(size, opc, U, Pg, Zn, Vd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_reduce_1: invalid size")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_int_reduce_1: invalid opc")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_reduce_1: invalid U")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_reduce_1: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_reduce_1: invalid Zn")
    }
    if Vd &^ 0b11111 != 0 {
        panic("sve_int_reduce_1: invalid Vd")
    }
    ret := uint32(0x04082000)
    ret |= size << 22
    ret |= opc << 17
    ret |= U << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Vd
    return Instruction(ret);
}

// sve_int_reduce_2: SVE bitwise logical reduction (predicated)
func sve_int_reduce_2(size, opc, Pg, Zn, Vd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_reduce_2: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_reduce_2: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_reduce_2: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_reduce_2: invalid Zn")
    }
    if Vd &^ 0b11111 != 0 {
        panic("sve_int_reduce_2: invalid Vd")
    }
    ret := uint32(0x04182000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Vd
    return Instruction(ret);
}

// sve_int_scmp_vi: SVE integer compare with signed immediate
func sve_int_scmp_vi(size, imm5, op, o2, Pg, Zn, ne, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_scmp_vi: invalid size")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_int_scmp_vi: invalid imm5")
    }
    if op &^ 0b1 != 0 {
        panic("sve_int_scmp_vi: invalid op")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_int_scmp_vi: invalid o2")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_scmp_vi: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_scmp_vi: invalid Zn")
    }
    if ne &^ 0b1 != 0 {
        panic("sve_int_scmp_vi: invalid ne")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_scmp_vi: invalid Pd")
    }
    ret := uint32(0x25000000)
    ret |= size << 22
    ret |= imm5 << 16
    ret |= op << 15
    ret |= o2 << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= ne << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_int_sel_vvv: SVE select vector elements (predicated)
func sve_int_sel_vvv(size, Zm, Pg, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_sel_vvv: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_int_sel_vvv: invalid Zm")
    }
    if Pg &^ 0b1111 != 0 {
        panic("sve_int_sel_vvv: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_sel_vvv: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_sel_vvv: invalid Zd")
    }
    ret := uint32(0x0520c000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_setffr: SVE FFR initialise
func sve_int_setffr(opc uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_int_setffr: invalid opc")
    }
    ret := uint32(0x252c9000)
    ret |= opc << 22
    return Instruction(ret);
}

// sve_int_ucmp_vi: SVE integer compare with unsigned immediate
func sve_int_ucmp_vi(size, imm7, lt, Pg, Zn, ne, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_ucmp_vi: invalid size")
    }
    if imm7 &^ 0b1111111 != 0 {
        panic("sve_int_ucmp_vi: invalid imm7")
    }
    if lt &^ 0b1 != 0 {
        panic("sve_int_ucmp_vi: invalid lt")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_ucmp_vi: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_ucmp_vi: invalid Zn")
    }
    if ne &^ 0b1 != 0 {
        panic("sve_int_ucmp_vi: invalid ne")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_ucmp_vi: invalid Pd")
    }
    ret := uint32(0x24200000)
    ret |= size << 22
    ret |= imm7 << 14
    ret |= lt << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= ne << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_int_un_pred_arit_0: SVE integer unary operations (predicated)
func sve_int_un_pred_arit_0(size, opc, Pg, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_un_pred_arit_0: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_un_pred_arit_0: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_un_pred_arit_0: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_un_pred_arit_0: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_un_pred_arit_0: invalid Zd")
    }
    ret := uint32(0x0410a000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_un_pred_arit_1: SVE bitwise unary operations (predicated)
func sve_int_un_pred_arit_1(size, opc, Pg, Zn, Zd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_un_pred_arit_1: invalid size")
    }
    if opc &^ 0b111 != 0 {
        panic("sve_int_un_pred_arit_1: invalid opc")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_int_un_pred_arit_1: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_int_un_pred_arit_1: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_int_un_pred_arit_1: invalid Zd")
    }
    ret := uint32(0x0418a000)
    ret |= size << 22
    ret |= opc << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_int_while_rr: SVE integer compare scalar count and limit
func sve_int_while_rr(size, Rm, sf, U, lt, Rn, eq, Pd uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_int_while_rr: invalid size")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_int_while_rr: invalid Rm")
    }
    if sf &^ 0b1 != 0 {
        panic("sve_int_while_rr: invalid sf")
    }
    if U &^ 0b1 != 0 {
        panic("sve_int_while_rr: invalid U")
    }
    if lt &^ 0b1 != 0 {
        panic("sve_int_while_rr: invalid lt")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_int_while_rr: invalid Rn")
    }
    if eq &^ 0b1 != 0 {
        panic("sve_int_while_rr: invalid eq")
    }
    if Pd &^ 0b1111 != 0 {
        panic("sve_int_while_rr: invalid Pd")
    }
    ret := uint32(0x25200000)
    ret |= size << 22
    ret |= Rm << 16
    ret |= sf << 12
    ret |= U << 11
    ret |= lt << 10
    ret |= Rn << 5
    ret |= eq << 4
    ret |= Pd
    return Instruction(ret);
}

// sve_int_wrffr: SVE FFR write from predicate
func sve_int_wrffr(opc, Pn uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_int_wrffr: invalid opc")
    }
    if Pn &^ 0b1111 != 0 {
        panic("sve_int_wrffr: invalid Pn")
    }
    ret := uint32(0x25289000)
    ret |= opc << 22
    ret |= Pn << 5
    return Instruction(ret);
}

// sve_intx_dot: SVE integer dot product (unpredicated)
func sve_intx_dot(size, Zm, U, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_intx_dot: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_intx_dot: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_intx_dot: invalid U")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_intx_dot: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_intx_dot: invalid Zda")
    }
    ret := uint32(0x44000000)
    ret |= size << 22
    ret |= Zm << 16
    ret |= U << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_intx_dot_by_indexed_elem: SVE integer dot product (indexed)
func sve_intx_dot_by_indexed_elem(size, opc, U, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_intx_dot_by_indexed_elem: invalid size")
    }
    if opc &^ 0b11111 != 0 {
        panic("sve_intx_dot_by_indexed_elem: invalid opc")
    }
    if U &^ 0b1 != 0 {
        panic("sve_intx_dot_by_indexed_elem: invalid U")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_intx_dot_by_indexed_elem: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_intx_dot_by_indexed_elem: invalid Zda")
    }
    ret := uint32(0x44200000)
    ret |= size << 22
    ret |= opc << 16
    ret |= U << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_intx_mixed_dot: SVE mixed sign dot product
func sve_intx_mixed_dot(size, Zm, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_intx_mixed_dot: invalid size")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_intx_mixed_dot: invalid Zm")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_intx_mixed_dot: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_intx_mixed_dot: invalid Zda")
    }
    ret := uint32(0x44007800)
    ret |= size << 22
    ret |= Zm << 16
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_intx_mixed_dot_by_indexed_elem: SVE mixed sign dot product (indexed)
func sve_intx_mixed_dot_by_indexed_elem(size, opc, U, Zn, Zda uint32) Instruction {
    if size &^ 0b11 != 0 {
        panic("sve_intx_mixed_dot_by_indexed_elem: invalid size")
    }
    if opc &^ 0b11111 != 0 {
        panic("sve_intx_mixed_dot_by_indexed_elem: invalid opc")
    }
    if U &^ 0b1 != 0 {
        panic("sve_intx_mixed_dot_by_indexed_elem: invalid U")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_intx_mixed_dot_by_indexed_elem: invalid Zn")
    }
    if Zda &^ 0b11111 != 0 {
        panic("sve_intx_mixed_dot_by_indexed_elem: invalid Zda")
    }
    ret := uint32(0x44201800)
    ret |= size << 22
    ret |= opc << 16
    ret |= U << 10
    ret |= Zn << 5
    ret |= Zda
    return Instruction(ret);
}

// sve_intx_mmla: SVE integer matrix multiply accumulate
func sve_intx_mmla(uns, Zm, Zn, Zd uint32) Instruction {
    if uns &^ 0b11 != 0 {
        panic("sve_intx_mmla: invalid uns")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_intx_mmla: invalid Zm")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_intx_mmla: invalid Zn")
    }
    if Zd &^ 0b11111 != 0 {
        panic("sve_intx_mmla: invalid Zd")
    }
    ret := uint32(0x45009800)
    ret |= uns << 22
    ret |= Zm << 16
    ret |= Zn << 5
    ret |= Zd
    return Instruction(ret);
}

// sve_mem_32b_fill: SVE load vector register
func sve_mem_32b_fill(imm9h, imm9l, Rn, Zt uint32) Instruction {
    if imm9h &^ 0b111111 != 0 {
        panic("sve_mem_32b_fill: invalid imm9h")
    }
    if imm9l &^ 0b111 != 0 {
        panic("sve_mem_32b_fill: invalid imm9l")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_32b_fill: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_32b_fill: invalid Zt")
    }
    ret := uint32(0x85804000)
    ret |= imm9h << 16
    ret |= imm9l << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_32b_gld_sv_a: SVE 32-bit gather load halfwords (scalar plus 32-bit scaled offsets)
func sve_mem_32b_gld_sv_a(xs, Zm, U, ff, Pg, Rn, Zt uint32) Instruction {
    if xs &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_sv_a: invalid xs")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_sv_a: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_sv_a: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_sv_a: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_32b_gld_sv_a: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_sv_a: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_sv_a: invalid Zt")
    }
    ret := uint32(0x84a00000)
    ret |= xs << 22
    ret |= Zm << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_32b_gld_sv_b: SVE 32-bit gather load words (scalar plus 32-bit scaled offsets)
func sve_mem_32b_gld_sv_b(xs, Zm, U, ff, Pg, Rn, Zt uint32) Instruction {
    if xs &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_sv_b: invalid xs")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_sv_b: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_sv_b: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_sv_b: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_32b_gld_sv_b: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_sv_b: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_sv_b: invalid Zt")
    }
    ret := uint32(0x85200000)
    ret |= xs << 22
    ret |= Zm << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_32b_gld_vi: SVE 32-bit gather load (vector plus immediate)
func sve_mem_32b_gld_vi(msz, imm5, U, ff, Pg, Zn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_32b_gld_vi: invalid msz")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_vi: invalid imm5")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_vi: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_vi: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_32b_gld_vi: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_vi: invalid Zn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_vi: invalid Zt")
    }
    ret := uint32(0x84208000)
    ret |= msz << 23
    ret |= imm5 << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_32b_gld_vs: SVE 32-bit gather load (scalar plus 32-bit unscaled offsets)
func sve_mem_32b_gld_vs(opc, xs, Zm, U, ff, Pg, Rn, Zt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_mem_32b_gld_vs: invalid opc")
    }
    if xs &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_vs: invalid xs")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_vs: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_vs: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_32b_gld_vs: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_32b_gld_vs: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_vs: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_32b_gld_vs: invalid Zt")
    }
    ret := uint32(0x84000000)
    ret |= opc << 23
    ret |= xs << 22
    ret |= Zm << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_32b_pfill: SVE load predicate register
func sve_mem_32b_pfill(imm9h, imm9l, Rn, Pt uint32) Instruction {
    if imm9h &^ 0b111111 != 0 {
        panic("sve_mem_32b_pfill: invalid imm9h")
    }
    if imm9l &^ 0b111 != 0 {
        panic("sve_mem_32b_pfill: invalid imm9l")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_32b_pfill: invalid Rn")
    }
    if Pt &^ 0b1111 != 0 {
        panic("sve_mem_32b_pfill: invalid Pt")
    }
    ret := uint32(0x85800000)
    ret |= imm9h << 16
    ret |= imm9l << 10
    ret |= Rn << 5
    ret |= Pt
    return Instruction(ret);
}

// sve_mem_32b_prfm_sv: SVE 32-bit gather prefetch (scalar plus 32-bit scaled offsets)
func sve_mem_32b_prfm_sv(xs, Zm, msz, Pg, Rn, prfop uint32) Instruction {
    if xs &^ 0b1 != 0 {
        panic("sve_mem_32b_prfm_sv: invalid xs")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_32b_prfm_sv: invalid Zm")
    }
    if msz &^ 0b11 != 0 {
        panic("sve_mem_32b_prfm_sv: invalid msz")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_32b_prfm_sv: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_32b_prfm_sv: invalid Rn")
    }
    if prfop &^ 0b1111 != 0 {
        panic("sve_mem_32b_prfm_sv: invalid prfop")
    }
    ret := uint32(0x84200000)
    ret |= xs << 22
    ret |= Zm << 16
    ret |= msz << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= prfop
    return Instruction(ret);
}

// sve_mem_32b_prfm_vi: SVE 32-bit gather prefetch (vector plus immediate)
func sve_mem_32b_prfm_vi(msz, imm5, Pg, Zn, prfop uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_32b_prfm_vi: invalid msz")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_mem_32b_prfm_vi: invalid imm5")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_32b_prfm_vi: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_mem_32b_prfm_vi: invalid Zn")
    }
    if prfop &^ 0b1111 != 0 {
        panic("sve_mem_32b_prfm_vi: invalid prfop")
    }
    ret := uint32(0x8400e000)
    ret |= msz << 23
    ret |= imm5 << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= prfop
    return Instruction(ret);
}

// sve_mem_64b_gld_sv: SVE 64-bit gather load (scalar plus 32-bit unpacked scaled offsets)
func sve_mem_64b_gld_sv(opc, xs, Zm, U, ff, Pg, Rn, Zt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_mem_64b_gld_sv: invalid opc")
    }
    if xs &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_sv: invalid xs")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_sv: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_sv: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_sv: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_64b_gld_sv: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_sv: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_sv: invalid Zt")
    }
    ret := uint32(0xc4200000)
    ret |= opc << 23
    ret |= xs << 22
    ret |= Zm << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_64b_gld_sv2: SVE 64-bit gather load (scalar plus 64-bit scaled offsets)
func sve_mem_64b_gld_sv2(opc, Zm, U, ff, Pg, Rn, Zt uint32) Instruction {
    if opc &^ 0b11 != 0 {
        panic("sve_mem_64b_gld_sv2: invalid opc")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_sv2: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_sv2: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_sv2: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_64b_gld_sv2: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_sv2: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_sv2: invalid Zt")
    }
    ret := uint32(0xc4608000)
    ret |= opc << 23
    ret |= Zm << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_64b_gld_vi: SVE 64-bit gather load (vector plus immediate)
func sve_mem_64b_gld_vi(msz, imm5, U, ff, Pg, Zn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_64b_gld_vi: invalid msz")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vi: invalid imm5")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_vi: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_vi: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_64b_gld_vi: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vi: invalid Zn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vi: invalid Zt")
    }
    ret := uint32(0xc4208000)
    ret |= msz << 23
    ret |= imm5 << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_64b_gld_vs: SVE 64-bit gather load (scalar plus unpacked 32-bit unscaled offsets)
func sve_mem_64b_gld_vs(msz, xs, Zm, U, ff, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_64b_gld_vs: invalid msz")
    }
    if xs &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_vs: invalid xs")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vs: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_vs: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_vs: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_64b_gld_vs: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vs: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vs: invalid Zt")
    }
    ret := uint32(0xc4000000)
    ret |= msz << 23
    ret |= xs << 22
    ret |= Zm << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_64b_gld_vs2: SVE 64-bit gather load (scalar plus 64-bit unscaled offsets)
func sve_mem_64b_gld_vs2(msz, Zm, U, ff, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_64b_gld_vs2: invalid msz")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vs2: invalid Zm")
    }
    if U &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_vs2: invalid U")
    }
    if ff &^ 0b1 != 0 {
        panic("sve_mem_64b_gld_vs2: invalid ff")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_64b_gld_vs2: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vs2: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_64b_gld_vs2: invalid Zt")
    }
    ret := uint32(0xc4408000)
    ret |= msz << 23
    ret |= Zm << 16
    ret |= U << 14
    ret |= ff << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_64b_prfm_sv: SVE 64-bit gather prefetch (scalar plus unpacked 32-bit scaled offsets)
func sve_mem_64b_prfm_sv(xs, Zm, msz, Pg, Rn, prfop uint32) Instruction {
    if xs &^ 0b1 != 0 {
        panic("sve_mem_64b_prfm_sv: invalid xs")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_64b_prfm_sv: invalid Zm")
    }
    if msz &^ 0b11 != 0 {
        panic("sve_mem_64b_prfm_sv: invalid msz")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_64b_prfm_sv: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_64b_prfm_sv: invalid Rn")
    }
    if prfop &^ 0b1111 != 0 {
        panic("sve_mem_64b_prfm_sv: invalid prfop")
    }
    ret := uint32(0xc4200000)
    ret |= xs << 22
    ret |= Zm << 16
    ret |= msz << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= prfop
    return Instruction(ret);
}

// sve_mem_64b_prfm_sv2: SVE 64-bit gather prefetch (scalar plus 64-bit scaled offsets)
func sve_mem_64b_prfm_sv2(Zm, msz, Pg, Rn, prfop uint32) Instruction {
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_64b_prfm_sv2: invalid Zm")
    }
    if msz &^ 0b11 != 0 {
        panic("sve_mem_64b_prfm_sv2: invalid msz")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_64b_prfm_sv2: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_64b_prfm_sv2: invalid Rn")
    }
    if prfop &^ 0b1111 != 0 {
        panic("sve_mem_64b_prfm_sv2: invalid prfop")
    }
    ret := uint32(0xc4608000)
    ret |= Zm << 16
    ret |= msz << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= prfop
    return Instruction(ret);
}

// sve_mem_64b_prfm_vi: SVE 64-bit gather prefetch (vector plus immediate)
func sve_mem_64b_prfm_vi(msz, imm5, Pg, Zn, prfop uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_64b_prfm_vi: invalid msz")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_mem_64b_prfm_vi: invalid imm5")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_64b_prfm_vi: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_mem_64b_prfm_vi: invalid Zn")
    }
    if prfop &^ 0b1111 != 0 {
        panic("sve_mem_64b_prfm_vi: invalid prfop")
    }
    ret := uint32(0xc400e000)
    ret |= msz << 23
    ret |= imm5 << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= prfop
    return Instruction(ret);
}

// sve_mem_cld_si: SVE contiguous load (scalar plus immediate)
func sve_mem_cld_si(dtype, imm4, Pg, Rn, Zt uint32) Instruction {
    if dtype &^ 0b1111 != 0 {
        panic("sve_mem_cld_si: invalid dtype")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_mem_cld_si: invalid imm4")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cld_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cld_si: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cld_si: invalid Zt")
    }
    ret := uint32(0xa400a000)
    ret |= dtype << 21
    ret |= imm4 << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cld_ss: SVE contiguous load (scalar plus scalar)
func sve_mem_cld_ss(dtype, Rm, Pg, Rn, Zt uint32) Instruction {
    if dtype &^ 0b1111 != 0 {
        panic("sve_mem_cld_ss: invalid dtype")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_cld_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cld_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cld_ss: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cld_ss: invalid Zt")
    }
    ret := uint32(0xa4004000)
    ret |= dtype << 21
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cldff_ss: SVE contiguous first-fault load (scalar plus scalar)
func sve_mem_cldff_ss(dtype, Rm, Pg, Rn, Zt uint32) Instruction {
    if dtype &^ 0b1111 != 0 {
        panic("sve_mem_cldff_ss: invalid dtype")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_cldff_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cldff_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cldff_ss: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cldff_ss: invalid Zt")
    }
    ret := uint32(0xa4006000)
    ret |= dtype << 21
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cldnf_si: SVE contiguous non-fault load (scalar plus immediate)
func sve_mem_cldnf_si(dtype, imm4, Pg, Rn, Zt uint32) Instruction {
    if dtype &^ 0b1111 != 0 {
        panic("sve_mem_cldnf_si: invalid dtype")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_mem_cldnf_si: invalid imm4")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cldnf_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cldnf_si: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cldnf_si: invalid Zt")
    }
    ret := uint32(0xa410a000)
    ret |= dtype << 21
    ret |= imm4 << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cldnt_si: SVE contiguous non-temporal load (scalar plus immediate)
func sve_mem_cldnt_si(msz, imm4, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_cldnt_si: invalid msz")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_mem_cldnt_si: invalid imm4")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cldnt_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cldnt_si: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cldnt_si: invalid Zt")
    }
    ret := uint32(0xa400e000)
    ret |= msz << 23
    ret |= imm4 << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cldnt_ss: SVE contiguous non-temporal load (scalar plus scalar)
func sve_mem_cldnt_ss(msz, Rm, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_cldnt_ss: invalid msz")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_cldnt_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cldnt_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cldnt_ss: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cldnt_ss: invalid Zt")
    }
    ret := uint32(0xa400c000)
    ret |= msz << 23
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cst_si: SVE contiguous store (scalar plus immediate)
func sve_mem_cst_si(msz, size, imm4, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_cst_si: invalid msz")
    }
    if size &^ 0b11 != 0 {
        panic("sve_mem_cst_si: invalid size")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_mem_cst_si: invalid imm4")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cst_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cst_si: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cst_si: invalid Zt")
    }
    ret := uint32(0xe400e000)
    ret |= msz << 23
    ret |= size << 21
    ret |= imm4 << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cst_ss: SVE contiguous store (scalar plus scalar)
func sve_mem_cst_ss(opc, o2, Rm, Pg, Rn, Zt uint32) Instruction {
    if opc &^ 0b111 != 0 {
        panic("sve_mem_cst_ss: invalid opc")
    }
    if o2 &^ 0b1 != 0 {
        panic("sve_mem_cst_ss: invalid o2")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_cst_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cst_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cst_ss: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cst_ss: invalid Zt")
    }
    ret := uint32(0xe4004000)
    ret |= opc << 22
    ret |= o2 << 21
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cstnt_si: SVE contiguous non-temporal store (scalar plus immediate)
func sve_mem_cstnt_si(msz, imm4, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_cstnt_si: invalid msz")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_mem_cstnt_si: invalid imm4")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cstnt_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cstnt_si: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cstnt_si: invalid Zt")
    }
    ret := uint32(0xe410e000)
    ret |= msz << 23
    ret |= imm4 << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_cstnt_ss: SVE contiguous non-temporal store (scalar plus scalar)
func sve_mem_cstnt_ss(msz, Rm, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_cstnt_ss: invalid msz")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_cstnt_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_cstnt_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_cstnt_ss: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_cstnt_ss: invalid Zt")
    }
    ret := uint32(0xe4006000)
    ret |= msz << 23
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_eld_si: SVE load multiple structures (scalar plus immediate)
func sve_mem_eld_si(msz, opc, imm4, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_eld_si: invalid msz")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_mem_eld_si: invalid opc")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_mem_eld_si: invalid imm4")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_eld_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_eld_si: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_eld_si: invalid Zt")
    }
    ret := uint32(0xa400e000)
    ret |= msz << 23
    ret |= opc << 21
    ret |= imm4 << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_eld_ss: SVE load multiple structures (scalar plus scalar)
func sve_mem_eld_ss(msz, opc, Rm, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_eld_ss: invalid msz")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_mem_eld_ss: invalid opc")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_eld_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_eld_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_eld_ss: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_eld_ss: invalid Zt")
    }
    ret := uint32(0xa400c000)
    ret |= msz << 23
    ret |= opc << 21
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_est_si: SVE store multiple structures (scalar plus immediate)
func sve_mem_est_si(msz, opc, imm4, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_est_si: invalid msz")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_mem_est_si: invalid opc")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_mem_est_si: invalid imm4")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_est_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_est_si: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_est_si: invalid Zt")
    }
    ret := uint32(0xe410e000)
    ret |= msz << 23
    ret |= opc << 21
    ret |= imm4 << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_est_ss: SVE store multiple structures (scalar plus scalar)
func sve_mem_est_ss(msz, opc, Rm, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_est_ss: invalid msz")
    }
    if opc &^ 0b11 != 0 {
        panic("sve_mem_est_ss: invalid opc")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_est_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_est_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_est_ss: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_est_ss: invalid Zt")
    }
    ret := uint32(0xe4006000)
    ret |= msz << 23
    ret |= opc << 21
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_ld_dup: SVE load and broadcast element
func sve_mem_ld_dup(dtypeh, imm6, dtypel, Pg, Rn, Zt uint32) Instruction {
    if dtypeh &^ 0b11 != 0 {
        panic("sve_mem_ld_dup: invalid dtypeh")
    }
    if imm6 &^ 0b111111 != 0 {
        panic("sve_mem_ld_dup: invalid imm6")
    }
    if dtypel &^ 0b11 != 0 {
        panic("sve_mem_ld_dup: invalid dtypel")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_ld_dup: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_ld_dup: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_ld_dup: invalid Zt")
    }
    ret := uint32(0x84408000)
    ret |= dtypeh << 23
    ret |= imm6 << 16
    ret |= dtypel << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_ldqr_si: SVE load and broadcast quadword (scalar plus immediate)
func sve_mem_ldqr_si(msz, ssz, imm4, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_ldqr_si: invalid msz")
    }
    if ssz &^ 0b11 != 0 {
        panic("sve_mem_ldqr_si: invalid ssz")
    }
    if imm4 &^ 0b1111 != 0 {
        panic("sve_mem_ldqr_si: invalid imm4")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_ldqr_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_ldqr_si: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_ldqr_si: invalid Zt")
    }
    ret := uint32(0xa4002000)
    ret |= msz << 23
    ret |= ssz << 21
    ret |= imm4 << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_ldqr_ss: SVE load and broadcast quadword (scalar plus scalar)
func sve_mem_ldqr_ss(msz, ssz, Rm, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_ldqr_ss: invalid msz")
    }
    if ssz &^ 0b11 != 0 {
        panic("sve_mem_ldqr_ss: invalid ssz")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_ldqr_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_ldqr_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_ldqr_ss: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_ldqr_ss: invalid Zt")
    }
    ret := uint32(0xa4000000)
    ret |= msz << 23
    ret |= ssz << 21
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_prfm_si: SVE contiguous prefetch (scalar plus immediate)
func sve_mem_prfm_si(imm6, msz, Pg, Rn, prfop uint32) Instruction {
    if imm6 &^ 0b111111 != 0 {
        panic("sve_mem_prfm_si: invalid imm6")
    }
    if msz &^ 0b11 != 0 {
        panic("sve_mem_prfm_si: invalid msz")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_prfm_si: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_prfm_si: invalid Rn")
    }
    if prfop &^ 0b1111 != 0 {
        panic("sve_mem_prfm_si: invalid prfop")
    }
    ret := uint32(0x85c00000)
    ret |= imm6 << 16
    ret |= msz << 13
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= prfop
    return Instruction(ret);
}

// sve_mem_prfm_ss: SVE contiguous prefetch (scalar plus scalar)
func sve_mem_prfm_ss(msz, Rm, Pg, Rn, prfop uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_prfm_ss: invalid msz")
    }
    if Rm &^ 0b11111 != 0 {
        panic("sve_mem_prfm_ss: invalid Rm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_prfm_ss: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_prfm_ss: invalid Rn")
    }
    if prfop &^ 0b1111 != 0 {
        panic("sve_mem_prfm_ss: invalid prfop")
    }
    ret := uint32(0x8400c000)
    ret |= msz << 23
    ret |= Rm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= prfop
    return Instruction(ret);
}

// sve_mem_pspill: SVE store predicate register
func sve_mem_pspill(imm9h, imm9l, Rn, Pt uint32) Instruction {
    if imm9h &^ 0b111111 != 0 {
        panic("sve_mem_pspill: invalid imm9h")
    }
    if imm9l &^ 0b111 != 0 {
        panic("sve_mem_pspill: invalid imm9l")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_pspill: invalid Rn")
    }
    if Pt &^ 0b1111 != 0 {
        panic("sve_mem_pspill: invalid Pt")
    }
    ret := uint32(0xe5800000)
    ret |= imm9h << 16
    ret |= imm9l << 10
    ret |= Rn << 5
    ret |= Pt
    return Instruction(ret);
}

// sve_mem_spill: SVE store vector register
func sve_mem_spill(imm9h, imm9l, Rn, Zt uint32) Instruction {
    if imm9h &^ 0b111111 != 0 {
        panic("sve_mem_spill: invalid imm9h")
    }
    if imm9l &^ 0b111 != 0 {
        panic("sve_mem_spill: invalid imm9l")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_spill: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_spill: invalid Zt")
    }
    ret := uint32(0xe5804000)
    ret |= imm9h << 16
    ret |= imm9l << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_sst_sv2: SVE 64-bit scatter store (scalar plus 64-bit scaled offsets)
func sve_mem_sst_sv2(msz, Zm, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_sst_sv2: invalid msz")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv2: invalid Zm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_sst_sv2: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv2: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv2: invalid Zt")
    }
    ret := uint32(0xe420a000)
    ret |= msz << 23
    ret |= Zm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_sst_sv_a: SVE 64-bit scatter store (scalar plus unpacked 32-bit scaled offsets)
func sve_mem_sst_sv_a(msz, Zm, xs, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_sst_sv_a: invalid msz")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv_a: invalid Zm")
    }
    if xs &^ 0b1 != 0 {
        panic("sve_mem_sst_sv_a: invalid xs")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_sst_sv_a: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv_a: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv_a: invalid Zt")
    }
    ret := uint32(0xe4208000)
    ret |= msz << 23
    ret |= Zm << 16
    ret |= xs << 14
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_sst_sv_b: SVE 32-bit scatter store (scalar plus 32-bit scaled offsets)
func sve_mem_sst_sv_b(msz, Zm, xs, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_sst_sv_b: invalid msz")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv_b: invalid Zm")
    }
    if xs &^ 0b1 != 0 {
        panic("sve_mem_sst_sv_b: invalid xs")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_sst_sv_b: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv_b: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_sst_sv_b: invalid Zt")
    }
    ret := uint32(0xe4608000)
    ret |= msz << 23
    ret |= Zm << 16
    ret |= xs << 14
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_sst_vi_a: SVE 64-bit scatter store (vector plus immediate)
func sve_mem_sst_vi_a(msz, imm5, Pg, Zn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_sst_vi_a: invalid msz")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_mem_sst_vi_a: invalid imm5")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_sst_vi_a: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_mem_sst_vi_a: invalid Zn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_sst_vi_a: invalid Zt")
    }
    ret := uint32(0xe440a000)
    ret |= msz << 23
    ret |= imm5 << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_sst_vi_b: SVE 32-bit scatter store (vector plus immediate)
func sve_mem_sst_vi_b(msz, imm5, Pg, Zn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_sst_vi_b: invalid msz")
    }
    if imm5 &^ 0b11111 != 0 {
        panic("sve_mem_sst_vi_b: invalid imm5")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_sst_vi_b: invalid Pg")
    }
    if Zn &^ 0b11111 != 0 {
        panic("sve_mem_sst_vi_b: invalid Zn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_sst_vi_b: invalid Zt")
    }
    ret := uint32(0xe460a000)
    ret |= msz << 23
    ret |= imm5 << 16
    ret |= Pg << 10
    ret |= Zn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_sst_vs2: SVE 64-bit scatter store (scalar plus 64-bit unscaled offsets)
func sve_mem_sst_vs2(msz, Zm, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_sst_vs2: invalid msz")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs2: invalid Zm")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_sst_vs2: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs2: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs2: invalid Zt")
    }
    ret := uint32(0xe400a000)
    ret |= msz << 23
    ret |= Zm << 16
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_sst_vs_a: SVE 64-bit scatter store (scalar plus unpacked 32-bit unscaled offsets)
func sve_mem_sst_vs_a(msz, Zm, xs, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_sst_vs_a: invalid msz")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs_a: invalid Zm")
    }
    if xs &^ 0b1 != 0 {
        panic("sve_mem_sst_vs_a: invalid xs")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_sst_vs_a: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs_a: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs_a: invalid Zt")
    }
    ret := uint32(0xe4008000)
    ret |= msz << 23
    ret |= Zm << 16
    ret |= xs << 14
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// sve_mem_sst_vs_b: SVE 32-bit scatter store (scalar plus 32-bit unscaled offsets)
func sve_mem_sst_vs_b(msz, Zm, xs, Pg, Rn, Zt uint32) Instruction {
    if msz &^ 0b11 != 0 {
        panic("sve_mem_sst_vs_b: invalid msz")
    }
    if Zm &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs_b: invalid Zm")
    }
    if xs &^ 0b1 != 0 {
        panic("sve_mem_sst_vs_b: invalid xs")
    }
    if Pg &^ 0b111 != 0 {
        panic("sve_mem_sst_vs_b: invalid Pg")
    }
    if Rn &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs_b: invalid Rn")
    }
    if Zt &^ 0b11111 != 0 {
        panic("sve_mem_sst_vs_b: invalid Zt")
    }
    ret := uint32(0xe4408000)
    ret |= msz << 23
    ret |= Zm << 16
    ret |= xs << 14
    ret |= Pg << 10
    ret |= Rn << 5
    ret |= Zt
    return Instruction(ret);
}

// systeminstrs: System instructions
func systeminstrs(L, op1, CRn, CRm, op2, Rt uint32) Instruction {
    if L &^ 0b1 != 0 {
        panic("systeminstrs: invalid L")
    }
    if op1 &^ 0b111 != 0 {
        panic("systeminstrs: invalid op1")
    }
    if CRn &^ 0b1111 != 0 {
        panic("systeminstrs: invalid CRn")
    }
    if CRm &^ 0b1111 != 0 {
        panic("systeminstrs: invalid CRm")
    }
    if op2 &^ 0b111 != 0 {
        panic("systeminstrs: invalid op2")
    }
    if Rt &^ 0b11111 != 0 {
        panic("systeminstrs: invalid Rt")
    }
    ret := uint32(0xd5080000)
    ret |= L << 21
    ret |= op1 << 16
    ret |= CRn << 12
    ret |= CRm << 8
    ret |= op2 << 5
    ret |= Rt
    return Instruction(ret);
}

// systemmove: System register move
func systemmove(L, o0, op1, CRn, CRm, op2, Rt uint32) Instruction {
    if L &^ 0b1 != 0 {
        panic("systemmove: invalid L")
    }
    if o0 &^ 0b1 != 0 {
        panic("systemmove: invalid o0")
    }
    if op1 &^ 0b111 != 0 {
        panic("systemmove: invalid op1")
    }
    if CRn &^ 0b1111 != 0 {
        panic("systemmove: invalid CRn")
    }
    if CRm &^ 0b1111 != 0 {
        panic("systemmove: invalid CRm")
    }
    if op2 &^ 0b111 != 0 {
        panic("systemmove: invalid op2")
    }
    if Rt &^ 0b11111 != 0 {
        panic("systemmove: invalid Rt")
    }
    ret := uint32(0xd5100000)
    ret |= L << 21
    ret |= o0 << 19
    ret |= op1 << 16
    ret |= CRn << 12
    ret |= CRm << 8
    ret |= op2 << 5
    ret |= Rt
    return Instruction(ret);
}

// testbranch: Test and branch (immediate)
func testbranch(b5, op, b40, imm14, Rt uint32) Instruction {
    if b5 &^ 0b1 != 0 {
        panic("testbranch: invalid b5")
    }
    if op &^ 0b1 != 0 {
        panic("testbranch: invalid op")
    }
    if b40 &^ 0b11111 != 0 {
        panic("testbranch: invalid b40")
    }
    if imm14 &^ 0b11111111111111 != 0 {
        panic("testbranch: invalid imm14")
    }
    if Rt &^ 0b11111 != 0 {
        panic("testbranch: invalid Rt")
    }
    ret := uint32(0x36000000)
    ret |= b5 << 31
    ret |= op << 24
    ret |= b40 << 19
    ret |= imm14 << 5
    ret |= Rt
    return Instruction(ret);
}
