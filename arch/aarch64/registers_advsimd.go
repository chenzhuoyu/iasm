// Code generated by "mkasm_aarch64.py", DO NOT EDIT.

package aarch64

import (
    `fmt`
)

// SIMDRegister represents an Advanced SIMD hardware register.
type SIMDRegister interface {
    Register
    Bits() uint8
}

type (
    SIMDRegister8    uint8
    SIMDRegister16   uint8
    SIMDRegister32   uint8
    SIMDRegister64   uint8
    SIMDRegister128  uint8
    SIMDRegister128u uint8
    SIMDRegister128v uint8
)

func (SIMDRegister8)    Bits() uint8 { return 8 }
func (SIMDRegister16)   Bits() uint8 { return 16 }
func (SIMDRegister32)   Bits() uint8 { return 32 }
func (SIMDRegister64)   Bits() uint8 { return 64 }
func (SIMDRegister128)  Bits() uint8 { return 128 }
func (SIMDRegister128v) Bits() uint8 { return 128 }

func (self SIMDRegister8)    ID() uint8 { return uint8(self) & 0b11111 }
func (self SIMDRegister16)   ID() uint8 { return uint8(self) & 0b11111 }
func (self SIMDRegister32)   ID() uint8 { return uint8(self) & 0b11111 }
func (self SIMDRegister64)   ID() uint8 { return uint8(self) & 0b11111 }
func (self SIMDRegister128)  ID() uint8 { return uint8(self) & 0b11111 }
func (self SIMDRegister128v) ID() uint8 { return uint8(self) & 0b11111 }

func (self SIMDRegister8)    String() string { return fmt.Sprintf("b%d", self.ID()) }
func (self SIMDRegister16)   String() string { return fmt.Sprintf("h%d", self.ID()) }
func (self SIMDRegister32)   String() string { return fmt.Sprintf("s%d", self.ID()) }
func (self SIMDRegister64)   String() string { return fmt.Sprintf("d%d", self.ID()) }
func (self SIMDRegister128)  String() string { return fmt.Sprintf("q%d", self.ID()) }
func (self SIMDRegister128u) String() string { return fmt.Sprintf("v%d", self) }
func (self SIMDRegister128v) String() string { return fmt.Sprintf("v%d.%s", self.ID(), self.Arrangement()) }

// SIMDVectorArrangement represents the data arrangement of a V register.
type SIMDVectorArrangement uint8

const (
    Vec8B  SIMDVectorArrangement = 0b000
    Vec16B SIMDVectorArrangement = 0b001
    Vec4H  SIMDVectorArrangement = 0b010
    Vec8H  SIMDVectorArrangement = 0b011
    Vec2S  SIMDVectorArrangement = 0b100
    Vec4S  SIMDVectorArrangement = 0b101
    Vec1D  SIMDVectorArrangement = 0b110
    Vec2D  SIMDVectorArrangement = 0b111
)

// SIMDVectorArrangements maps the arrangement name to the actual value.
var SIMDVectorArrangements = map[string]SIMDVectorArrangement {
    "8b"  : Vec8B,
    "16b" : Vec16B,
    "4h"  : Vec4H,
    "8h"  : Vec8H,
    "2s"  : Vec2S,
    "4s"  : Vec4S,
    "1d"  : Vec1D,
    "2d"  : Vec2D,
}

func (self SIMDVectorArrangement) q()    uint8 { return uint8(self & 1)  }
func (self SIMDVectorArrangement) size() uint8 { return uint8(self >> 1) }
func (self SIMDVectorArrangement) imm5() uint8 { return 1 << self.size() }

func (self SIMDVectorArrangement) String() string {
    switch self {
        case Vec8B  : return "8b"
        case Vec16B : return "16b"
        case Vec4H  : return "4h"
        case Vec8H  : return "8h"
        case Vec2S  : return "2s"
        case Vec4S  : return "4s"
        case Vec1D  : return "1d"
        case Vec2D  : return "2d"
        default     : panic("aarch64: invalid SIMD vector arrangement")
    }
}

func (self SIMDRegister128u) B(n byte) SIMDRegister128v {
    switch n {
        case 8  : return self.As(Vec8B)
        case 16 : return self.As(Vec16B)
        default : panic("aarch64: invalid element count for unit size B")
    }
}

func (self SIMDRegister128u) H(n byte) SIMDRegister128v {
    switch n {
        case 4  : return self.As(Vec4H)
        case 8  : return self.As(Vec8H)
        default : panic("aarch64: invalid element count for unit size H")
    }
}

func (self SIMDRegister128u) S(n byte) SIMDRegister128v {
    switch n {
        case 2  : return self.As(Vec2S)
        case 4  : return self.As(Vec4S)
        default : panic("aarch64: invalid element count for unit size S")
    }
}

func (self SIMDRegister128u) D(n byte) SIMDRegister128v {
    switch n {
        case 1  : return self.As(Vec1D)
        case 2  : return self.As(Vec2D)
        default : panic("aarch64: invalid element count for unit size D")
    }
}

func (self SIMDRegister128u) As(v SIMDVectorArrangement) SIMDRegister128v {
    if self &^ 0b11111 != 0 {
        panic("aarch64: invalid unarranged vector register")
    } else {
        return SIMDRegister128v(uint8(v) << 5 | uint8(self))
    }
}

func (self SIMDRegister128v) Arrangement() SIMDVectorArrangement {
    return SIMDVectorArrangement(self >> 5)
}

const (
    B0 SIMDRegister8 = iota
    B1
    B2
    B3
    B4
    B5
    B6
    B7
    B8
    B9
    B10
    B11
    B12
    B13
    B14
    B15
    B16
    B17
    B18
    B19
    B20
    B21
    B22
    B23
    B24
    B25
    B26
    B27
    B28
    B29
    B30
    B31
)

const (
    H0 SIMDRegister16 = iota
    H1
    H2
    H3
    H4
    H5
    H6
    H7
    H8
    H9
    H10
    H11
    H12
    H13
    H14
    H15
    H16
    H17
    H18
    H19
    H20
    H21
    H22
    H23
    H24
    H25
    H26
    H27
    H28
    H29
    H30
    H31
)

const (
    S0 SIMDRegister32 = iota
    S1
    S2
    S3
    S4
    S5
    S6
    S7
    S8
    S9
    S10
    S11
    S12
    S13
    S14
    S15
    S16
    S17
    S18
    S19
    S20
    S21
    S22
    S23
    S24
    S25
    S26
    S27
    S28
    S29
    S30
    S31
)

const (
    D0 SIMDRegister64 = iota
    D1
    D2
    D3
    D4
    D5
    D6
    D7
    D8
    D9
    D10
    D11
    D12
    D13
    D14
    D15
    D16
    D17
    D18
    D19
    D20
    D21
    D22
    D23
    D24
    D25
    D26
    D27
    D28
    D29
    D30
    D31
)

const (
    Q0 SIMDRegister128 = iota
    Q1
    Q2
    Q3
    Q4
    Q5
    Q6
    Q7
    Q8
    Q9
    Q10
    Q11
    Q12
    Q13
    Q14
    Q15
    Q16
    Q17
    Q18
    Q19
    Q20
    Q21
    Q22
    Q23
    Q24
    Q25
    Q26
    Q27
    Q28
    Q29
    Q30
    Q31
)

const (
    V0 SIMDRegister128u = iota
    V1
    V2
    V3
    V4
    V5
    V6
    V7
    V8
    V9
    V10
    V11
    V12
    V13
    V14
    V15
    V16
    V17
    V18
    V19
    V20
    V21
    V22
    V23
    V24
    V25
    V26
    V27
    V28
    V29
    V30
    V31
)
