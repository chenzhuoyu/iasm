<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>GCSSTTR -- A64</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">GCSSTTR</h2><p class="aml">Guarded Control Stack unprivileged Store stores a doubleword from a register to memory. The address that is used for the store is calculated from a base register.</p><p class="aml">Memory accesses made by the instruction behave as if the instruction was executed at EL0 if the <a class="armarm-xref" title="Reference to Armv8 ARM section">Effective value</a> of PSTATE.UAO is 0 and either:</p><ul><li>The instruction is executed at EL1 and <a class="armarm-xref" title="Reference to Armv8 ARM section">HCR_EL2</a>.{NV, NV1} is not {1, 1}.</li><li>The instruction is executed at EL2 when the <a class="armarm-xref" title="Reference to Armv8 ARM section">Effective value</a> of <a class="armarm-xref" title="Reference to Armv8 ARM section">HCR_EL2</a>.{E2H, TGE} is {1, 1}.</li></ul><p class="aml">Otherwise, the memory access operates with the restrictions determined by the Exception level at which the instruction is executed.</p><h3 class="classheading"><a id="iclass_general"/>Integer<span style="font-size:smaller;"><br/>(FEAT_GCS)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>1</td><td class="r">1</td><td class="lr">0</td><td class="l">0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="r">0</td><td class="l">0</td><td>0</td><td class="r">1</td><td class="l">1</td><td class="r">1</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Rt</td></tr><tr class="secondrow"><td colspan="5"/><td/><td colspan="11"/><td class="droppedname" colspan="3">opc</td><td colspan="2"/><td colspan="5"/><td colspan="5"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="GCSSTTR_64_ldst_gcs"/><p class="asm-code">GCSSTTR  <a href="#sa_xt" title="64-bit general-purpose register to be transferred (field &quot;Rt&quot;)">&lt;Xt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-shared.HaveGCS.0" title="function: boolean HaveGCS()">HaveGCS</a>() then UNDEFINED;
bits(2) effective_el;
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rt);
<del>boolean is_gcssttr = (opc == '001');
</del>
<ins>boolean privileged;
case PSTATE.EL of
    when</ins><del>if is_gcssttr then
    boolean privileged;
    case PSTATE.EL of
        when</del> <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a> privileged = FALSE;
    when <a href="shared_pseudocode.html#EL1" title="constant bits(2) EL1 = '01'">EL1</a> privileged = <a href="shared_pseudocode.html#impl-shared.EL2Enabled.0" title="function: boolean EL2Enabled()">EL2Enabled</a>() &amp;&amp; <a href="shared_pseudocode.html#impl-shared.HaveNVExt.0" title="function: boolean HaveNVExt()">HaveNVExt</a>() &amp;&amp; HCR_EL2.&lt;NV,NV1> == '11';
    when <a href="shared_pseudocode.html#EL2" title="constant bits(2) EL2 = '10'">EL2</a> privileged = !(<a href="shared_pseudocode.html#impl-shared.HaveVirtHostExt.0" title="function: boolean HaveVirtHostExt()">HaveVirtHostExt</a>() &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11');
    when <a href="shared_pseudocode.html#EL3" title="constant bits(2) EL3 = '11'">EL3</a> privileged = TRUE;
if <a href="shared_pseudocode.html#impl-shared.HaveUAOExt.0" title="function: boolean HaveUAOExt()">HaveUAOExt</a>() &amp;&amp; PSTATE.UAO == '1' then
    privileged = PSTATE.EL != <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a>;
if privileged then
    effective_el = PSTATE.EL;
else
    effective_el = <a href="shared_pseudocode.html#EL0" title="constant bits(2) EL0 = '00'">EL0</a><ins>;</ins><del>;
else
    effective_el = PSTATE.EL;</del></p><div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xt></td><td><a id="sa_xt"/><p class="aml">Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Rt" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xn|SP></td><td><a id="sa_xn_sp"/><p class="aml">Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.</p></td></tr></table></div><div class="syntax-notes"/><div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3><p class="pseudocode">bits(64) address;
bits(64) data;

if effective_el == PSTATE.EL then
    <a href="shared_pseudocode.html#impl-aarch64.CheckGCSSTRTrap.0" title="function: CheckGCSSTRTrap()">CheckGCSSTRTrap</a>();

<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescGCS.2" title="function: AccessDescriptor CreateAccDescGCS(bits(2) el, MemOp memop)">CreateAccDescGCS</a>(effective_el, <a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>);

if n == 31 then
    <a href="shared_pseudocode.html#impl-aarch64.CheckSPAlignment.0" title="function: CheckSPAlignment()">CheckSPAlignment</a>();
    address = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(64) SP[]">SP</a>[];
else
    address = <a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[n, 64];

data = <a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[t, 64];
Mem[address, 8, accdesc] = data;</p></div><hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.59, AdvSIMD v29.12, pseudocode v2022-12_rel, sve v2022-12_relb
      ; Build timestamp: <ins>2022-12-14T23</ins><del>2022-12-14T22</del>:<ins>21</ins><del>29</del>
    </p><p class="copyconf">
      Copyright Â© 2010-2022 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>