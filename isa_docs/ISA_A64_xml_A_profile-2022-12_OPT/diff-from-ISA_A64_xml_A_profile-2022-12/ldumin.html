<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>LDUMIN, LDUMINA, LDUMINAL, LDUMINL -- A64</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">LDUMIN, LDUMINA, LDUMINAL, LDUMINL</h2><p class="aml">Atomic unsigned minimum on word or doubleword in memory atomically loads a 32-bit word or 64-bit doubleword from memory, compares it against the value held in a register, and stores the smaller value back to memory, treating the values as unsigned numbers. The value initially loaded from memory is returned in the destination register.</p><ul><li>If the destination register is not one of WZR or XZR, <span class="asm-code">LDUMINA</span> and <span class="asm-code">LDUMINAL</span> load from memory with acquire semantics.</li><li><span class="asm-code">LDUMINL</span> and <span class="asm-code">LDUMINAL</span> store to memory with release semantics.</li><li><span class="asm-code">LDUMIN</span> has neither acquire nor release semantics.</li></ul><p class="aml">For more information about memory ordering semantics see <a class="armarm-xref" title="Reference to Armv8 ARM section">Load-Acquire, Store-Release</a>.</p><p class="aml">For information about memory accesses see <a class="armarm-xref" title="Reference to Armv8 ARM section">Load/Store addressing modes</a>.</p><p class="desc">This instruction is used by the alias <a href="stumin_ldumin.html" title="Atomic unsigned minimum on word or doubleword in memory">STUMIN, STUMINL</a>.</p><h3 class="classheading"><a id="iclass_general"/>Integer<span style="font-size:smaller;"><br/>(FEAT_LSE)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td class="r">x</td><td class="l">1</td><td>1</td><td class="r">1</td><td class="lr">0</td><td class="l">0</td><td class="r">0</td><td class="lr">A</td><td class="lr">R</td><td class="lr">1</td><td class="lr" colspan="5">Rs</td><td class="lr">0</td><td class="l">1</td><td>1</td><td class="r">1</td><td class="l">0</td><td class="r">0</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Rt</td></tr><tr class="secondrow"><td class="droppedname" colspan="2">size</td><td colspan="3"/><td/><td colspan="2"/><td/><td/><td/><td colspan="5"/><td/><td class="droppedname" colspan="3">opc</td><td colspan="2"/><td colspan="5"/><td colspan="5"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding">32-bit LDUMIN<span class="bitdiff"> (size == 10 &amp;&amp; A == 0 &amp;&amp; R == 0)</span></h4><a id="LDUMIN_32_memop"/><p class="asm-code">LDUMIN  <a href="#sa_ws" title="32-bit general-purpose register holding data value to be operated on with the contents of memory location (field &quot;Rs&quot;)">&lt;Ws></a>, <a href="#sa_wt" title="32-bit general-purpose register to be loaded (field &quot;Rt&quot;)">&lt;Wt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><div class="encoding"><h4 class="encoding">32-bit LDUMINA<span class="bitdiff"> (size == 10 &amp;&amp; A == 1 &amp;&amp; R == 0)</span></h4><a id="LDUMINA_32_memop"/><p class="asm-code">LDUMINA  <a href="#sa_ws" title="32-bit general-purpose register holding data value to be operated on with the contents of memory location (field &quot;Rs&quot;)">&lt;Ws></a>, <a href="#sa_wt" title="32-bit general-purpose register to be loaded (field &quot;Rt&quot;)">&lt;Wt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><div class="encoding"><h4 class="encoding">32-bit LDUMINAL<span class="bitdiff"> (size == 10 &amp;&amp; A == 1 &amp;&amp; R == 1)</span></h4><a id="LDUMINAL_32_memop"/><p class="asm-code">LDUMINAL  <a href="#sa_ws" title="32-bit general-purpose register holding data value to be operated on with the contents of memory location (field &quot;Rs&quot;)">&lt;Ws></a>, <a href="#sa_wt" title="32-bit general-purpose register to be loaded (field &quot;Rt&quot;)">&lt;Wt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><div class="encoding"><h4 class="encoding">32-bit LDUMINL<span class="bitdiff"> (size == 10 &amp;&amp; A == 0 &amp;&amp; R == 1)</span></h4><a id="LDUMINL_32_memop"/><p class="asm-code">LDUMINL  <a href="#sa_ws" title="32-bit general-purpose register holding data value to be operated on with the contents of memory location (field &quot;Rs&quot;)">&lt;Ws></a>, <a href="#sa_wt" title="32-bit general-purpose register to be loaded (field &quot;Rt&quot;)">&lt;Wt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><div class="encoding"><h4 class="encoding">64-bit LDUMIN<span class="bitdiff"> (size == 11 &amp;&amp; A == 0 &amp;&amp; R == 0)</span></h4><a id="LDUMIN_64_memop"/><p class="asm-code">LDUMIN  <a href="#sa_xs" title="64-bit general-purpose register holding data value to be operated on with the contents of memory location (field &quot;Rs&quot;)">&lt;Xs></a>, <a href="#sa_xt" title="64-bit general-purpose register to be loaded (field &quot;Rt&quot;)">&lt;Xt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><div class="encoding"><h4 class="encoding">64-bit LDUMINA<span class="bitdiff"> (size == 11 &amp;&amp; A == 1 &amp;&amp; R == 0)</span></h4><a id="LDUMINA_64_memop"/><p class="asm-code">LDUMINA  <a href="#sa_xs" title="64-bit general-purpose register holding data value to be operated on with the contents of memory location (field &quot;Rs&quot;)">&lt;Xs></a>, <a href="#sa_xt" title="64-bit general-purpose register to be loaded (field &quot;Rt&quot;)">&lt;Xt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><div class="encoding"><h4 class="encoding">64-bit LDUMINAL<span class="bitdiff"> (size == 11 &amp;&amp; A == 1 &amp;&amp; R == 1)</span></h4><a id="LDUMINAL_64_memop"/><p class="asm-code">LDUMINAL  <a href="#sa_xs" title="64-bit general-purpose register holding data value to be operated on with the contents of memory location (field &quot;Rs&quot;)">&lt;Xs></a>, <a href="#sa_xt" title="64-bit general-purpose register to be loaded (field &quot;Rt&quot;)">&lt;Xt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><div class="encoding"><h4 class="encoding">64-bit LDUMINL<span class="bitdiff"> (size == 11 &amp;&amp; A == 0 &amp;&amp; R == 1)</span></h4><a id="LDUMINL_64_memop"/><p class="asm-code">LDUMINL  <a href="#sa_xs" title="64-bit general-purpose register holding data value to be operated on with the contents of memory location (field &quot;Rs&quot;)">&lt;Xs></a>, <a href="#sa_xt" title="64-bit general-purpose register to be loaded (field &quot;Rt&quot;)">&lt;Xt></a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP></a>]</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-shared.HaveAtomicExt.0" title="function: boolean HaveAtomicExt()">HaveAtomicExt</a>() then UNDEFINED;

integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer s = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rs);

integer datasize = 8 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);
integer regsize = if datasize == 64 then 64 else 32;
boolean acquire = A == '1' &amp;&amp; Rt != '11111';
<ins>boolean release = R == '1';
boolean tagchecked = n != 31;</ins><del>boolean release = R == '1';</del><a href="shared_pseudocode.html#MemAtomicOp" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp</del></a><del> op;
case opc of
    when '000' op = </del><a href="shared_pseudocode.html#MemAtomicOp_ADD" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp_ADD</del></a><del>;
    when '001' op = </del><a href="shared_pseudocode.html#MemAtomicOp_BIC" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp_BIC</del></a><del>;
    when '010' op = </del><a href="shared_pseudocode.html#MemAtomicOp_EOR" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp_EOR</del></a><del>;
    when '011' op = </del><a href="shared_pseudocode.html#MemAtomicOp_ORR" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp_ORR</del></a><del>;
    when '100' op = </del><a href="shared_pseudocode.html#MemAtomicOp_SMAX" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp_SMAX</del></a><del>;
    when '101' op = </del><a href="shared_pseudocode.html#MemAtomicOp_SMIN" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp_SMIN</del></a><del>;
    when '110' op = </del><a href="shared_pseudocode.html#MemAtomicOp_UMAX" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp_UMAX</del></a><del>;
    when '111' op = </del><a href="shared_pseudocode.html#MemAtomicOp_UMIN" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><del>MemAtomicOp_UMIN</del></a><del>;
boolean tagchecked = n != 31;</del></p><div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Ws></td><td><a id="sa_ws"/><p class="aml">Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the "Rs" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Wt></td><td><a id="sa_wt"/><p class="aml">Is the 32-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xs></td><td><a id="sa_xs"/><p class="aml">Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the "Rs" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xt></td><td><a id="sa_xt"/><p class="aml">Is the 64-bit name of the general-purpose register to be loaded, encoded in the "Rt" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xn|SP></td><td><a id="sa_xn_sp"/><p class="aml">Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.</p></td></tr></table></div><div class="syntax-notes"/><h3 class="aliastable" id="">Alias Conditions</h3><table class="aliastable"><thead><tr><th>Alias</th><th>Is preferred when</th></tr></thead><tbody><tr><td><a href="stumin_ldumin.html" title="Atomic unsigned minimum on word or doubleword in memory">STUMIN, STUMINL</a></td><td class="notfirst"><span class="pseudocode">A == '0' &amp;&amp; Rt == '11111'</span></td></tr></tbody></table><div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3><p class="pseudocode">bits(64) address;
bits(datasize) value;
bits(datasize) data;

<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescAtomicOp.4" title="function: AccessDescriptor CreateAccDescAtomicOp(MemAtomicOp modop, boolean acquire, boolean release, boolean tagchecked)">CreateAccDescAtomicOp</a><ins>(</ins><del>(op, acquire, release, tagchecked);

value =</del><a href="shared_pseudocode.html#MemAtomicOp_UMIN" title="enumeration MemAtomicOp { MemAtomicOp_GCSSS1, MemAtomicOp_ADD, MemAtomicOp_BIC, MemAtomicOp_EOR, MemAtomicOp_ORR, MemAtomicOp_SMAX, MemAtomicOp_SMIN, MemAtomicOp_UMAX, MemAtomicOp_UMIN, MemAtomicOp_SWP, MemAtomicOp_CAS }"><ins>MemAtomicOp_UMIN</ins></a><ins>, acquire, release, tagchecked);

value = </ins><a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[s, datasize];
if n == 31 then
    <a href="shared_pseudocode.html#impl-aarch64.CheckSPAlignment.0" title="function: CheckSPAlignment()">CheckSPAlignment</a>();
    address = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(64) SP[]">SP</a>[];
else
    address = <a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[n, 64];

bits(datasize) comparevalue = bits(datasize) UNKNOWN;    // Irrelevant when not executing CAS
data = <a href="shared_pseudocode.html#impl-aarch64.MemAtomic.4" title="function: bits(size) MemAtomic(bits(64) address, bits(size) cmpoperand, bits(size) operand, AccessDescriptor accdesc_in)">MemAtomic</a>(address, comparevalue, value, accdesc);

if t != 31 then
    <a href="shared_pseudocode.html#impl-aarch64.X.write.2" title="accessor: X[integer n, integer width] = bits(width) value">X</a>[t, regsize] = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(data, regsize);</p></div><h3>Operational information</h3><p class="aml">If PSTATE.DIT is 1, the timing of this instruction is insensitive to the value of the data being loaded or stored.</p><hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.59, AdvSIMD v29.12, pseudocode v2022-12_rel, sve v2022-12_relb
      ; Build timestamp: <ins>2022-12-14T23</ins><del>2022-12-14T22</del>:<ins>21</ins><del>29</del>
    </p><p class="copyconf">
      Copyright © 2010-2022 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>