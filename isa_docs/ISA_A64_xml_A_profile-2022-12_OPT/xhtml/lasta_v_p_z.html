<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>LASTA (SIMD&amp;FP scalar)</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">LASTA (SIMD&amp;FP scalar)</h2><p>Extract element after last to SIMD&amp;FP scalar register</p>
      <p class="aml">If there is an active element then extract the element after the last active element modulo the number of elements from the final source vector register. If there are no active elements, extract element zero. Then place the extracted element in the destination SIMD&amp;FP scalar register.</p>
    
    <p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td class="r">1</td><td colspan="2" class="lr">size</td><td class="l">1</td><td>0</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">0</td><td class="l">1</td><td>0</td><td class="r">0</td><td colspan="3" class="lr">Pg</td><td colspan="5" class="lr">Zn</td><td colspan="5" class="lr">Vd</td></tr><tr class="secondrow"><td colspan="8"/><td colspan="2"/><td colspan="5"/><td class="droppedname">B</td><td colspan="3"/><td colspan="3"/><td colspan="5"/><td colspan="5"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="lasta_v_p_z_"/><p class="asm-code">LASTA   <a href="#sa_v" title="Width specifier (field &quot;size&quot;) [B,D,H,S]">&lt;V&gt;</a><a href="#sa_d" title="Destination SIMD&amp;FP register number [0-31] (field &quot;Vd&quot;)">&lt;d&gt;</a>, <a href="#sa_pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg&gt;</a>, <a href="#sa_zn" title="Source scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a>.<a href="#sa_t" title="Size specifier (field &quot;size&quot;) [B,D,H,S]">&lt;T&gt;</a></p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSVE.0" title="function: boolean HaveSVE()">HaveSVE</a>() &amp;&amp; !<a href="shared_pseudocode.html#impl-aarch64.HaveSME.0" title="function: boolean HaveSME()">HaveSME</a>() then UNDEFINED;
constant integer esize = 8 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Vd);
boolean isBefore = FALSE;</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;V&gt;</td><td><a id="sa_v"/>
        <p>Is a width specifier, 
      encoded in
      <q>size</q>:
        </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">size</th>
                <th class="symbol">&lt;V&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">00</td>
                <td class="symbol">B</td>
              </tr>
              <tr>
                <td class="bitfield">01</td>
                <td class="symbol">H</td>
              </tr>
              <tr>
                <td class="bitfield">10</td>
                <td class="symbol">S</td>
              </tr>
              <tr>
                <td class="bitfield">11</td>
                <td class="symbol">D</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;d&gt;</td><td><a id="sa_d"/>
        
          <p class="aml">Is the number [0-31] of the destination SIMD&amp;FP register, encoded in the "Vd" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Pg&gt;</td><td><a id="sa_pg"/>
        
          <p class="aml">Is the name of the governing scalable predicate register P0-P7, encoded in the "Pg" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn&gt;</td><td><a id="sa_zn"/>
        
          <p class="aml">Is the name of the source scalable vector register, encoded in the "Zn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;T&gt;</td><td><a id="sa_t"/>
        <p>Is the size specifier, 
      encoded in
      <q>size</q>:
        </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">size</th>
                <th class="symbol">&lt;T&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">00</td>
                <td class="symbol">B</td>
              </tr>
              <tr>
                <td class="bitfield">01</td>
                <td class="symbol">H</td>
              </tr>
              <tr>
                <td class="bitfield">10</td>
                <td class="symbol">S</td>
              </tr>
              <tr>
                <td class="bitfield">11</td>
                <td class="symbol">D</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckSVEEnabled.0" title="function: CheckSVEEnabled()">CheckSVEEnabled</a>();
constant integer VL = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
constant integer PL = VL DIV 8;
constant integer elements = VL DIV esize;
bits(PL) mask = <a href="shared_pseudocode.html#impl-aarch64.P.read.2" title="accessor: bits(width) P[integer n, integer width]">P</a>[g, PL];
bits(VL) operand = <a href="shared_pseudocode.html#impl-aarch64.Z.read.2" title="accessor: bits(width) Z[integer n, integer width]">Z</a>[n, VL];
integer last = <a href="shared_pseudocode.html#impl-aarch64.LastActiveElement.2" title="function: integer LastActiveElement(bits(N) mask, integer esize)">LastActiveElement</a>(mask, esize);

if isBefore then
    if last &lt; 0 then last = elements - 1;
else
    last = last + 1;
    if last &gt;= elements then last = 0;
<a href="shared_pseudocode.html#impl-aarch64.V.write.2" title="accessor: V[integer n, integer width] = bits(width) value">V</a>[d, esize] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand, last, esize];</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.59, AdvSIMD v29.12, pseudocode v2022-12_rel, sve v2022-12_relb
      ; Build timestamp: 2022-12-14T23:21
    </p><p class="copyconf">
      Copyright Â© 2010-2022 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
