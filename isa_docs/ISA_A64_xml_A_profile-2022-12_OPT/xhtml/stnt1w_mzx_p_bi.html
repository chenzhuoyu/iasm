<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>STNT1W (scalar plus immediate, strided registers)</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">STNT1W (scalar plus immediate, strided registers)</h2><p>Contiguous store non-temporal of words from multiple strided vectors (immediate index)</p>
      <p class="aml">Contiguous store non-temporal of words from elements of two or four strided vector registers to the memory address generated by a 64-bit scalar base and immediate index which is multiplied by the vector's in-memory size, irrespective of predication, and added to the base address.</p>
      <p class="aml">Inactive elements are not written to memory.</p>
      <p class="aml">A non-temporal store is a hint to the system that this data is unlikely to be referenced again soon.</p>
    
    <p class="desc">
      It has encodings from 2 classes:
      <a href="#iclass_to_2reg">Two registers</a>
       and 
      <a href="#iclass_to_4reg">Four registers</a>
    </p>
    <h3 class="classheading"><a id="iclass_to_2reg"/>Two registers<span style="font-size:smaller;"><br/>(FEAT_SME2)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td class="r">0</td><td colspan="4" class="lr">imm4</td><td class="lr">0</td><td class="lr">1</td><td class="lr">0</td><td colspan="3" class="lr">PNg</td><td colspan="5" class="lr">Rn</td><td class="lr">T</td><td class="lr">1</td><td colspan="3" class="lr">Zt</td></tr><tr class="secondrow"><td colspan="12"/><td colspan="4"/><td/><td class="droppedname">msz&lt;1&gt;</td><td class="droppedname">msz&lt;0&gt;</td><td colspan="3"/><td colspan="5"/><td/><td class="droppedname">N</td><td colspan="3"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="stnt1w_mzx_p_bi_2x8"/><p class="asm-code">STNT1W  { <a href="#sa_zt1" title="First scalable vector register Z0-Z7 or Z16-Z23 to be transferred (field T:'0':Zt)">&lt;Zt1&gt;</a>.S, <a href="#sa_zt2" title="Second scalable vector register Z8-Z15 or Z24-Z31 to be transferred (field T:'1':Zt)">&lt;Zt2&gt;</a>.S }, <a href="#sa_png" title="Governing scalable predicate register PN8-PN15 (field &quot;PNg&quot;)">&lt;PNg&gt;</a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP&gt;</a>{, #<a href="#sa_imm" title="Optional signed immediate vector offset, multiple of 2 [-16-14], default 0 (field &quot;imm4&quot;)">&lt;imm&gt;</a>, MUL VL}]</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSME2.0" title="function: boolean HaveSME2()">HaveSME2</a>() then UNDEFINED;
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':PNg);
constant integer nreg = 2;
integer tstride = 8;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(T:'0':Zt);
constant integer esize = 32;
integer offset = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(imm4);</p>
    <h3 class="classheading"><a id="iclass_to_4reg"/>Four registers<span style="font-size:smaller;"><br/>(FEAT_SME2)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td class="r">0</td><td colspan="4" class="lr">imm4</td><td class="lr">1</td><td class="lr">1</td><td class="lr">0</td><td colspan="3" class="lr">PNg</td><td colspan="5" class="lr">Rn</td><td class="lr">T</td><td class="lr">1</td><td class="lr">0</td><td colspan="2" class="lr">Zt</td></tr><tr class="secondrow"><td colspan="12"/><td colspan="4"/><td/><td class="droppedname">msz&lt;1&gt;</td><td class="droppedname">msz&lt;0&gt;</td><td colspan="3"/><td colspan="5"/><td/><td class="droppedname">N</td><td/><td colspan="2"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="stnt1w_mzx_p_bi_4x4"/><p class="asm-code">STNT1W  { <a href="#sa_zt1_1" title="First scalable vector register Z0-Z3 or Z16-Z19 to be transferred (field T:'00':Zt)">&lt;Zt1&gt;</a>.S, <a href="#sa_zt2_1" title="Second scalable vector register Z4-Z7 or Z20-Z23 to be transferred (field T:'01':Zt)">&lt;Zt2&gt;</a>.S, <a href="#sa_zt3" title="Third scalable vector register Z8-Z11 or Z24-Z27 to be transferred (field T:'10':Zt)">&lt;Zt3&gt;</a>.S, <a href="#sa_zt4" title="Fourth scalable vector register Z12-Z15 or Z28-Z31 to be transferred (field T:'11':Zt)">&lt;Zt4&gt;</a>.S }, <a href="#sa_png" title="Governing scalable predicate register PN8-PN15 (field &quot;PNg&quot;)">&lt;PNg&gt;</a>, [<a href="#sa_xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP&gt;</a>{, #<a href="#sa_imm_1" title="Optional signed immediate vector offset, multiple of 4 [-32-28], default 0 (field &quot;imm4&quot;)">&lt;imm&gt;</a>, MUL VL}]</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSME2.0" title="function: boolean HaveSME2()">HaveSME2</a>() then UNDEFINED;
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('1':PNg);
constant integer nreg = 4;
integer tstride = 4;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(T:'00':Zt);
constant integer esize = 32;
integer offset = <a href="shared_pseudocode.html#impl-shared.SInt.1" title="function: integer SInt(bits(N) x)">SInt</a>(imm4);</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt1&gt;</td><td><a id="sa_zt1"/>
        
          
        
        
          <p class="aml">For the two registers variant: is the name of the first scalable vector register Z0-Z7 or Z16-Z23 to be transferred, encoded as "T:'0':Zt".</p>
        
      </td></tr><tr><td/><td><a id="sa_zt1_1"/>
        
          
        
        
          <p class="aml">For the four registers variant: is the name of the first scalable vector register Z0-Z3 or Z16-Z19 to be transferred, encoded as "T:'00':Zt".</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt2&gt;</td><td><a id="sa_zt2"/>
        
          
        
        
          <p class="aml">For the two registers variant: is the name of the second scalable vector register Z8-Z15 or Z24-Z31 to be transferred, encoded as "T:'1':Zt".</p>
        
      </td></tr><tr><td/><td><a id="sa_zt2_1"/>
        
          
        
        
          <p class="aml">For the four registers variant: is the name of the second scalable vector register Z4-Z7 or Z20-Z23 to be transferred, encoded as "T:'01':Zt".</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt3&gt;</td><td><a id="sa_zt3"/>
        
          <p class="aml">Is the name of the third scalable vector register Z8-Z11 or Z24-Z27 to be transferred, encoded as "T:'10':Zt".</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt4&gt;</td><td><a id="sa_zt4"/>
        
          <p class="aml">Is the name of the fourth scalable vector register Z12-Z15 or Z28-Z31 to be transferred, encoded as "T:'11':Zt".</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;PNg&gt;</td><td><a id="sa_png"/>
        
          <p class="aml">Is the name of the governing scalable predicate register PN8-PN15, with predicate-as-counter encoding, encoded in the "PNg" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xn|SP&gt;</td><td><a id="sa_xn_sp"/>
        
          <p class="aml">Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;imm&gt;</td><td><a id="sa_imm"/>
        
          
        
        
          <p class="aml">For the two registers variant: is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the "imm4" field.</p>
        
      </td></tr><tr><td/><td><a id="sa_imm_1"/>
        
          
        
        
          <p class="aml">For the four registers variant: is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the "imm4" field.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckStreamingSVEEnabled.0" title="function: CheckStreamingSVEEnabled()">CheckStreamingSVEEnabled</a>();
constant integer VL = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
constant integer PL = VL DIV 8;
constant integer elements = VL DIV esize;
constant integer mbytes = esize DIV 8;
bits(64) base;
bits(VL) src;
bits(PL) pred = <a href="shared_pseudocode.html#impl-aarch64.P.read.2" title="accessor: bits(width) P[integer n, integer width]">P</a>[g, PL];
bits(PL * nreg) mask = <a href="shared_pseudocode.html#impl-aarch64.CounterToPredicate.2" title="function: bits(width) CounterToPredicate(bits(16) pred, integer width)">CounterToPredicate</a>(pred&lt;15:0&gt;, PL * nreg);
boolean contiguous = TRUE;
boolean nontemporal = TRUE;
boolean tagchecked = n != 31;
<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescSVE.4" title="function: AccessDescriptor CreateAccDescSVE(MemOp memop, boolean nontemporal, boolean contiguous, boolean tagchecked)">CreateAccDescSVE</a>(<a href="shared_pseudocode.html#MemOp_STORE" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_STORE</a>, nontemporal, contiguous, tagchecked);

if !<a href="shared_pseudocode.html#impl-aarch64.AnyActiveElement.2" title="function: boolean AnyActiveElement(bits(N) mask, integer esize)">AnyActiveElement</a>(mask, esize) then
    if n == 31 &amp;&amp; <a href="shared_pseudocode.html#impl-shared.ConstrainUnpredictableBool.1" title="function: boolean ConstrainUnpredictableBool(Unpredictable which)">ConstrainUnpredictableBool</a>(<a href="shared_pseudocode.html#Unpredictable_CHECKSPNONEACTIVE" title="enumeration Unpredictable {  Unpredictable_VMSR,  Unpredictable_WBOVERLAPLD,  Unpredictable_WBOVERLAPST,  Unpredictable_LDPOVERLAP,  Unpredictable_BASEOVERLAP,  Unpredictable_DATAOVERLAP,  Unpredictable_DEVPAGE2,  Unpredictable_INSTRDEVICE,  Unpredictable_RESCPACR,  Unpredictable_RESMAIR,  Unpredictable_S1CTAGGED,  Unpredictable_S2RESMEMATTR,  Unpredictable_RESTEXCB,  Unpredictable_RESPRRR,  Unpredictable_RESDACR,  Unpredictable_RESVTCRS,  Unpredictable_RESTnSZ,  Unpredictable_RESTCF,  Unpredictable_DEVICETAGSTORE,  Unpredictable_OORTnSZ,  Unpredictable_LARGEIPA,  Unpredictable_ESRCONDPASS,  Unpredictable_ILZEROIT,  Unpredictable_ILZEROT,  Unpredictable_BPVECTORCATCHPRI,  Unpredictable_VCMATCHHALF,   Unpredictable_VCMATCHDAPA,  Unpredictable_WPMASKANDBAS,  Unpredictable_WPBASCONTIGUOUS,  Unpredictable_RESWPMASK,  Unpredictable_WPMASKEDBITS,  Unpredictable_RESBPWPCTRL,  Unpredictable_BPNOTIMPL,  Unpredictable_RESBPTYPE,  Unpredictable_BPNOTCTXCMP,  Unpredictable_BPMATCHHALF,  Unpredictable_BPMISMATCHHALF,  Unpredictable_RESTARTALIGNPC,  Unpredictable_RESTARTZEROUPPERPC,  Unpredictable_ZEROUPPER,   Unpredictable_ERETZEROUPPERPC,   Unpredictable_A32FORCEALIGNPC,  Unpredictable_SMD,  Unpredictable_NONFAULT,  Unpredictable_SVEZEROUPPER,  Unpredictable_SVELDNFDATA,  Unpredictable_SVELDNFZERO,  Unpredictable_CHECKSPNONEACTIVE,  Unpredictable_SMEZEROUPPER,  Unpredictable_NVNV1,  Unpredictable_Shareability,  Unpredictable_AFUPDATE,  Unpredictable_DBUPDATE,  Unpredictable_IESBinDebug,  Unpredictable_BADPMSFCR,  Unpredictable_ZEROBTYPE,  Unpredictable_EL2TIMESTAMP, Unpredictable_EL1TIMESTAMP,  Unpredictable_RESERVEDNSxB,  Unpredictable_WFxTDEBUG,  Unpredictable_LS64UNSUPPORTED,   Unpredictable_MISALIGNEDATOMIC,  Unpredictable_CLEARERRITEZERO,   Unpredictable_ALUEXCEPTIONRETURN,  Unpredictable_IGNORETRAPINDEBUG,  Unpredictable_DBGxVR_RESS,  Unpredictable_PMUEVENTCOUNTER,  Unpredictable_PMSCR_PCT,   Unpredictable_CounterReservedForEL2,  Unpredictable_BRBFILTRATE,   Unpredictable_MOPSOVERLAP31,  Unpredictable_STOREONLYTAGCHECKEDCAS,  Unpredictable_RESTC }">Unpredictable_CHECKSPNONEACTIVE</a>) then
        <a href="shared_pseudocode.html#impl-aarch64.CheckSPAlignment.0" title="function: CheckSPAlignment()">CheckSPAlignment</a>();
else
    if n == 31 then <a href="shared_pseudocode.html#impl-aarch64.CheckSPAlignment.0" title="function: CheckSPAlignment()">CheckSPAlignment</a>();
    base = if n == 31 then <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(64) SP[]">SP</a>[] else <a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[n, 64];

for r = 0 to nreg-1
    src = <a href="shared_pseudocode.html#impl-aarch64.Z.read.2" title="accessor: bits(width) Z[integer n, integer width]">Z</a>[t, VL];
    for e = 0 to elements-1
        if <a href="shared_pseudocode.html#impl-aarch64.ActivePredicateElement.3" title="function: boolean ActivePredicateElement(bits(N) pred, integer e, integer esize)">ActivePredicateElement</a>(mask, r * elements + e, esize) then
            bits(64) addr = base + (offset * nreg * elements + r * elements + e) * mbytes;
            Mem[addr, mbytes, accdesc] = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[src, e, esize];
    t = t + tstride;</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.59, AdvSIMD v29.12, pseudocode v2022-12_rel, sve v2022-12_relb
      ; Build timestamp: 2022-12-14T23:21
    </p><p class="copyconf">
      Copyright © 2010-2022 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
