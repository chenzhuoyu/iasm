<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>TRBSR_EL1</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">TRBSR_EL1, Trace Buffer Status/syndrome Register</h1><p>The TRBSR_EL1 characteristics are:</p><h2>Purpose</h2>
        <p>Provides syndrome information to software for a trace buffer management event.</p>
      <h2>Configuration</h2><p>External register TRBSR_EL1 bits [63:0] are architecturally mapped to AArch64 System register <a href="AArch64-trbsr_el1.html">TRBSR_EL1[63:0]</a>.</p><p>TRBSR_EL1 is in the Core power domain.
    </p><p>This register is present only when FEAT_TRBE_EXT is implemented. Otherwise, direct accesses to TRBSR_EL1 are <span class="arm-defined-word">RES0</span>.</p><h2>Attributes</h2>
        <p>TRBSR_EL1 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_0-63_56">RES0</a></td><td class="lr" colspan="24"><a href="#fieldset_0-55_32">MSS2</a></td></tr><tr class="firstrow"><td class="lr" colspan="6"><a href="#fieldset_0-31_26">EC</a></td><td class="lr" colspan="2"><a href="#fieldset_0-25_24">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-23_23">DAT</a></td><td class="lr" colspan="1"><a href="#fieldset_0-22_22">IRQ</a></td><td class="lr" colspan="1"><a href="#fieldset_0-21_21">TRG</a></td><td class="lr" colspan="1"><a href="#fieldset_0-20_20">WRAP</a></td><td class="lr" colspan="1"><a href="#fieldset_0-19_19">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-18_18-1">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-17_17">S</a></td><td class="lr" colspan="1"><a href="#fieldset_0-16_16">RES0</a></td><td class="lr" colspan="16"><a href="#fieldset_0-15_0">MSS</a></td></tr></tbody></table><h4 id="fieldset_0-63_56">Bits [63:56]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-55_32">MSS2, bits [55:32]</h4><div class="field">
      <p>Management event Specific Syndrome 2. Contains syndrome specific to the management event.</p>
    
      <p>The syndrome contents for each management event are described in the following sections.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><div class="partial_fieldset"><h3 id="fieldset_0-55_32_0">MSS2 encoding for other trace buffer management events</h3><table class="regdiagram"><thead><tr><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="24"><a href="#fieldset_0-55_32_0-23_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-55_32_0-23_0">Bits [23:0]</h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div></div><div class="partial_fieldset"><h3 id="fieldset_0-55_32_1">MSS2 encoding for a buffer management event for an IMPLEMENTATION DEFINED reason</h3><table class="regdiagram"><thead><tr><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="24"><a href="#fieldset_0-55_32_1-23_0">IMPLEMENTATION DEFINED</a></td></tr></tbody></table><h4 id="fieldset_0-55_32_1-23_0">IMPLEMENTATION DEFINED, bits [23:0]</h4><div class="field">
            <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
          </div></div><div class="partial_fieldset"><h3 id="fieldset_0-55_32_2">MSS2 encoding for stage 1 or stage 2 Data Aborts on write to trace buffer</h3><table class="regdiagram"><thead><tr><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_0-55_32_2-23_8">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_2-7_7-1">AssuredOnly</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_2-6_6-1">Overlay</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_2-5_5-1">DirtyBit</a></td><td class="lr" colspan="5"><a href="#fieldset_0-55_32_2-4_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-55_32_2-23_8">Bits [23:8]</h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div><h4 id="fieldset_0-55_32_2-7_7-1">AssuredOnly, bit [7]<span class="condition"><br/>When FEAT_THE is implemented, TRBSR_EL1.EC == 0b100101 and GetTRBSR_EL1_FSC() == 0b0011xx:
                        </span></h4><div class="field">
            <p>AssuredOnly flag. If a memory access generates a stage 2 Data Abort, then this field holds information about the fault.</p>
          <table class="valuetable"><tr><th>AssuredOnly</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
                <p>Data Abort is not due to AssuredOnly.</p>
              </td></tr><tr><td class="bitfield">0b1</td><td>
                <p>Data Abort is due to AssuredOnly.</p>
              </td></tr></table></div><h4 id="fieldset_0-55_32_2-7_7-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div><h4 id="fieldset_0-55_32_2-6_6-1">Overlay, bit [6]<span class="condition"><br/>When (FEAT_S1POE is implemented or FEAT_S2POE is implemented) and GetTRBSR_EL1_FSC() == 0b0011xx:
                        </span></h4><div class="field">
            <p>Overlay flag. If a memory access generates a Data Abort for a Permission fault, then this field holds information about the fault.</p>
          <table class="valuetable"><tr><th>Overlay</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
                <p>Data Abort due to Base Permissions.</p>
              </td></tr><tr><td class="bitfield">0b1</td><td>
                <p>Data Abort due to Overlay Permissions.</p>
              </td></tr></table></div><h4 id="fieldset_0-55_32_2-6_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div><h4 id="fieldset_0-55_32_2-5_5-1">DirtyBit, bit [5]<span class="condition"><br/>When (FEAT_S1PIE is implemented or FEAT_S2PIE is implemented) and GetTRBSR_EL1_FSC() == 0b0011xx:
                        </span></h4><div class="field">
            <p>DirtyBit flag. If a memory access generates a Data Abort (Write Access) for a Permission fault (When using Indirect Permission), then this field holds information about the fault.</p>
          <table class="valuetable"><tr><th>DirtyBit</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
                <p>Permission Fault is not due to state of nDirty / Dirty bit.</p>
              </td></tr><tr><td class="bitfield">0b1</td><td>
                <p>Permission Fault is due to state of nDirty / Dirty bit.</p>
              </td></tr></table></div><h4 id="fieldset_0-55_32_2-5_5-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div><h4 id="fieldset_0-55_32_2-4_0">Bits [4:0]</h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div></div></div><h4 id="fieldset_0-31_26">EC, bits [31:26]</h4><div class="field">
      <p>Event Class. Top-level description of the cause of the trace buffer management event.</p>
    <table class="valuetable"><tr><th>EC</th><th>Meaning</th><th>MSS</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td>
          <p>Other trace buffer management event. All trace buffer management events other than those described by the other defined event class codes.</p>
        </td><td><a href="#fieldset_0-15_0_0">MSS encoding for other trace buffer management events</a></td></tr><tr><td class="bitfield">0b011110</td><td><p>Granule Protection Check fault on write to trace buffer, other than Granule Protection Fault (GPF). That is, any of the following:</p>
<ul>
<li>Granule Protection Table (GPT) address size fault.
</li><li>GPT walk fault.
</li><li>Synchronous External abort on GPT fetch.
</li></ul>
<p>A GPF on translation table walk or update is reported as either a Stage 1 or Stage 2 Data Abort, as appropriate. Other GPFs are reported as a Stage 1 Data Abort.</p></td><td><a href="#fieldset_0-15_0_0">MSS encoding for other trace buffer management events</a></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b011111</td><td>
          <p>Buffer management event for an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> reason.</p>
        </td><td><a href="#fieldset_0-15_0_1">MSS encoding for a buffer management event for an IMPLEMENTATION DEFINED reason</a></td></tr><tr><td class="bitfield">0b100100</td><td>
          <p>Stage 1 Data Abort on write to trace buffer.</p>
        </td><td><a href="#fieldset_0-15_0_2">MSS encoding for stage 1 or stage 2 Data Aborts on write to trace buffer</a></td></tr><tr><td class="bitfield">0b100101</td><td>
          <p>Stage 2 Data Abort on write to trace buffer.</p>
        </td><td><a href="#fieldset_0-15_0_2">MSS encoding for stage 1 or stage 2 Data Aborts on write to trace buffer</a></td></tr></table>
      <p>All other values are reserved.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_24">Bits [25:24]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-23_23">DAT, bit [23]</h4><div class="field">
      <p>Data. Indicates when the Trace Buffer Unit has trace data that has not yet been written to memory.</p>
    <table class="valuetable"><tr><th>DAT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Internal buffers are empty. All Trace operations Accepted by the Trace Buffer Unit will Complete in finite time.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Internal buffers are not empty.</p>
        </td></tr></table><p>When TRBSR_EL1.{DAT, S} is {0, 1}, meaning Collection is stopped and the Trace Buffer Unit internal buffers are empty, then all trace data has been written to memory. An additional Data Synchronization Barrier may be required to ensure that the writes are Complete. When TRBSR_EL1.DAT is 0 and Collection is not stopped, there may still be trace data held by the trace unit that the Trace Buffer Unit has not Accepted.</p>
<p>That is, TRBSR_EL1.DAT reads as 1 when the Trace Buffer Unit has Accepted trace data from the trace unit, but has not yet written it to memory.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-22_22">IRQ, bit [22]</h4><div class="field">
      <p>Maintenance interrupt status.</p>
    <table class="valuetable"><tr><th>IRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Maintenance interrupt is not asserted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Maintenance interrupt is asserted.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-21_21">TRG, bit [21]</h4><div class="field">
      <p>Triggered.</p>
    <table class="valuetable"><tr><th>TRG</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>No Detected Trigger has been observed since this field was last cleared to zero.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>A Detected Trigger has been observed since this field was last cleared to zero.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-20_20">WRAP, bit [20]</h4><div class="field">
      <p>Wrapped.</p>
    <table class="valuetable"><tr><th>WRAP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>The current write pointer has not wrapped since this field was last cleared to zero.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The current write pointer has wrapped since this field was last cleared to zero.</p>
        </td></tr></table>
      <p>For each byte of trace the Trace Buffer Unit Accepts and writes to the trace buffer at the address in the current write pointer, if the current write pointer is equal to the Limit pointer minus one, the current write pointer is wrapped by setting it to the Base pointer, and this field is set to 1.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-19_19">Bit [19]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-18_18-1">Bit [18]<span class="condition"><br/>From Armv9.3:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-18_18-2"><span class="condition"><br/>When the PE sets this bit as the result of an External Abort:
                        </span></h4><div class="field">
      <p>External Abort.</p>
    <table class="valuetable"><tr><th>EA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>An External Abort has not been asserted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>An External Abort has been asserted and detected by the Trace Buffer Unit.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-18_18-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-17_17">S, bit [17]</h4><div class="field">
      <p>Stopped.</p>
    <table class="valuetable"><tr><th>S</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Collection has not been stopped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Collection is stopped.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-16_16">Bit [16]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-15_0">MSS, bits [15:0]</h4><div class="field">
      <p>Management event Specific Syndrome. Contains syndrome specific to the management event.</p>
    
      <p>The syndrome contents for each management event are described in the following sections.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><div class="partial_fieldset"><h3 id="fieldset_0-15_0_0">MSS encoding for other trace buffer management events</h3><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="10"><a href="#fieldset_0-15_0_0-15_6">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_0-15_0_0-5_0">BSC</a></td></tr></tbody></table><h4 id="fieldset_0-15_0_0-15_6">Bits [15:6]</h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div><h4 id="fieldset_0-15_0_0-5_0">BSC, bits [5:0]</h4><div class="field">
            <p>Trace buffer status code.</p>
          <table class="valuetable"><tr><th>BSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000000</td><td>
                <p>Collection not stopped, or access not allowed.</p>
              </td></tr><tr><td class="bitfield">0b000001</td><td>
                <p>Trace buffer filled. Collection stopped because the current write pointer wrapped to the base pointer and the trace buffer mode is Fill mode.</p>
              </td></tr><tr><td class="bitfield">0b000010</td><td>
                <p>Trigger Event. Collection stopped because of a Trigger Event. See <a href="ext-trbtrg_el1.html">TRBTRG_EL1</a> for more information.</p>
              </td></tr><tr><td class="bitfield">0b000011</td><td>
                <p>Manual Stop. Collection stopped because of a Manual Stop event. See <a href="ext-trbcr.html">TRBCR</a>.ManStop for more information.</p>
              </td></tr></table>
            <p>All other values are reserved.</p>
          </div></div><div class="partial_fieldset"><h3 id="fieldset_0-15_0_1">MSS encoding for a buffer management event for an IMPLEMENTATION DEFINED reason</h3><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_0-15_0_1-15_0">IMPLEMENTATION DEFINED</a></td></tr></tbody></table><h4 id="fieldset_0-15_0_1-15_0">IMPLEMENTATION DEFINED, bits [15:0]</h4><div class="field">
            <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
          </div></div><div class="partial_fieldset"><h3 id="fieldset_0-15_0_2">MSS encoding for stage 1 or stage 2 Data Aborts on write to trace buffer</h3><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="10"><a href="#fieldset_0-15_0_2-15_6">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_0-15_0_2-5_0">FSC</a></td></tr></tbody></table><h4 id="fieldset_0-15_0_2-15_6">Bits [15:6]</h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div><h4 id="fieldset_0-15_0_2-5_0">FSC, bits [5:0]</h4><div class="field">
            <p>Fault Status Code.</p>
          <table class="valuetable"><tr><th>FSC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td>
                <p>Address size fault, level 0 of translation or translation table base register.</p>
              </td></tr><tr><td class="bitfield">0b000001</td><td>
                <p>Address size fault, level 1.</p>
              </td></tr><tr><td class="bitfield">0b000010</td><td>
                <p>Address size fault, level 2.</p>
              </td></tr><tr><td class="bitfield">0b000011</td><td>
                <p>Address size fault, level 3.</p>
              </td></tr><tr><td class="bitfield">0b000100</td><td>
                <p>Translation fault, level 0.</p>
              </td></tr><tr><td class="bitfield">0b000101</td><td>
                <p>Translation fault, level 1.</p>
              </td></tr><tr><td class="bitfield">0b000110</td><td>
                <p>Translation fault, level 2.</p>
              </td></tr><tr><td class="bitfield">0b000111</td><td>
                <p>Translation fault, level 3.</p>
              </td></tr><tr><td class="bitfield">0b001001</td><td>
                <p>Access flag fault, level 1.</p>
              </td></tr><tr><td class="bitfield">0b001010</td><td>
                <p>Access flag fault, level 2.</p>
              </td></tr><tr><td class="bitfield">0b001011</td><td>
                <p>Access flag fault, level 3.</p>
              </td></tr><tr><td class="bitfield">0b001000</td><td>
                <p>Access flag fault, level 0.</p>
              </td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001100</td><td>
                <p>Permission fault, level 0.</p>
              </td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001101</td><td>
                <p>Permission fault, level 1.</p>
              </td></tr><tr><td class="bitfield">0b001110</td><td>
                <p>Permission fault, level 2.</p>
              </td></tr><tr><td class="bitfield">0b001111</td><td>
                <p>Permission fault, level 3.</p>
              </td></tr><tr><td class="bitfield">0b010000</td><td>
                <p>Synchronous External abort, not on translation table walk or hardware update of translation table.</p>
              </td></tr><tr><td class="bitfield">0b010001</td><td>
                <p>Asynchronous External abort.</p>
              </td></tr><tr><td class="bitfield">0b010010</td><td>
                <p>Synchronous External abort on translation table walk or hardware update of translation table, level -2.</p>
              </td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b010011</td><td>
                <p>Synchronous External abort on translation table walk or hardware update of translation table, level -1.</p>
              </td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b010100</td><td>
                <p>Synchronous External abort on translation table walk or hardware update of translation table, level 0.</p>
              </td></tr><tr><td class="bitfield">0b010101</td><td>
                <p>Synchronous External abort on translation table walk or hardware update of translation table, level 1.</p>
              </td></tr><tr><td class="bitfield">0b010110</td><td>
                <p>Synchronous External abort on translation table walk or hardware update of translation table, level 2.</p>
              </td></tr><tr><td class="bitfield">0b010111</td><td>
                <p>Synchronous External abort on translation table walk or hardware update of translation table, level 3.</p>
              </td></tr><tr><td class="bitfield">0b011011</td><td>
                <p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level -1.</p>
              </td><td>When FEAT_LPA2 is implemented and FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b100001</td><td>
                <p>Alignment fault.</p>
              </td></tr><tr><td class="bitfield">0b100010</td><td>
                <p>Granule Protection Fault on translation table walk or hardware update of translation table, level -2.</p>
              </td><td>When FEAT_D128 is implemented and FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100011</td><td>
                <p>Granule Protection Fault on translation table walk or hardware update of translation table, level -1.</p>
              </td><td>When FEAT_RME is implemented and FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b100100</td><td>
                <p>Granule Protection Fault on translation table walk or hardware update of translation table, level 0.</p>
              </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100101</td><td>
                <p>Granule Protection Fault on translation table walk or hardware update of translation table, level 1.</p>
              </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100110</td><td>
                <p>Granule Protection Fault on translation table walk or hardware update of translation table, level 2.</p>
              </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100111</td><td>
                <p>Granule Protection Fault on translation table walk or hardware update of translation table, level 3.</p>
              </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101000</td><td>
                <p>Granule Protection Fault, not on translation table walk or hardware update of translation table.</p>
              </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101001</td><td>
                <p>Address size fault, level -1.</p>
              </td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101010</td><td>
                <p>Translation fault, level -2.</p>
              </td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b101011</td><td>
                <p>Translation fault, level -1.</p>
              </td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101100</td><td>
                <p>Address Size fault, level -2.</p>
              </td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b110000</td><td>
                <p>TLB conflict abort.</p>
              </td></tr><tr><td class="bitfield">0b110001</td><td>
                <p>Unsupported atomic hardware update fault.</p>
              </td><td>When FEAT_HAFDBS is implemented</td></tr></table>
            <p>All other values are reserved.</p>
          </div></div></div><h2>Accessing TRBSR_EL1</h2>
        <p>The PE might ignore a write to TRBSR_EL1 if any of the following apply:</p>

      
        <ul>
<li><a href="ext-trblimitr_el1.html">TRBLIMITR_EL1</a>.E == <span class="binarynumber">0b1</span> and the Trace Buffer Unit is using Self-hosted mode.
</li><li><a href="ext-trblimitr_el1.html">TRBLIMITR_EL1</a>.XE == <span class="binarynumber">0b1</span> and the Trace Buffer Unit is using External mode.
</li></ul>
      <h4>TRBSR_EL1 can be accessed through the external debug interface:</h4><table class="info"><tr><th>Component</th><th>Offset</th><th>Instance</th></tr><tr><td>TRBE</td><td><span class="hexnumber">0x018</span></td><td>TRBSR_EL1</td></tr></table><p>This interface is accessible as follows:</p><ul><li>When DoubleLockStatus(), or !IsCorePowered(), or OSLockStatus() or !AllowExternalTraceBufferAccess(), accesses to this register generate an error response.
          </li><li>Otherwise, accesses to this register are <span class="access_level">RW</span>.
          </li></ul><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:07; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
