<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>GICH_HCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">GICH_HCR, Hypervisor Control Register</h1><p>The GICH_HCR characteristics are:</p><h2>Purpose</h2>
        <p>Controls the virtual CPU interface.</p>
      <h2>Configuration</h2><p>This register is present only when FEAT_GICv3_LEGACY is implemented and EL2 is implemented. Otherwise, direct accesses to GICH_HCR are <span class="arm-defined-word">RES0</span>.</p>
        <p>This register is available when the GIC implementation supports interrupt virtualization.</p>
      <h2>Attributes</h2>
        <p>GICH_HCR is a 32-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="5"><a href="#fieldset_0-31_27">EOICount</a></td><td class="lr" colspan="19"><a href="#fieldset_0-26_8">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7">VGrp1DIE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6">VGrp1EIE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5">VGrp0DIE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-4_4">VGrp0EIE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-3_3">NPIE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2">LRENPIE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">UIE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">En</a></td></tr></tbody></table><h4 id="fieldset_0-31_27">EOICount, bits [31:27]</h4><div class="field"><p>Counts the number of EOIs received that do not have a corresponding entry in the List registers. The virtual CPU interface increments this field automatically when a matching EOI is received. EOIs that do not clear a bit in <a href="ext-gich_aprn.html">GICH_APR&lt;n&gt;</a> do not cause an increment. If an EOI occurs when the value of this field is 31, then the field wraps to 0.</p>
<p>The maintenance interrupt is asserted whenever this field is nonzero and GICH_HCR.LRENPIE == 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-26_8">Bits [26:8]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-7_7">VGrp1DIE, bit [7]</h4><div class="field"><p>VM Group 1 Disabled Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is disabled:</p><table class="valuetable"><tr><th>VGrp1DIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Maintenance interrupt disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp1 == 0.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_6">VGrp1EIE, bit [6]</h4><div class="field"><p>VM Group 1 Enabled Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected virtual machine is enabled:</p><table class="valuetable"><tr><th>VGrp1EIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Maintenance interrupt disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp1 == 1.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-5_5">VGrp0DIE, bit [5]</h4><div class="field"><p>VM Group 0 Disabled Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is disabled:</p><table class="valuetable"><tr><th>VGrp0DIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Maintenance interrupt disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp0 == 0.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-4_4">VGrp0EIE, bit [4]</h4><div class="field"><p>VM Group 0 Enabled Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected virtual machine is enabled:</p><table class="valuetable"><tr><th>VGrp0EIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Maintenance interrupt disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Maintenance interrupt signaled when <a href="ext-gicv_ctlr.html">GICV_CTLR</a>.EnableGrp0 == 1.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-3_3">NPIE, bit [3]</h4><div class="field"><p>No Pending Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while no pending interrupts are present in the List registers:</p><table class="valuetable"><tr><th>NPIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Maintenance interrupt disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Maintenance interrupt signaled while the List registers contain no interrupts in the pending state.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-2_2">LRENPIE, bit [2]</h4><div class="field"><p>List Register Entry Not Present Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register for an EOI request:</p><table class="valuetable"><tr><th>LRENPIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Maintenance interrupt disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Maintenance interrupt signaled while GICH_HCR.EOICount is not 0.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-1_1">UIE, bit [1]</h4><div class="field"><p>Underflow Interrupt Enable.</p>
<p>Enables the signaling of a maintenance interrupt when the List registers are either empty or hold only one valid entry.</p><table class="valuetable"><tr><th>UIE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Maintenance interrupt disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>A maintenance interrupt is signaled if zero or one of the List register entries are marked as a valid interrupt.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-0_0">En, bit [0]</h4><div class="field"><p>Enable.</p>
<p>Global enable bit for the virtual CPU interface.</p><table class="valuetable"><tr><th>En</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Virtual CPU interface operation is disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Virtual CPU interface operation is enabled.</p>
        </td></tr></table><p>When this field is 0:</p>
<ul>
<li>The virtual CPU interface does not signal any maintenance interrupts.
</li><li>The virtual CPU interface does not signal any virtual interrupts.
</li><li>A read of <a href="ext-gicv_iar.html">GICV_IAR</a> or <a href="ext-gicv_aiar.html">GICV_AIAR</a> returns a spurious interrupt ID.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>The VGrp1DIE, VGrp1EIE, VGrp0DIE, and VGrp0EIE fields permit the hypervisor to track the virtual CPU interfaces that are enabled. The hypervisor can then route interrupts that have multiple targets correctly and efficiently, without having to read the virtual CPU interface status.</p>
<p>See <span class="xref">'Maintenance interrupts' in ARM® Generic Interrupt Controller Architecture Specification, GIC architecture version 3.0 and version 4.0 (ARM IHI 0069)</span> and <a href="ext-gich_misr.html">GICH_MISR</a> for more information.</p></div><h2>Accessing GICH_HCR</h2>
        <p>This register is used only when System register access is not enabled. When System register access is enabled:</p>

      
        <ul>
<li>For AArch32 implementations, <a href="AArch32-ich_hcr.html">ICH_HCR</a> provides equivalent functionality.
</li><li>For AArch64 implementations, <a href="AArch64-ich_hcr_el2.html">ICH_HCR_EL2</a> provides equivalent functionality.
</li></ul>

      
        <p>GICH_HCR.En must be set to 1 for any virtual or maintenance interrupt to be asserted.</p>
      <h4>GICH_HCR can be accessed through the memory-mapped interfaces:</h4><table class="info"><tr><th>Component</th><th>Offset</th><th>Instance</th></tr><tr><td>GIC Virtual interface control</td><td><span class="hexnumber">0x0000</span></td><td>GICH_HCR</td></tr></table><p>This interface is accessible as follows:</p><ul><li>When GICD_CTLR.DS == 0, accesses to this register are <span class="access_level">RW</span>.
          </li><li>When an access is Secure, accesses to this register are <span class="access_level">RW</span>.
          </li><li>When an access is Non-secure, accesses to this register are <span class="access_level">RW</span>.
          </li></ul><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:07; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
