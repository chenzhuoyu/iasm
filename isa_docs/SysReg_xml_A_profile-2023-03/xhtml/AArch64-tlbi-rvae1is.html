<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>TLBI RVAE1IS, TLBI RVAE1ISNXS</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">TLBI RVAE1IS, TLBI RVAE1ISNXS, TLB Range Invalidate by VA, EL1, Inner Shareable</h1><p>The TLBI RVAE1IS, TLBI RVAE1ISNXS characteristics are:</p><h2>Purpose</h2>
        <p>Invalidates cached copies of translation table entries from TLBs that meet all the following requirements:</p>

      
        <ul>
<li>
<p>The entry is a 64-bit stage 1 translation table entry, from any level of the translation table walk up to the level indicated in the TTL hint.</p>
<p>Or, if FEAT_D128 is implemented, and the entry is 128-bit a stage 1 translation table entry, if TTL is <span class="binarynumber">0b00</span>.</p>

</li><li>
<p>The entry would be used to translate any of the VAs in the specified address range, and one of the following applies:</p>
<ul>
<li>
<p>The entry is from a level of lookup above the final level and matches the specified ASID.</p>

</li><li>
<p>The entry is a global entry from the final level of lookup.</p>

</li><li>
<p>The entry is a non-global entry from the final level of lookup that matches the specified ASID.</p>

</li></ul>

</li><li>
<p>The entry is within the address range determined by the formula [BaseADDR &lt;= VA &lt; BaseADDR + ((NUM +1)*2<sup>(5*SCALE +1)</sup> * Translation_Granule_Size)].</p>

</li><li>
<p>When EL2 is implemented and enabled in the current Security state:</p>
<ul>
<li>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is not {1, 1}, the entry would be used with the current VMID and would be required to translate any of the VAs in the specified address range using the EL1&amp;0 translation regime for the Security state.
</li><li>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} is {1, 1}, the entry would be required to translate any of the VAs in the specified address range using the EL2&amp;0 translation regime for the Security state.
</li></ul>

</li><li>
<p>When EL2 is not implemented or is disabled in the current Security state, the entry would be required to translate any of the VAs in the specified address range using the EL1&amp;0 translation regime for the Security state.</p>

</li></ul>

      
        <p>The Security state is indicated by the value of 
<a href="AArch64-scr_el3.html">SCR_EL3</a>.NS if <span class="xref">FEAT_RME</span> is not implemented, or <a href="AArch64-scr_el3.html">SCR_EL3</a>.{NSE, NS} if <span class="xref">FEAT_RME</span> is implemented.</p>

      
        <p>The invalidation applies to all PEs in the same Inner Shareable shareability domain as the PE that executes this System instruction.</p>

      
        <div class="note"><span class="note-header">Note</span><p>When 
a TLB maintenance instruction is generated to the Secure EL1&amp;0 translation regime and is defined to pass a VMID argument, or would be defined to pass a VMID argument if <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2==1, then:</p><ul><li>A PE with <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2==1 is not architecturally required to invalidate any entries in the Secure EL1&amp;0 translation of a PE in the same required shareability domain with <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2==0.</li><li>A PE with <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2==0 is not architecturally required to invalidate any entries in the Secure EL1&amp;0 translation of a PE in the same required shareability domain with <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2==1.</li><li>A PE is architecturally required to invalidate all relevant entries in the Secure EL1&amp;0 translation of a System MMU in the same required shareability domain with a VMID of 0.</li></ul></div>
      
        <p>For 64-bit translation table entry, the range of addresses invalidated is <span class="arm-defined-word">UNPREDICTABLE</span> when:</p>

      
        <ul>
<li>
<p>For the 4K translation granule:</p>
<ul>
<li>If TTL==01 and BaseADDR[29:12] is not equal to 000000000000000000.
</li><li>If TTL==10 and BaseADDR[20:12] is not equal to 000000000.
</li></ul>

</li><li>
<p>For the 16K translation granule:</p>
<ul>
<li>If TTL==10 and BaseADDR[24:14] is not equal to 00000000000.
</li></ul>

</li><li>
<p>For the 64K translation granule:</p>
<ul>
<li>If TTL==01 and BaseADDR[41:16] is not equal to 00000000000000000000000000.
</li><li>If TTL==10 and BaseADDR[28:16] is not equal to 0000000000000.
</li></ul>

</li></ul>
      <h2>Configuration</h2><p>This instruction is present only when FEAT_TLBIRANGE is implemented. Otherwise, direct accesses to TLBI RVAE1IS, TLBI RVAE1ISNXS are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>TLBI RVAE1IS, TLBI RVAE1ISNXS is a 64-bit System instruction.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_0-63_48">ASID</a></td><td class="lr" colspan="2"><a href="#fieldset_0-47_46">TG</a></td><td class="lr" colspan="2"><a href="#fieldset_0-45_44">SCALE</a></td><td class="lr" colspan="5"><a href="#fieldset_0-43_39">NUM</a></td><td class="lr" colspan="2"><a href="#fieldset_0-38_37">TTL</a></td><td class="lr" colspan="5"><a href="#fieldset_0-36_0-1">BaseADDR</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-36_0-1">BaseADDR</a></td></tr></tbody></table><h4 id="fieldset_0-63_48">ASID, bits [63:48]</h4><div class="field"><p>ASID value to match. Any TLB entries that match the ASID value and VA value will be affected by this System instruction.</p>
<p>Global TLB entries that match the VA value will be affected by this System instruction, regardless of the value of the ASID field.</p>
<p>If the implementation supports 16 bits of ASID, then the upper 8 bits of the ASID must be written to 0 by software when the context being invalidated only uses 8 bits.</p></div><h4 id="fieldset_0-47_46">TG, bits [47:46]</h4><div class="field">
      <p>Translation granule size.</p>
    <table class="valuetable"><tr><th>TG</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Reserved.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>4K translation granule.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>16K translation granule.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>64K translation granule.</p>
        </td></tr></table>
      <p>The instruction takes a translation granule size for the translations that are being invalidated. If the translations used a different translation granule size than the one being specified, then the architecture does not require that the instruction invalidates any entries.</p>
    </div><h4 id="fieldset_0-45_44">SCALE, bits [45:44]</h4><div class="field">
      <p>The exponent element of the calculation that is used to produce the upper range.</p>
    </div><h4 id="fieldset_0-43_39">NUM, bits [43:39]</h4><div class="field">
      <p>The base element of the calculation that is used to produce the upper range.</p>
    </div><h4 id="fieldset_0-38_37">TTL, bits [38:37]</h4><div class="field"><p>TTL Level hint. The TTL hint is only guaranteed to invalidate:</p>
<ul>
<li>
<p>Non-leaf-level entries in the range up to but not including the level described by the TTL hint.</p>

</li><li>
<p>Leaf-level entries in the range that match the level described by the TTL hint.</p>

</li></ul><table class="valuetable"><tr><th>TTL</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>The entries in the range can be using any level for the translation table entries.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td><p>The TTL hint indicates level 1.</p>
<p>If <span class="xref">FEAT_LPA2</span> is not implemented, when using a 16KB translation granule, this value is reserved and hardware should treat this field as <span class="binarynumber">0b00</span>.</p></td></tr><tr><td class="bitfield">0b10</td><td>
          <p>The TTL hint indicates level 2.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>The TTL hint indicates level 3.</p>
        </td></tr></table></div><h4 id="fieldset_0-36_0-1">BaseADDR, bits [36:0]<span class="condition"><br/>When FEAT_LPA2 is implemented and TCR_EL1.DS == 1:
                        </span></h4><div class="field"><p>The starting address for the range of the maintenance instructions. This field is BaseADDR[52:16] for all translation granules.</p>
<p>When using a 4KB translation granule, BaseADDR[15:12] is treated as <span class="binarynumber">0b0000</span>.</p>
<p>When using a 16KB translation granule, BaseADDR[15:14] is treated as <span class="binarynumber">0b00</span>.</p></div><h4 id="fieldset_0-36_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>The starting address for the range of the maintenance instruction.</p>
<p>When using a 4KB translation granule, this field is BaseADDR[48:12].</p>
<p>When using a 16KB translation granule, this field is BaseADDR[50:14].</p>
<p>When using a 64KB translation granule, this field is BaseADDR[52:16].</p></div><div class="access_mechanisms"><h2>Executing TLBI RVAE1IS, TLBI RVAE1ISNXS</h2><p>Accesses to this instruction use the following encodings in the System instruction encoding space:</p><h4 class="assembler">TLBI RVAE1IS{, &lt;Xt&gt;}</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b01</td><td>0b000</td><td>0b1000</td><td>0b0010</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.TTLB == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.TTLBIS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGITR_EL2.TLBIRVAE1IS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        if IsFeatureImplemented(FEAT_XS) &amp;&amp; IsFeatureImplemented(FEAT_HCX) &amp;&amp; IsHCRXEL2Enabled() &amp;&amp; HCRX_EL2.FnXS == '1' then
            AArch64.TLBI_RVA(SecurityStateAtEL(EL1), Regime_EL10, VMID[], Shareability_ISH, TLBILevel_Any, TLBI_ExcludeXS, X[t, 64]);
        else
            AArch64.TLBI_RVA(SecurityStateAtEL(EL1), Regime_EL10, VMID[], Shareability_ISH, TLBILevel_Any, TLBI_AllAttr, X[t, 64]);
elsif PSTATE.EL == EL2 then
    if HCR_EL2.&lt;E2H,TGE&gt; == '11' then
        AArch64.TLBI_RVA(SecurityStateAtEL(EL2), Regime_EL20, VMID_NONE, Shareability_ISH, TLBILevel_Any, TLBI_AllAttr, X[t, 64]);
    else
        AArch64.TLBI_RVA(SecurityStateAtEL(EL1), Regime_EL10, VMID[], Shareability_ISH, TLBILevel_Any, TLBI_AllAttr, X[t, 64]);
elsif PSTATE.EL == EL3 then
    if HCR_EL2.&lt;E2H,TGE&gt; == '11' then
        AArch64.TLBI_RVA(SecurityStateAtEL(EL2), Regime_EL20, VMID_NONE, Shareability_ISH, TLBILevel_Any, TLBI_AllAttr, X[t, 64]);
    else
        AArch64.TLBI_RVA(SecurityStateAtEL(EL1), Regime_EL10, VMID[], Shareability_ISH, TLBILevel_Any, TLBI_AllAttr, X[t, 64]);
                </p><h4 class="assembler">TLBI RVAE1ISNXS{, &lt;Xt&gt;}</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b01</td><td>0b000</td><td>0b1001</td><td>0b0010</td><td>0b001</td></tr></table><p class="pseudocode">
if !IsFeatureImplemented(FEAT_XS) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.TTLB == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.TTLBIS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; IsFeatureImplemented(FEAT_HCX) &amp;&amp; (!IsHCRXEL2Enabled() || HCRX_EL2.FGTnXS == '0') &amp;&amp; HFGITR_EL2.TLBIRVAE1IS == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        AArch64.TLBI_RVA(SecurityStateAtEL(EL1), Regime_EL10, VMID[], Shareability_ISH, TLBILevel_Any, TLBI_ExcludeXS, X[t, 64]);
elsif PSTATE.EL == EL2 then
    if HCR_EL2.&lt;E2H,TGE&gt; == '11' then
        AArch64.TLBI_RVA(SecurityStateAtEL(EL2), Regime_EL20, VMID_NONE, Shareability_ISH, TLBILevel_Any, TLBI_ExcludeXS, X[t, 64]);
    else
        AArch64.TLBI_RVA(SecurityStateAtEL(EL1), Regime_EL10, VMID[], Shareability_ISH, TLBILevel_Any, TLBI_ExcludeXS, X[t, 64]);
elsif PSTATE.EL == EL3 then
    if HCR_EL2.&lt;E2H,TGE&gt; == '11' then
        AArch64.TLBI_RVA(SecurityStateAtEL(EL2), Regime_EL20, VMID_NONE, Shareability_ISH, TLBILevel_Any, TLBI_ExcludeXS, X[t, 64]);
    else
        AArch64.TLBI_RVA(SecurityStateAtEL(EL1), Regime_EL10, VMID[], Shareability_ISH, TLBILevel_Any, TLBI_ExcludeXS, X[t, 64]);
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:06; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
