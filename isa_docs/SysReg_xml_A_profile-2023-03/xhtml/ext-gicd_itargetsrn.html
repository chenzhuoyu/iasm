<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>GICD_ITARGETSR&lt;n&gt;</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">GICD_ITARGETSR&lt;n&gt;, Interrupt Processor Targets Registers, n = 0 - 254</h1><p>The GICD_ITARGETSR&lt;n&gt; characteristics are:</p><h2>Purpose</h2>
        <p>When affinity routing is not enabled, holds the list of target PEs for the interrupt. That is, it holds the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and has sufficient priority.</p>
      <h2>Configuration</h2>
        <p>These registers are available in all configurations of the GIC. When <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS==0, these registers are Common.</p>

      
        <p>The number of implemented GICD_ITARGETSR&lt;n&gt; registers is 8*(<a href="ext-gicd_typer.html">GICD_TYPER</a>.ITLinesNumber+1). Registers are numbered from 0.</p>

      
        <p>GICD_ITARGETSR0 to GICD_ITARGETSR7 are Banked for each connected PEwith <a href="ext-gicr_typer.html">GICR_TYPER</a>.Processor_Number &lt; 8. </p>

      
        <p>Accessing GICD_ITARGETSR0 to GICD_ITARGETSR7 from a PE with <a href="ext-gicr_typer.html">GICR_TYPER</a>.Processor_Number &gt; 7 is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>:</p>

      
        <ul>
<li>Register is RAZ/WI.
</li><li>An <span class="arm-defined-word">UNKNOWN</span> banked copy of the register is accessed.
</li></ul>
      <h2>Attributes</h2>
        <p>GICD_ITARGETSR&lt;n&gt; is a 32-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_0-31_24">CPU_targets_offset_3B</a></td><td class="lr" colspan="8"><a href="#fieldset_0-23_16">CPU_targets_offset_2B</a></td><td class="lr" colspan="8"><a href="#fieldset_0-15_8">CPU_targets_offset_1B</a></td><td class="lr" colspan="8"><a href="#fieldset_0-7_0">CPU_targets_offset_0B</a></td></tr></tbody></table><div class="text_before_fields">
    <p>PEs in the system number from 0, and each bit in a PE targets field refers to the corresponding PE. For example, a value of <span class="hexnumber">0x3</span> means that the Pending interrupt is sent to PEs 0 and 1. For GICD_ITARGETSR0-GICD_ITARGETSR7, a read of any targets field returns the number of the PE performing the read.</p>
  </div><h4 id="fieldset_0-31_24">CPU_targets_offset_3B, bits [31:24]</h4><div class="field">
      <p>PE targets for an interrupt, at byte offset 3.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a GIC reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-23_16">CPU_targets_offset_2B, bits [23:16]</h4><div class="field">
      <p>PE targets for an interrupt, at byte offset 2.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a GIC reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-15_8">CPU_targets_offset_1B, bits [15:8]</h4><div class="field">
      <p>PE targets for an interrupt, at byte offset 1.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a GIC reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_0">CPU_targets_offset_0B, bits [7:0]</h4><div class="field">
      <p>PE targets for an interrupt, at byte offset 0.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a GIC reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>The bits that are set to 1 in the PE targets field determine which PEs are targeted:</p>
<table class="valuetable"><thead><tr><th>Value of PE targets field</th><th>Interrupt targets</th></tr></thead><tbody><tr><td><span class="binarynumber">0bxxxxxxx1</span></td><td>CPU interface 0</td></tr><tr><td><span class="binarynumber">0bxxxxxx1x</span></td><td>CPU interface 1</td></tr><tr><td><span class="binarynumber">0bxxxxx1xx</span></td><td>CPU interface 2</td></tr><tr><td><span class="binarynumber">0bxxxx1xxx</span></td><td>CPU interface 3</td></tr><tr><td><span class="binarynumber">0bxxx1xxxx</span></td><td>CPU interface 4</td></tr><tr><td><span class="binarynumber">0bxx1xxxxx</span></td><td>CPU interface 5</td></tr><tr><td><span class="binarynumber">0bx1xxxxxx</span></td><td>CPU interface 6</td></tr><tr><td><span class="binarynumber">0b1xxxxxxx</span></td><td>CPU interface 7</td></tr></tbody></table>
<p>For interrupt ID m, when DIV and MOD are the integer division and modulo operations:</p>
<ul>
<li>The corresponding GICD_ITARGETSR&lt;n&gt; number, n, is given by n = m DIV 4.
</li><li>The offset of the required GICD_ITARGETSR&lt;n&gt; register is (<span class="hexnumber">0x800</span> + (4*n)).
</li><li>The byte offset of the required Priority field in this register is m MOD 4, where:<ul>
<li>Byte offset 0 refers to register bits [7:0].
</li><li>Byte offset 1 refers to register bits [15:8].
</li><li>Byte offset 2 refers to register bits [23:16].
</li><li>Byte offset 3 refers to register bits [31:24].
</li></ul>

</li></ul>
<p>Software can write to these registers at any time. Any change to a targets field value:</p>
<ul>
<li>Has no effect on any active interrupt. This means that removing a CPU interface from a targets list does not cancel an active state for interrupts on that CPU interface. There is no effect on interrupts that are active and pending until the active status is cleared, at which time it is treated as a pending interrupt.
</li><li>Has an effect on any pending interrupts. This means:<ul>
<li>Enables the CPU interface to be chosen as a target for the pending interrupt using an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> mechanism.
</li><li>Removing a CPU interface from the target list of a pending interrupt removes the pending state of the interrupt on that CPU interface.
</li></ul>

</li></ul></div><h2>Accessing GICD_ITARGETSR&lt;n&gt;</h2>
        <p>These registers are used when affinity routing is not enabled. When affinity routing is enabled for the Security state of an interrupt, the target PEs for an interrupt are defined by <a href="ext-gicd_iroutern.html">GICD_IROUTER&lt;n&gt;</a> and the associated byte in GICD_ITARGETSR&lt;n&gt; is <span class="arm-defined-word">RES0</span>. An implementation is permitted to make the byte RAZ/WI in this case.</p>

      
        <ul>
<li>These registers are byte-accessible.
</li><li>A register field corresponding to an unimplemented interrupt is RAZ/WI.
</li><li>A field bit corresponding to an unimplemented CPU interface is RAZ/WI.
</li><li>GICD_ITARGETSR0-GICD_ITARGETSR7 are read-only. Each field returns a value that corresponds only to the PE reading the register.
</li><li>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> which, if any, SPIs are statically configured in hardware. The field for such an SPI is read-only, and returns a value that indicates the PE targets for the interrupt.
</li><li>If <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS==0, unless the <a href="ext-gicd_nsacrn.html">GICD_NSACR&lt;n&gt;</a> registers permit Non-secure software to control Group 0 and Secure Group 1 interrupts, any bits that correspond to Group 0 or Secure Group 1 interrupts are accessible only by Secure accesses and are RAZ/WI to Non-secure accesses.
</li></ul>

      
        <p>In a single connected PE implementation, all interrupts target one PE, and these registers are RAZ/WI.</p>

      
        <div class="note"><span class="note-header">Note</span><p>Implementations must ensure that an interrupt that is pending at the time of the write uses either the old value or the new value and must ensure that the interrupt is neither lost nor handled more than one time. The effect of the change must be visible in finite time.</p></div>
      <h4>GICD_ITARGETSR&lt;n&gt; can be accessed through the memory-mapped interfaces:</h4><table class="info"><tr><th>Component</th><th>Frame</th><th>Offset</th><th>Instance</th></tr><tr><td>GIC Distributor</td><td>Dist_base</td><td><span class="hexnumber">0x0800</span> + (4 * n)</td><td>GICD_ITARGETSR&lt;n&gt;</td></tr></table><p>Accesses on this interface are <span class="access_level">RW</span>.</p><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:06; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
