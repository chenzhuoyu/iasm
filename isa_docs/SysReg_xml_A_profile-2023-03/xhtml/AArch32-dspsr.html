<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>DSPSR</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">DSPSR, Debug Saved Program Status Register</h1><p>The DSPSR characteristics are:</p><h2>Purpose</h2>
        <p>Holds the saved process state for Debug state. On entering Debug state, PSTATE information is written to this register. On exiting Debug state, values are copied from this register to PSTATE.</p>
      <h2>Configuration</h2><p>AArch32 System register DSPSR bits [31:0] are architecturally mapped to AArch64 System register <a href="AArch64-dspsr_el0.html">DSPSR_EL0[31:0]</a>.</p><p>This register is present only when AArch32 is supported. Otherwise, direct accesses to DSPSR are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>DSPSR is a 32-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-31_31">N</a></td><td class="lr" colspan="1"><a href="#fieldset_0-30_30">Z</a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29">C</a></td><td class="lr" colspan="1"><a href="#fieldset_0-28_28">V</a></td><td class="lr" colspan="1"><a href="#fieldset_0-27_27">Q</a></td><td class="lr" colspan="2"><a href="#fieldset_0-26_25">IT[1:0]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_24-1">DIT</a></td><td class="lr" colspan="1"><a href="#fieldset_0-23_23-1">SSBS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-22_22-1">PAN</a></td><td class="lr" colspan="1"><a href="#fieldset_0-21_21">SS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-20_20">IL</a></td><td class="lr" colspan="4"><a href="#fieldset_0-19_16">GE</a></td><td class="lr" colspan="6"><a href="#fieldset_0-15_10">IT[7:2]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9">E</a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8">A</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7">I</a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6">F</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5">T</a></td><td class="lr" colspan="5"><a href="#fieldset_0-4_0">M[4:0]</a></td></tr></tbody></table><h4 id="fieldset_0-31_31">N, bit [31]</h4><div class="field">
      <p>Negative Condition flag. Set to the value of PSTATE.N on entering Debug state, and  copied to PSTATE.N on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-30_30">Z, bit [30]</h4><div class="field">
      <p>Zero Condition flag. Set to the value of PSTATE.Z on entering Debug state, and  copied to PSTATE.Z on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29">C, bit [29]</h4><div class="field">
      <p>Carry Condition flag. Set to the value of PSTATE.C on entering Debug state, and  copied to PSTATE.C on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-28_28">V, bit [28]</h4><div class="field">
      <p>Overflow Condition flag. Set to the value of PSTATE.V on entering Debug state, and  copied to PSTATE.V on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-27_27">Q, bit [27]</h4><div class="field">
      <p>Overflow or saturation flag. Set to the value of PSTATE.Q on entering Debug state, and  copied to PSTATE.Q on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-26_25">IT, bits [15:10, 26:25]</h4><div class="field">
      <p>If-Then. Set to the value of PSTATE.IT on entering Debug state, and  copied to PSTATE.IT on exiting Debug state.</p>
    <p>DSPSR.IT must contain a value that is valid for the instruction being returned to.</p>
<p>The IT field is split as follows:</p>
<ul>
<li>IT[1:0] is DSPSR[26:25].
</li><li>IT[7:2] is DSPSR[15:10].
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_24-1">DIT, bit [24]<span class="condition"><br/>When FEAT_DIT is implemented:
                        </span></h4><div class="field">
      <p>Data Independent Timing. Set to the value of PSTATE.DIT on entering Debug state, and  copied to PSTATE.DIT on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_24-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-23_23-1">SSBS, bit [23]<span class="condition"><br/>When FEAT_SSBS is implemented:
                        </span></h4><div class="field">
      <p>Speculative Store Bypass. Set to the value of PSTATE.SSBS on entering Debug state, and  copied to PSTATE.SSBS on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-23_23-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-22_22-1">PAN, bit [22]<span class="condition"><br/>When FEAT_PAN is implemented:
                        </span></h4><div class="field">
      <p>Privileged Access Never. Set to the value of PSTATE.PAN on entering Debug state, and  copied to PSTATE.PAN on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-22_22-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-21_21">SS, bit [21]</h4><div class="field">
      <p>Software Step. Set to the value of PSTATE.SS on entering Debug state, and conditionally  copied to PSTATE.SS on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-20_20">IL, bit [20]</h4><div class="field">
      <p>Illegal Execution state. Set to the value of PSTATE.IL on entering Debug state, and  copied to PSTATE.IL on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-19_16">GE, bits [19:16]</h4><div class="field">
      <p>Greater than or Equal flags. Set to the value of PSTATE.GE on entering Debug state, and  copied to PSTATE.GE on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-9_9">E, bit [9]</h4><div class="field">
      <p>Endianness. Set to the value of PSTATE.E on entering Debug state, and  copied to PSTATE.E on exiting Debug state.</p>
    
      <p>If the implementation does not support big-endian operation, DSPSR.E is <span class="arm-defined-word">RES0</span>. If the implementation does not support little-endian operation, DSPSR.E is <span class="arm-defined-word">RES1</span>. On exiting Debug state, if the implementation does not support big-endian operation at the Exception level being returned to, DSPSR.E is <span class="arm-defined-word">RES0</span>, and if the implementation does not support little-endian operation at the Exception level being returned to, DSPSR.E is <span class="arm-defined-word">RES1</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-8_8">A, bit [8]</h4><div class="field">
      <p>SError interrupt mask. Set to the value of PSTATE.A on entering Debug state, and  copied to PSTATE.A on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_7">I, bit [7]</h4><div class="field">
      <p>IRQ interrupt mask. Set to the value of PSTATE.I on entering Debug state, and  copied to PSTATE.I on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_6">F, bit [6]</h4><div class="field">
      <p>FIQ interrupt mask. Set to the value of PSTATE.F on entering Debug state, and  copied to PSTATE.F on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-5_5">T, bit [5]</h4><div class="field">
      <p>T32 Instruction set state. Set to the value of PSTATE.T on entering Debug state, and  copied to PSTATE.T on exiting Debug state.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-4_0">M[4:0], bits [4:0]</h4><div class="field">
      <p>Mode. Set to the value of PSTATE.M[4:0] on entering Debug state, and  copied to PSTATE.M[4:0] on exiting Debug state.</p>
    <table class="valuetable"><tr><th>M[4:0]</th><th>Meaning</th></tr><tr><td class="bitfield">0b10000</td><td>
          <p>User.</p>
        </td></tr><tr><td class="bitfield">0b10001</td><td>
          <p>FIQ.</p>
        </td></tr><tr><td class="bitfield">0b10010</td><td>
          <p>IRQ.</p>
        </td></tr><tr><td class="bitfield">0b10011</td><td>
          <p>Supervisor.</p>
        </td></tr><tr><td class="bitfield">0b10110</td><td>
          <p>Monitor.</p>
        </td></tr><tr><td class="bitfield">0b10111</td><td>
          <p>Abort.</p>
        </td></tr><tr><td class="bitfield">0b11010</td><td>
          <p>Hyp.</p>
        </td></tr><tr><td class="bitfield">0b11011</td><td>
          <p>Undefined.</p>
        </td></tr><tr><td class="bitfield">0b11111</td><td>
          <p>System.</p>
        </td></tr></table>
      <p>Other values are reserved. If DSPSR.M[4:0] has a Reserved value, or a value for an unimplemented Exception level, exiting Debug state is an illegal return event, as described in <span class="xref">'Illegal return events from AArch32 state'</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing DSPSR</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b011</td><td>0b0100</td><td>0b0101</td><td>0b000</td></tr></table><p class="pseudocode">
if !Halted() then
    UNDEFINED;
else
    R[t] = DSPSR;
                </p><h4 class="assembler">MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b011</td><td>0b0100</td><td>0b0101</td><td>0b000</td></tr></table><p class="pseudocode">
if !Halted() then
    UNDEFINED;
else
    DSPSR = R[t];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:06; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright Â© 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
