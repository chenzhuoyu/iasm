<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>PAR</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PAR, Physical Address Register</h1><p>The PAR characteristics are:</p><h2>Purpose</h2>
        <p>Returns the output address (OA) from an Address translation instruction that executed successfully, or fault information if the instruction did not execute successfully.</p>
      <h2>Configuration</h2><p>AArch32 System register PAR bits [63:0] are architecturally mapped to AArch64 System register <a href="AArch64-par_el1.html">PAR_EL1[63:0]</a>.</p><p>This register is present only when EL1 is capable of using AArch32. Otherwise, direct accesses to PAR are <span class="arm-defined-word">UNDEFINED</span>.</p>
        <p>PAR is a 64-bit register that can also be accessed as a 32-bit value. If it is accessed as a 32-bit register, accesses read and write bits[31:0] and do not modify bits[63:32].</p>

      
        <p>The Configurations section specifies the cases where each PAR format is used.</p>

      
        <p>PAR is accessed as a 32-bit value:</p>

      
        <ul>
<li>When the PE is not in Hyp mode and is using the Short-descriptor translation table format.
</li><li>When the PE is in Hyp mode and executes an <a href="AArch32-ats12nsopr.html">ATS12NSOPR</a>, <a href="AArch32-ats12nsopw.html">ATS12NSOPW</a>, <a href="AArch32-ats12nsour.html">ATS12NSOUR</a>, or <a href="AArch32-ats12nsouw.html">ATS12NSOUW</a> instruction and the value of <a href="AArch32-hcr.html">HCR</a>.VM is 0 and the value of <a href="AArch32-ttbcr.html">TTBCR</a>.EAE is 0.
</li></ul>

      
        <p>In these cases, PAR[63:32] is <span class="arm-defined-word">RES0</span>.</p>

      
        <p>Otherwise, the PAR is accessed as a 64-bit value, if any of the following is true:</p>

      
        <ul>
<li>When using the Long-descriptor translation table format.
</li><li>If the stage 1 address translation is disabled and <a href="AArch32-ttbcr.html">TTBCR</a>.EAE is set to 1.
</li><li>In an implementation that includes EL2, for the result of an ATS1Cxx instruction performed from Hyp mode.
</li></ul>

      
        <p>For PL1&amp;0 stage 1 translations, <a href="AArch32-ttbcr.html">TTBCR</a>.EAE selects the translation table format.</p>
      <h2>Attributes</h2>
        <p>PAR is a 64-bit register.</p>
      <h2>Field descriptions</h2><h3>When the instruction returned a 32-bit value to the PAR, PAR.F==0:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-63_32">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_0-31_12">PA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-11_11">LPAE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10">NOS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9">NS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7">SH</a></td><td class="lr" colspan="3"><a href="#fieldset_0-6_4">Inner[2:0]</a></td><td class="lr" colspan="2"><a href="#fieldset_0-3_2">Outer[1:0]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">SS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">F</a></td></tr></tbody></table><div class="text_before_fields"><p>This section describes the register value returned by the successful execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p>
<p>On a successful conversion, the PAR can return a value that indicates the resulting attributes, rather than the values that appear in the Translation table descriptors. More precisely:</p>
<ul>
<li>Memory attribute fields are permitted to report the resulting attributes, as determined by any permitted implementation choices and any applicable configuration bits, instead of reporting the values that appear in the Translation table descriptors. This applies to the NOS, SH, Inner, and Outer fields.
</li><li>See the NS bit description for constraints on the value it returns.
</li></ul></div><h4 id="fieldset_0-63_32">Bits [63:32]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-31_12">PA, bits [31:12]</h4><div class="field">
      <p>Output address. The output address (OA) corresponding to the supplied input address. This field returns address bits[31:12].</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-11_11">LPAE, bit [11]</h4><div class="field">
      <p>When updating the PAR with the result of the translation operation, this bit is set as follows:</p>
    <table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Short-descriptor translation table format used. This means the PAR returned a 32-bit value.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-10_10">NOS, bit [10]</h4><div class="field">
      <p>Not Outer Shareable. When the returned value of PAR.SH is 1, indicates the Shareability attribute for the physical memory region:</p>
    <table class="valuetable"><tr><th>NOS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Memory region is Outer Shareable.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Memory region is Inner Shareable.</p>
        </td></tr></table><p>When the returned value of PAR.SH is 0 the value returned to this field is <span class="arm-defined-word">UNKNOWN</span>.</p>
<p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-9_9">NS, bit [9]</h4><div class="field"><p>Non-secure. The NS attribute for a translation table entry from a Secure translation regime.</p>
<p>For a result from a Secure translation regime, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p>
<p>For a result from a Non-secure translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-8_8">IMPLEMENTATION DEFINED, bit [8]</h4><div class="field">
      <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_7">SH, bit [7]</h4><div class="field">
      <p>Shareability. Indicates whether the physical memory region is Non-shareable:</p>
    <table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Memory is Non-shareable.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Memory is shareable, and PAR.NOS indicates whether the region is Outer Shareable or Inner Shareable.</p>
        </td></tr></table>
      <p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_4">Inner[2:0], bits [6:4]</h4><div class="field">
      <p>Inner cacheability attribute for the region. Permitted values are:</p>
    <table class="valuetable"><tr><th>Inner[2:0]</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td>
          <p>Non-cacheable.</p>
        </td></tr><tr><td class="bitfield">0b001</td><td>
          <p>Device-nGnRnE.</p>
        </td></tr><tr><td class="bitfield">0b011</td><td>
          <p>Device-nGnRE.</p>
        </td></tr><tr><td class="bitfield">0b101</td><td>
          <p>Write-Back, Write-Allocate.</p>
        </td></tr><tr><td class="bitfield">0b110</td><td>
          <p>Write-Through.</p>
        </td></tr><tr><td class="bitfield">0b111</td><td>
          <p>Write-Back, no Write-Allocate.</p>
        </td></tr></table><p>The values <span class="binarynumber">0b010</span> and <span class="binarynumber">0b100</span> are reserved.</p>
<p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-3_2">Outer[1:0], bits [3:2]</h4><div class="field">
      <p>Outer cacheability attribute for the region. Permitted values are:</p>
    <table class="valuetable"><tr><th>Outer[1:0]</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Non-cacheable.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Write-Back, Write-Allocate.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Write-Through, no Write-Allocate.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>Write-Back, no Write-Allocate.</p>
        </td></tr></table>
      <p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-1_1">SS, bit [1]</h4><div class="field">
      <p>Supersection. Used to indicate if the result is a Supersection:</p>
    <table class="valuetable"><tr><th>SS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Result is not a Supersection. PAR[31:12] contains OA[31:12].</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Result is a Supersection, and:</p>
<ul>
<li>PAR[31:24] contains OA[31:24].
</li><li>PAR[23:16] contains OA[39:32].
</li><li>PAR[15:12] contains <span class="binarynumber">0b0000</span>.
</li></ul>
<p>If an implementation supports less than 40 bits of physical address, the bits in the PAR field that correspond to physical address bits that are not implemented are <span class="arm-defined-word">UNKNOWN</span>.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-0_0">F, bit [0]</h4><div class="field">
      <p>Indicates whether the instruction performed a successful address translation.</p>
    <table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Address translation completed successfully.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When the instruction returned a 32-bit value to the PAR, PAR.F==1:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_1-63_32">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_1-31_16">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_1-15_12">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_1-11_11">LPAE</a></td><td class="lr" colspan="4"><a href="#fieldset_1-10_7">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_1-6_6">FS[5]</a></td><td class="lr" colspan="5"><a href="#fieldset_1-5_1">FS[4:0]</a></td><td class="lr" colspan="1"><a href="#fieldset_1-0_0">F</a></td></tr></tbody></table><div class="text_before_fields">
    <p>This section describes the register value returned by a fault on the execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p>
  </div><h4 id="fieldset_1-63_32">Bits [63:32]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-31_16">IMPLEMENTATION DEFINED, bits [31:16]</h4><div class="field">
      <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-15_12">Bits [15:12]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-11_11">LPAE, bit [11]</h4><div class="field">
      <p>When updating the PAR with the result of the translation operation, this bit is set as follows:</p>
    <table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Short-descriptor translation table format used. This means the PAR returned a 32-bit value.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-10_7">Bits [10:7]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_1-6_6">FS[5], bit [6]</h4><div class="field"><p>Fault status bits, External abort type. Provides an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of an External abort. Values are as in the <a href="AArch32-dfsr.html">DFSR</a>.ExT field when using the Short-descriptor translation table format.</p>
<p>In an implementation that does not provide any classification of External aborts, this bit is <span class="arm-defined-word">RES0</span>.</p>
<p>For aborts other than External aborts this bit always returns 0.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-5_1">FS[4:0], bits [5:1]</h4><div class="field">
      <p>Fault status bits. Values are as in the <a href="AArch32-dfsr.html">DFSR</a>.FS field when using the Short-descriptor translation table format.</p>
    <table class="valuetable"><tr><th>FS[4:0]</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00001</td><td>
          <p>Alignment fault.</p>
        </td></tr><tr><td class="bitfield">0b00011</td><td>
          <p>Access flag fault, level 1.</p>
        </td></tr><tr><td class="bitfield">0b00100</td><td>
          <p>Fault on instruction cache maintenance.</p>
        </td></tr><tr><td class="bitfield">0b00101</td><td>
          <p>Translation fault, level 1.</p>
        </td></tr><tr><td class="bitfield">0b00110</td><td>
          <p>Access flag fault, level 2.</p>
        </td></tr><tr><td class="bitfield">0b00111</td><td>
          <p>Translation fault, level 2.</p>
        </td></tr><tr><td class="bitfield">0b01001</td><td>
          <p>Domain fault, level 1.</p>
        </td></tr><tr><td class="bitfield">0b01011</td><td>
          <p>Domain fault, level 2.</p>
        </td></tr><tr><td class="bitfield">0b01100</td><td>
          <p>Synchronous External abort, on translation table walk, level 1.</p>
        </td></tr><tr><td class="bitfield">0b01101</td><td>
          <p>Permission fault, level 1.</p>
        </td></tr><tr><td class="bitfield">0b01110</td><td>
          <p>Synchronous External abort, on translation table walk, level 2.</p>
        </td></tr><tr><td class="bitfield">0b01111</td><td>
          <p>Permission fault, level 2.</p>
        </td></tr><tr><td class="bitfield">0b10000</td><td>
          <p>TLB conflict abort.</p>
        </td></tr><tr><td class="bitfield">0b11001</td><td>
          <p>Synchronous parity or ECC error on memory access, not on translation table walk.</p>
        </td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b11100</td><td>
          <p>Synchronous parity or ECC error on translation table walk, level 1.</p>
        </td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b11110</td><td>
          <p>Synchronous parity or ECC error on translation table walk, level 2.</p>
        </td><td>When FEAT_RAS is not implemented</td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-0_0">F, bit [0]</h4><div class="field">
      <p>Indicates whether the instruction performed a successful address translation.</p>
    <table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td>
          <p>Address translation aborted.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When the instruction returned a 64-bit value to the PAR, PAR.F==0:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_2-63_56">ATTR</a></td><td class="lr" colspan="16"><a href="#fieldset_2-55_40">RES0</a></td><td class="lr" colspan="8"><a href="#fieldset_2-39_12">PA</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_2-39_12">PA</a></td><td class="lr" colspan="1"><a href="#fieldset_2-11_11">LPAE</a></td><td class="lr" colspan="1"><a href="#fieldset_2-10_10">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="1"><a href="#fieldset_2-9_9">NS</a></td><td class="lr" colspan="2"><a href="#fieldset_2-8_7">SH</a></td><td class="lr" colspan="6"><a href="#fieldset_2-6_1">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_2-0_0">F</a></td></tr></tbody></table><div class="text_before_fields"><p>This section describes the register value returned by the successful execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p>
<p>On a successful conversion, the PAR can return a value that indicates the resulting attributes, rather than the values that appear in the Translation table descriptors. More precisely:</p>
<ul>
<li>Memory attribute fields are permitted to report the resulting attributes, as determined by any permitted implementation choices and any applicable configuration bits, instead of reporting the values that appear in the Translation table descriptors. This applies to the ATTR and SH fields.
</li><li>See the NS bit description for constraints on the value it returns.
</li></ul></div><h4 id="fieldset_2-63_56">ATTR, bits [63:56]</h4><div class="field"><p>Memory attributes for the returned output address. This field uses the same encoding as the Attr&lt;n&gt; fields in <a href="AArch32-mair0.html">MAIR0</a> and <a href="AArch32-mair1.html">MAIR1</a>.</p>
<p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-55_40">Bits [55:40]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_2-39_12">PA, bits [39:12]</h4><div class="field">
      <p>Output address. The output address (OA) corresponding to the supplied input address. This field returns address bits[39:12].</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-11_11">LPAE, bit [11]</h4><div class="field">
      <p>When updating the PAR with the result of the translation operation, this bit is set as follows:</p>
    <table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td>
          <p>Long-descriptor translation table format used. This means the PAR returned a 64-bit value.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-10_10">IMPLEMENTATION DEFINED, bit [10]</h4><div class="field">
      <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-9_9">NS, bit [9]</h4><div class="field"><p>Non-secure. The NS attribute for a translation table entry from a Secure translation regime.</p>
<p>For a result from a Secure translation regime, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p>
<p>For a result from a Non-secure translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-8_7">SH, bits [8:7]</h4><div class="field">
      <p>Shareability attribute, for the returned output address. Permitted values are:</p>
    <table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Non-shareable.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Outer Shareable.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>Inner Shareable.</p>
        </td></tr></table><p>The value <span class="binarynumber">0b01</span> is reserved.</p>
<div class="note"><span class="note-header">Note</span><p>This field returns the value <span class="binarynumber">0b10</span> for:</p><ul><li>Any type of Device memory.</li><li>Normal memory with both Inner Non-cacheable and Outer Non-cacheable attributes.</li></ul></div><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-6_1">Bits [6:1]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_2-0_0">F, bit [0]</h4><div class="field">
      <p>Indicates whether the instruction performed a successful address translation.</p>
    <table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Address translation completed successfully.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When the instruction returned a 64-bit value to the PAR, PAR.F==1:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_3-63_56">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_3-55_52">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_3-51_48">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="16"><a href="#fieldset_3-47_12">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_3-47_12">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_3-11_11">LPAE</a></td><td class="lr" colspan="1"><a href="#fieldset_3-10_10">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_3-9_9">FSTAGE</a></td><td class="lr" colspan="1"><a href="#fieldset_3-8_8">S2WLK</a></td><td class="lr" colspan="1"><a href="#fieldset_3-7_7">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_3-6_1">FST</a></td><td class="lr" colspan="1"><a href="#fieldset_3-0_0">F</a></td></tr></tbody></table><div class="text_before_fields">
    <p>This section describes the register value returned by a fault on the execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p>
  </div><h4 id="fieldset_3-63_56">IMPLEMENTATION DEFINED, bits [63:56]</h4><div class="field">
      <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-55_52">IMPLEMENTATION DEFINED, bits [55:52]</h4><div class="field">
      <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-51_48">IMPLEMENTATION DEFINED, bits [51:48]</h4><div class="field">
      <p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-47_12">Bits [47:12]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_3-11_11">LPAE, bit [11]</h4><div class="field">
      <p>When updating the PAR with the result of the translation operation, this bit is set as follows:</p>
    <table class="valuetable"><tr><th>LPAE</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td>
          <p>Long-descriptor translation table format used. This means the PAR returned a 64-bit value.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-10_10">Bit [10]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_3-9_9">FSTAGE, bit [9]</h4><div class="field">
      <p>Indicates the translation stage at which the translation aborted:</p>
    <table class="valuetable"><tr><th>FSTAGE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Translation aborted because of a fault in the stage 1 translation.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Translation aborted because of a fault in the stage 2 translation.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-8_8">S2WLK, bit [8]</h4><div class="field">
      <p>If this bit is set to 1, it indicates the translation aborted because of a stage 2 fault during a stage 1 translation table walk.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-7_7">Bit [7]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_3-6_1">FST, bits [6:1]</h4><div class="field">
      <p>Fault status field. Values are as in the <a href="AArch32-dfsr.html">DFSR</a>.STATUS and <a href="AArch32-ifsr.html">IFSR</a>.STATUS fields when using the Long-descriptor translation table format.</p>
    <table class="valuetable"><tr><th>FST</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td>
          <p>Address size fault in translation table base register.</p>
        </td></tr><tr><td class="bitfield">0b000001</td><td>
          <p>Address size fault, level 1.</p>
        </td></tr><tr><td class="bitfield">0b000010</td><td>
          <p>Address size fault, level 2.</p>
        </td></tr><tr><td class="bitfield">0b000011</td><td>
          <p>Address size fault, level 3.</p>
        </td></tr><tr><td class="bitfield">0b000101</td><td>
          <p>Translation fault, level 1.</p>
        </td></tr><tr><td class="bitfield">0b000110</td><td>
          <p>Translation fault, level 2.</p>
        </td></tr><tr><td class="bitfield">0b000111</td><td>
          <p>Translation fault, level 3.</p>
        </td></tr><tr><td class="bitfield">0b001001</td><td>
          <p>Access flag fault, level 1.</p>
        </td></tr><tr><td class="bitfield">0b001010</td><td>
          <p>Access flag fault, level 2.</p>
        </td></tr><tr><td class="bitfield">0b001011</td><td>
          <p>Access flag fault, level 3.</p>
        </td></tr><tr><td class="bitfield">0b001101</td><td>
          <p>Permission fault, level 1.</p>
        </td></tr><tr><td class="bitfield">0b001110</td><td>
          <p>Permission fault, level 2.</p>
        </td></tr><tr><td class="bitfield">0b001111</td><td>
          <p>Permission fault, level 3.</p>
        </td></tr><tr><td class="bitfield">0b010101</td><td>
          <p>Synchronous External abort on translation table walk, level 1.</p>
        </td></tr><tr><td class="bitfield">0b010110</td><td>
          <p>Synchronous External abort on translation table walk, level 2.</p>
        </td></tr><tr><td class="bitfield">0b010111</td><td>
          <p>Synchronous External abort on translation table walk, level 3.</p>
        </td></tr><tr><td class="bitfield">0b011101</td><td>
          <p>Synchronous parity or ECC error on memory access on translation table walk, level 1.</p>
        </td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011110</td><td>
          <p>Synchronous parity or ECC error on memory access on translation table walk, level 2.</p>
        </td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011111</td><td>
          <p>Synchronous parity or ECC error on memory access on translation table walk, level 3.</p>
        </td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b110000</td><td>
          <p>TLB conflict abort.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-0_0">F, bit [0]</h4><div class="field">
      <p>Indicates whether the instruction performed a successful address translation.</p>
    <table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td>
          <p>Address translation aborted.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing PAR</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0111</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T7 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T7 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        R[t] = PAR_NS&lt;31:0&gt;;
    else
        R[t] = PAR&lt;31:0&gt;;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        R[t] = PAR_NS&lt;31:0&gt;;
    else
        R[t] = PAR&lt;31:0&gt;;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        R[t] = PAR_S&lt;31:0&gt;;
    else
        R[t] = PAR_NS&lt;31:0&gt;;
                </p><h4 class="assembler">MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0111</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T7 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T7 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        PAR_NS&lt;31:0&gt; = R[t];
    else
        PAR&lt;31:0&gt; = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        PAR_NS&lt;31:0&gt; = R[t];
    else
        PAR&lt;31:0&gt; = R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        PAR_S&lt;31:0&gt; = R[t];
    else
        PAR_NS&lt;31:0&gt; = R[t];
                </p><h4 class="assembler">MRRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;Rt2&gt;, &lt;CRm&gt;</h4><table class="access_instructions"><tr><th>coproc</th><th>CRm</th><th>opc1</th></tr><tr><td>0b1111</td><td>0b0111</td><td>0b0000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T7 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T7 == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        (R[t2], R[t]) = (PAR_NS&lt;63:32&gt;, PAR_NS&lt;31:0&gt;);
    else
        (R[t2], R[t]) = (PAR&lt;63:32&gt;, PAR&lt;31:0&gt;);
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        (R[t2], R[t]) = (PAR_NS&lt;63:32&gt;, PAR_NS&lt;31:0&gt;);
    else
        (R[t2], R[t]) = (PAR&lt;63:32&gt;, PAR&lt;31:0&gt;);
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        (R[t2], R[t]) = (PAR_S&lt;63:32&gt;, PAR_S&lt;31:0&gt;);
    else
        (R[t2], R[t]) = (PAR_NS&lt;63:32&gt;, PAR_NS&lt;31:0&gt;);
                </p><h4 class="assembler">MCRR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;Rt2&gt;, &lt;CRm&gt;</h4><table class="access_instructions"><tr><th>coproc</th><th>CRm</th><th>opc1</th></tr><tr><td>0b1111</td><td>0b0111</td><td>0b0000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T7 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T7 == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        PAR_NS = R[t2]:R[t];
    else
        PAR = R[t2]:R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        PAR_NS = R[t2]:R[t];
    else
        PAR = R[t2]:R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        PAR_S = R[t2]:R[t];
    else
        PAR_NS = R[t2]:R[t];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:06; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright Â© 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
