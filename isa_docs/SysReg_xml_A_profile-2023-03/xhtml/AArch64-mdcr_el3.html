<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>MDCR_EL3</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">MDCR_EL3, Monitor Debug Configuration Register (EL3)</h1><p>The MDCR_EL3 characteristics are:</p><h2>Purpose</h2>
        <p>Provides EL3 configuration options for self-hosted debug and the Performance Monitors Extension.</p>
      <h2>Configuration</h2><p>This register is present only when EL3 is implemented. Otherwise, direct accesses to MDCR_EL3 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>MDCR_EL3 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="14"><a href="#fieldset_0-63_50">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-49_48-1">ETBAD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-47_47-1">EnITE</a></td><td class="lr" colspan="2"><a href="#fieldset_0-46_45-1">EPMSSAD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-44_44-1">EnPMSS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-43_43-1">EBWE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-42_42-1">EnPMS3</a></td><td class="lr" colspan="2"><a href="#fieldset_0-41_40-1">PMEE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-39_39-1">EnTB2</a></td><td class="lr" colspan="1"><a href="#fieldset_0-38_38-1">E3BREC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-37_37-1">E3BREW</a></td><td class="lr" colspan="1"><a href="#fieldset_0-36_36-1">EnPMSN</a></td><td class="lr" colspan="1"><a href="#fieldset_0-35_35-1">MPMX</a></td><td class="lr" colspan="1"><a href="#fieldset_0-34_34-1">MCCD</a></td><td class="lr" colspan="2"><a href="#fieldset_0-33_32-1">SBRBE</a></td></tr><tr class="firstrow"><td class="lr" colspan="2"><a href="#fieldset_0-31_30-1">PMSSE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-28_28-1">MTPME</a></td><td class="lr" colspan="1"><a href="#fieldset_0-27_27-1">TDCC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-26_26-1">NSTBE</a></td><td class="lr" colspan="2"><a href="#fieldset_0-25_24-1">NSTB</a></td><td class="lr" colspan="1"><a href="#fieldset_0-23_23-1">SCCD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-22_22-1">ETAD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-21_21-1">EPMAD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-20_20-1">EDAD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-19_19-1">TTRF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-18_18-1">STE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-17_17-1">SPME</a></td><td class="lr" colspan="1"><a href="#fieldset_0-16_16-1">SDD</a></td><td class="lr" colspan="2"><a href="#fieldset_0-15_14-1">SPD32</a></td><td class="lr" colspan="2"><a href="#fieldset_0-13_12-1">NSPB</a></td><td class="lr" colspan="1"><a href="#fieldset_0-11_11-1">NSPBE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10-1">TDOSA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9">TDA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7-1">EnPM2</a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6-1">TPM</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-4_4-1">EDADE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-3_3-1">ETADE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2-1">EPMADE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0-1">RLTE</a></td></tr></tbody></table><h4 id="fieldset_0-63_50">Bits [63:50]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-49_48-1">ETBAD, bits [49:48]<span class="condition"><br/>When FEAT_TRBE_EXT is implemented:
                        </span></h4><div class="field">
      <p>External Trace Buffer Access Disable. Controls access to the Trace Buffer registers from an external debugger.</p>
    <table class="valuetable"><tr><th>ETBAD</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00</td><td><p>Non-secure accesses from an external debugger to Trace Buffer registers are prohibited.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, Secure and Realm accesses from an external debugger to Trace Buffer registers are prohibited and Root accesses to Trace Buffer registers are allowed.</p>
<p>If <span class="xref">FEAT_RME</span> is not implemented, Secure accesses to Trace Buffer registers are allowed.</p></td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Secure and Non-secure accesses from an external debugger to Trace Buffer registers are prohibited. Root and Realm accesses to Trace Buffer registers are allowed.</p>
        </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Realm and Non-secure accesses from an external debugger to Trace Buffer registers are prohibited. Root and Secure accesses to Trace Buffer registers are allowed.</p>
        </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b11</td><td>
          <p>All accesses from an external debugger to Trace Buffer registers are allowed.</p>
        </td></tr></table>
      <p>If EL3 is not implemented, then the Effective value of this field is <span class="binarynumber">0b11</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-49_48-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-47_47-1">EnITE, bit [47]<span class="condition"><br/>When FEAT_ITE is implemented:
                        </span></h4><div class="field">
      <p>Enable access to Instrumentation trace registers. When disabled, accesses to Instrumentation trace registers generate a trap to EL3.</p>
    <table class="valuetable"><tr><th>EnITE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses of the specified Instrumentation trace registers at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified Instrumentation trace registers are not trapped by this mechanism.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are: <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-trcitecr_el1.html">TRCITECR_EL1</a>, <a href="AArch64-trcitecr_el2.html">TRCITECR_EL2</a>, and TRCITECR_EL12.</p>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-47_47-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-46_45-1">EPMSSAD, bits [46:45]<span class="condition"><br/>When FEAT_PMUv3_SS is implemented:
                        </span></h4><div class="field">
      <p>External PMU Snapshot Access Disable. Controls access to the PMU Snapshot registers from an external debugger.</p>
    <table class="valuetable"><tr><th>EPMSSAD</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00</td><td><p>Non-secure accesses from an external debugger to PMU Snapshot registers are prohibited.</p>
<p>If <span class="xref">FEAT_RME</span> is implemented, Secure and Realm accesses from an external debugger to PMU Snapshot registers are prohibited and Root accesses to PMU Snapshot registers are allowed.</p>
<p>If <span class="xref">FEAT_RME</span> is not implemented, Secure accesses to PMU Snapshot registers are allowed.</p></td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Secure and Non-secure accesses from an external debugger to PMU Snapshot registers are prohibited. Root and Realm accesses to PMU Snapshot registers are allowed.</p>
        </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Realm and Non-secure accesses from an external debugger to PMU Snapshot registers are prohibited. Root and Secure accesses to PMU Snapshot registers are allowed.</p>
        </td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b11</td><td>
          <p>All accesses from an external debugger to PMU Snapshot registers are allowed.</p>
        </td></tr></table>
      <p>If EL3 is not implemented, then the Effective value of this field is <span class="binarynumber">0b11</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-46_45-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-44_44-1">EnPMSS, bit [44]<span class="condition"><br/>When FEAT_PMUv3_SS is implemented:
                        </span></h4><div class="field">
      <p>Enable access to PMU Snapshot registers. When disabled, accesses to PMU Snapshot registers generate a trap to EL3.</p>
    <table class="valuetable"><tr><th>EnPMSS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses of the specified PMU Snapshot registers at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified PMU Snapshot registers are not trapped by this mechanism.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li><span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmccntsvr_el1.html">PMCCNTSVR_EL1</a>, <a href="AArch64-pmevcntsvrn_el1.html">PMEVCNTSVR&lt;n&gt;_EL1</a>, and <a href="AArch64-pmsscr_el1.html">PMSSCR_EL1</a>.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmicntsvr_el1.html">PMICNTSVR_EL1</a>.
</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-44_44-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-43_43-1">EBWE, bit [43]<span class="condition"><br/>When FEAT_Debugv8p9 is implemented:
                        </span></h4><div class="field">
      <p>Extended Breakpoint and Watchpoint Enable. Enables use of additional breakpoints or watchpoints, and enables a trap to EL3 on accesses to debug registers.</p>
    <table class="valuetable"><tr><th>EBWE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Effective values of <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.EMBWE and <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.EBWE are 0.</p>
<p>The Effective value of <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a>.BANK is zero at EL3.</p>
<p>Accesses of <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a> at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Effective values of <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.EMBWE, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.EBWE, and <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a>.BANK are not affected by this field.</p>
<p>Accesses of <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a> are not trapped by this mechanism.</p></td></tr></table><p>In AArch64 state, the instructions affected by this control are: <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a>.</p>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this field is implemented or is <span class="arm-defined-word">RES0</span> when 16 or fewer breakpoints are implemented, 16 or fewer watchpoints are implemented, and <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a> is implemented as RAZ/WI.</p>
<p>If EL3 is not implemented, then the Effective value of this field is 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-43_43-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-42_42-1">EnPMS3, bit [42]<span class="condition"><br/>When FEAT_SPE_FDS is implemented:
                        </span></h4><div class="field">
      <p>Enable access to SPE registers. When disabled, accesses to SPE registers generate a trap to EL3.</p>
    <table class="valuetable"><tr><th>EnPMS3</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses of the specified SPE registers at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified SPE registers are not trapped by this mechanism.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are: <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmsdsfr_el1.html">PMSDSFR_EL1</a>.</p>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-42_42-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-41_40-1">PMEE, bits [41:40]<span class="condition"><br/>When FEAT_EBEP is implemented:
                        </span></h4><div class="field">
      <p>Performance Monitors Exception Enable. Controls the generation of <span class="signal">PMUIRQ</span> signal and PMU exception at all Exception levels.</p>
    <table class="valuetable"><tr><th>PMEE</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p><span class="signal">PMUIRQ</span> signal is enabled, and PMU exception is disabled.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p><span class="signal">PMUIRQ</span> signal and PMU exception are both controlled by <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.PMEE.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p><span class="signal">PMUIRQ</span> signal is disabled, and PMU exception is disabled.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p><span class="signal">PMUIRQ</span> signal is disabled, and PMU exception is enabled.</p>
        </td></tr></table>
      <p>If EL3 is not implemented, then the Effective value of this field is <span class="binarynumber">0b01</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-41_40-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-39_39-1">EnTB2, bit [39]<span class="condition"><br/>When FEAT_TRBE_MPAM is implemented:
                        </span></h4><div class="field">
      <p>Enable access to Trace Buffer registers. When disabled, accesses to Trace Buffer registers generate a trap to EL3.</p>
    <table class="valuetable"><tr><th>EnTB2</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses of the specified Trace Buffer registers at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified Trace Buffer registers are not trapped by this mechanism.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are: <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-trbmpam_el1.html">TRBMPAM_EL1</a>.</p>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-39_39-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-38_38-1">E3BREC, bit [38]<span class="condition"><br/>When FEAT_BRBEv1p1 is implemented:
                        </span></h4><div class="field">
      <p>Branch Record Buffer EL3 Cold Reset Enable. With MDCR_EL3.E3BREW, controls branch recording at EL3.</p>
    <table class="valuetable"><tr><th>E3BREC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When MDCR_EL3.E3BREW == 0: Branch recording at EL3 is disabled.</p>
<p>When MDCR_EL3.E3BREW == 1: Branch recording at EL3 is enabled.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When MDCR_EL3.E3BREW == 0: Branch recording at EL3 is enabled.</p>
<p>When MDCR_EL3.E3BREW == 1: Branch recording at EL3 is disabled.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-38_38-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-37_37-1">E3BREW, bit [37]<span class="condition"><br/>When FEAT_BRBEv1p1 is implemented:
                        </span></h4><div class="field">
      <p>Branch Record Buffer EL3 Warm Reset Enable. With MDCR_EL3.E3BREC, controls branch recording at EL3.</p>
    
      <p>For a description of the values derived by evaluating MDCR_EL3.E3BREC and MDCR_EL3.E3BREW together, see MDCR_EL3.E3BREC.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-37_37-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-36_36-1">EnPMSN, bit [36]<span class="condition"><br/>When FEAT_SPEv1p2 is implemented:
                        </span></h4><div class="field">
      <p>Trap accesses to <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a>. Controls access to Statistical Profiling <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a> System register from EL2 and EL1.</p>
    <table class="valuetable"><tr><th>EnPMSN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses to <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a> at EL2 and EL1 generate a Trap exception to EL3.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Do not trap <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a> to EL3.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-36_36-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-35_35-1">MPMX, bit [35]<span class="condition"><br/>When FEAT_PMUv3p7 is implemented:
                        </span></h4><div class="field">
      <p>Monitor Performance Monitors Extended control. With MDCR_EL3.SPME, controls PMU operation at EL3.</p>
    <table class="valuetable"><tr><th>MPMX</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Counters are not affected by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Affected counters are prohibited from counting at EL3.</p>
<p>If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 1, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is disabled at EL3. Otherwise, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.</p></td></tr></table><p>The counters affected by this field are:</p>
<ul>
<li>If EL2 is implemented and MDCR_EL3.SPME is 1, event counters <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a> for values of n less than <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN.
</li><li>If EL2 is not implemented or MDCR_EL3.SPME is 0, all event counters.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, the instruction counter, <a href="AArch64-pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 1, the cycle counter, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>Other event counters are not affected by this field. When <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 0, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this field.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-35_35-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-34_34-1">MCCD, bit [34]<span class="condition"><br/>When FEAT_PMUv3p7 is implemented:
                        </span></h4><div class="field">
      <p>Monitor Cycle Counter Disable. Prohibits the Cycle Counter, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a>, from counting at EL3.</p>
    <table class="valuetable"><tr><th>MCCD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Cycle counting by <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Cycle counting by <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is prohibited at EL3.</p>
        </td></tr></table>
      <p>This field does not affect the CPU_CYCLES event or any other event that counts cycles.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-34_34-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-33_32-1">SBRBE, bits [33:32]<span class="condition"><br/>When FEAT_BRBE is implemented:
                        </span></h4><div class="field">
      <p>Secure Branch Record Buffer Enable. Controls branch recording by the BRBE, and access to BRBE registers and instructions at EL2 and EL1.</p>
    <table class="valuetable"><tr><th>SBRBE</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Direct accesses to BRBE registers and instructions, except when in EL3, generate a Trap exception to EL3. EL0, EL1, and EL2 are prohibited regions.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Direct accesses to BRBE registers and instructions in Secure state, except when in EL3, generate a Trap exception to EL3. EL0, EL1, and EL2 in Secure state are prohibited regions. This control does not cause any direct accesses to BRBE registers when not in Secure state to be trapped, and does not cause any Exception levels when not in Secure state to be a prohibited region.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Direct accesses to BRBE registers and instructions, except when in EL3, generate a Trap exception to EL3. This control does not cause any Exception levels to be prohibited regions.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>This control does not cause any direct accesses to BRBE registers or instruction to be trapped, and does not cause any Exception levels to be a prohibited region.</p>
        </td></tr></table><p>The Branch Record Buffer registers trapped by this control are: <a href="AArch64-brbcr_el1.html">BRBCR_EL1</a>, <a href="AArch64-brbcr_el2.html">BRBCR_EL2</a>, BRBCR_EL12, <a href="AArch64-brbfcr_el1.html">BRBFCR_EL1</a>, <a href="AArch64-brbidr0_el1.html">BRBIDR0_EL1</a>, <a href="AArch64-brbinfn_el1.html">BRBINF&lt;n&gt;_EL1</a>, <a href="AArch64-brbinfinj_el1.html">BRBINFINJ_EL1</a>, <a href="AArch64-brbsrcn_el1.html">BRBSRC&lt;n&gt;_EL1</a>, <a href="AArch64-brbsrcinj_el1.html">BRBSRCINJ_EL1</a>, <a href="AArch64-brbtgtn_el1.html">BRBTGT&lt;n&gt;_EL1</a>, <a href="AArch64-brbtgtinj_el1.html">BRBTGTINJ_EL1</a>, and <a href="AArch64-brbts_el1.html">BRBTS_EL1</a>.</p>
<p>The Branch Record Buffer instructions trapped by this control are:</p>
<ul>
<li><a href="AArch64-brb-iall.html">BRB IALL</a>.
</li><li><a href="AArch64-brb-inj.html">BRB INJ</a>.
</li></ul>
<div class="note"><span class="note-header">Note</span><p>If FEAT_BRBEv1p1 is not implemented, EL3 is a prohibited region.</p></div><p>If EL3 is not implemented then the Effective value of this field is <span class="binarynumber">0b11</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-33_32-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-31_30-1">PMSSE, bits [31:30]<span class="condition"><br/>When FEAT_PMUv3_SS is implemented:
                        </span></h4><div class="field">
      <p>Performance Monitors Snapshot Enable. Controls the generation of Capture events.</p>
    <table class="valuetable"><tr><th>PMSSE</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Capture events are disabled.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Capture events are controlled by <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.PMSSE.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Capture events are enabled and prohibited.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>Capture events are enabled and allowed.</p>
        </td></tr></table>
      <p>If EL3 is not implemented, then the Effective value of this field is <span class="binarynumber">0b01</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-31_30-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-29_29">Bit [29]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-28_28-1">MTPME, bit [28]<span class="condition"><br/>When FEAT_MTPMU is implemented:
                        </span></h4><div class="field">
      <p>Multi-threaded PMU Enable. Enables use of the <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0</a>.MT bits.</p>
    <table class="valuetable"><tr><th>MTPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p><span class="xref">FEAT_MTPMU</span> is disabled. The Effective value of <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0</a>.MT is zero.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p><a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0</a>.MT bits not affected by this field.</p>
        </td></tr></table>
      <p>If <span class="xref">FEAT_MTPMU</span> is disabled for any other PE in the system that has the same level 1 Affinity as the PE, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the PE behaves as if this field is 0.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to <span class="binarynumber">1</span>.
</li></ul></div><h4 id="fieldset_0-28_28-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-27_27-1">TDCC, bit [27]<span class="condition"><br/>When FEAT_FGT is implemented:
                        </span></h4><div class="field">
      <p>Trap DCC. Traps use of the Debug Comms Channel at EL2, EL1, and EL0 to EL3.</p>
    <table class="valuetable"><tr><th>TDCC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any register accesses to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Accesses to the DCC registers at EL2, EL1, and EL0 generate a Trap exception to EL3, unless the access also generates a higher priority exception.</p>
<p>Traps on the DCC data transfer registers are ignored when the PE is in Debug state.</p></td></tr></table><p>The DCC registers trapped by this control are:</p>
<p>AArch64: <a href="AArch64-osdtrrx_el1.html">OSDTRRX_EL1</a>, <a href="AArch64-osdtrtx_el1.html">OSDTRTX_EL1</a>, <a href="AArch64-mdccsr_el0.html">MDCCSR_EL0</a>, <a href="AArch64-mdccint_el1.html">MDCCINT_EL1</a>, and, when the PE is in Non-debug state, <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, and <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a>.</p>
<p>AArch32: <a href="AArch32-dbgdtrrxext.html">DBGDTRRXext</a>, <a href="AArch32-dbgdtrtxext.html">DBGDTRTXext</a>, <a href="AArch32-dbgdscrint.html">DBGDSCRint</a>, <a href="AArch32-dbgdccint.html">DBGDCCINT</a>, and, when the PE is in Non-debug state, <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.</p>
<p>The traps are reported with EC syndrome value:</p>
<ul>
<li><span class="hexnumber">0x05</span> for trapped AArch32 <span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses with coproc == <span class="binarynumber">0b1110</span>.
</li><li><span class="hexnumber">0x06</span> for trapped AArch32 <span class="instruction">LDC</span> to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> and <span class="instruction">STC</span> from <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a>.
</li><li><span class="hexnumber">0x18</span> for trapped AArch64 <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses.
</li></ul>
<p>When the PE is in Debug state, MDCR_EL3.TDCC does not trap any accesses to:</p>
<p>AArch64: <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>, <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a>, and <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a>.</p>
<p>AArch32: <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-27_27-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-26_26-1">NSTBE, bit [26]<span class="condition"><br/>When FEAT_TRBE is implemented and FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Non-secure Trace Buffer Extended. Together with MDCR_EL3.NSTB, controls the owning translation regime and accesses to Trace Buffer control registers from EL2 and EL1.</p>
    
      <p>For a description of the values derived by evaluating NSTB and NSTBE together, see MDCR_EL3.NSTB.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-26_26-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-25_24-1">NSTB, bits [25:24]<span class="condition"><br/>When FEAT_TRBE is implemented and FEAT_RME is implemented:
                        </span></h4><div class="field"><p>Non-secure Trace Buffer. Together with MDCR_EL3.NSTBE, controls the owning translation regime and accesses to Trace Buffer control registers from EL2 and EL1.</p>
<table class="valuetable"><thead><tr><th>NSTBE</th><th>NSTB</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b00</span></td><td>Secure state owns the Trace Buffer. When TraceBufferEnabled()==TRUE, tracing is prohibited in Realm and Non-secure states. Accesses to Trace Buffer control registers at EL2 and EL1 generate Trap exceptions to EL3. When Secure state is not implemented, this encoding is reserved.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b01</span></td><td>Secure state owns the Trace Buffer. When TraceBufferEnabled()==TRUE, tracing is prohibited in Realm and Non-secure states. Accesses to Trace Buffer control registers at Realm and Non-secure EL2, and Realm and Non-secure EL1, generate Trap exceptions to EL3. When Secure state is not implemented, this encoding is reserved.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b10</span></td><td>Non-secure state owns the Trace Buffer. When TraceBufferEnabled()==TRUE, tracing is prohibited in Secure and Realm states. Accesses to Trace Buffer control registers at EL2 and EL1 generate Trap exceptions to EL3.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b11</span></td><td>Non-secure state owns the Trace Buffer. When TraceBufferEnabled()==TRUE, tracing is prohibited in Secure and Realm states. Accesses to Trace Buffer control registers at Secure and Realm EL2, and Secure and Realm EL1, generate Trap exceptions to EL3.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b0x</span></td><td>Reserved</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b10</span></td><td>Realm state owns the Trace Buffer. When TraceBufferEnabled()==TRUE, tracing is prohibited in Secure and Non-secure states. Accesses to Trace Buffer control registers at EL2 and EL1 generate Trap exceptions to EL3.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b11</span></td><td>Realm state owns the Trace Buffer. When TraceBufferEnabled()==TRUE, tracing is prohibited in Secure and Non-secure states. Accesses to Trace Buffer control registers at Secure and Non-secure EL2, and Secure and Non-secure EL1, generate Trap exceptions to EL3.</td></tr></tbody></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li><span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-trbbaser_el1.html">TRBBASER_EL1</a>, <a href="AArch64-trblimitr_el1.html">TRBLIMITR_EL1</a>, <a href="AArch64-trbmar_el1.html">TRBMAR_EL1</a>, <a href="AArch64-trbptr_el1.html">TRBPTR_EL1</a>, <a href="AArch64-trbsr_el1.html">TRBSR_EL1</a>, and <a href="AArch64-trbtrg_el1.html">TRBTRG_EL1</a>.
</li><li>If <span class="xref">FEAT_TRBE_MPAM</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-trbmpam_el1.html">TRBMPAM_EL1</a>.
</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>If the Trace Buffer Unit is enabled and using Self-hosted mode, and MDCR_EL3.{NSTB, NSTBE} selects a reserved value, then the behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and the Trace Buffer Unit does one of:</p>
<ul>
<li>
<p>Behaves as if the Trace Buffer Unit is disabled.</p>

</li><li>
<p>Selects an implemented Security state as the owning Security state.</p>

</li><li>
<p>When trace data is received from the trace unit, it is not written to memory and the Trace Buffer Unit generates a Trace Buffer management event:</p>
<ul>
<li>
<p><a href="AArch64-trbsr_el1.html">TRBSR_EL1</a>.IRQ is set to 1.</p>

</li><li>
<p>If <a href="AArch64-trbsr_el1.html">TRBSR_EL1</a>.S is 0, then all of the following occur:</p>
<ul>
<li>
<p><a href="AArch64-trbsr_el1.html">TRBSR_EL1</a>.S is set to 1, Collection is stopped.</p>

</li><li>
<p><a href="AArch64-trbsr_el1.html">TRBSR_EL1</a>.EC is set to <span class="hexnumber">0x00</span>, other buffer management event.</p>

</li><li>
<p><a href="AArch64-trbsr_el1.html">TRBSR_EL1</a>.BSC is set to <span class="binarynumber">0b000000</span>, access not allowed.</p>

</li></ul>

</li><li>
<p>The other fields in <a href="AArch64-trbsr_el1.html">TRBSR_EL1</a> are unchanged.</p>

</li></ul>

</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_24-2"><span class="condition"><br/>When FEAT_TRBE is implemented:
                        </span></h4><div class="field">
      <p>Non-secure Trace Buffer. Controls the owning translation regime and accesses to Trace Buffer control registers from EL2 and EL1.</p>
    <table class="valuetable"><tr><th>NSTB</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Trace Buffer owning Security state is Secure state. 
If <span class="function">TraceBufferEnabled</span>() == TRUE, tracing is prohibited in Non-secure state.
Accesses to Trace Buffer control registers at EL2 and EL1  generate Trap exceptions to EL3.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Trace Buffer owning Security state is Secure state. 
If <span class="function">TraceBufferEnabled</span>() == TRUE, tracing is prohibited in Non-secure state.
Accesses to Trace Buffer control registers at EL2 and EL1 in Non-secure state generate Trap exceptions to EL3.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Trace Buffer owning Security state is Non-secure state. 
If <span class="function">TraceBufferEnabled</span>() == TRUE, tracing is prohibited in Secure state.
Accesses to Trace Buffer control registers at EL2 and EL1  generate Trap exceptions to EL3.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>Trace Buffer owning Security state is Non-secure state. 
If <span class="function">TraceBufferEnabled</span>() == TRUE, tracing is prohibited in Secure state.
Accesses to Trace Buffer control registers at EL2 and EL1 in Secure state generate Trap exceptions to EL3.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li><span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-trbbaser_el1.html">TRBBASER_EL1</a>, <a href="AArch64-trblimitr_el1.html">TRBLIMITR_EL1</a>, <a href="AArch64-trbmar_el1.html">TRBMAR_EL1</a>, <a href="AArch64-trbptr_el1.html">TRBPTR_EL1</a>, <a href="AArch64-trbsr_el1.html">TRBSR_EL1</a>, and <a href="AArch64-trbtrg_el1.html">TRBTRG_EL1</a>.
</li><li>If <span class="xref">FEAT_TRBE_MPAM</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-trbmpam_el1.html">TRBMPAM_EL1</a>.
</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is 1, then the Effective value of this field is <span class="binarynumber">0b11</span>.</p>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is 0, then the Effective value of this field is <span class="binarynumber">0b01</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_24-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-23_23-1">SCCD, bit [23]<span class="condition"><br/>When FEAT_PMUv3p5 is implemented:
                        </span></h4><div class="field">
      <p>Secure Cycle Counter Disable. Prohibits <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> from counting in Secure state.</p>
    <table class="valuetable"><tr><th>SCCD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Cycle counting by <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Cycle counting by <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is prohibited in Secure state.</p>
        </td></tr></table>
      <p>This field does not affect the CPU_CYCLES event or any other event that counts cycles.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-23_23-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-22_22-1">ETAD, bit [22]<span class="condition"><br/>When FEAT_RME is implemented, FEAT_TRC_EXT is implemented and FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>External Trace Access Disable. Together with MDCR_EL3.ETADE, controls access to trace unit registers by an external debugger.</p>
<table class="valuetable"><thead><tr><th>ETADE</th><th>ETAD</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b0</span></td><td>Access to trace unit registers by an external debugger is permitted.</td></tr><tr><td><span class="binarynumber">0b0</span>
</td><td><span class="binarynumber">0b1</span>
</td><td>Root and Secure access to trace unit registers by an external debugger is permitted.
Realm and Non-secure access to trace unit registers by an external debugger is not permitted.</td></tr><tr><td><span class="binarynumber">0b1</span>
</td><td><span class="binarynumber">0b0</span>
</td><td>Root and Realm access to trace unit registers by an external debugger is permitted.
Secure and Non-secure access to trace unit registers by an external debugger is not permitted.</td></tr><tr><td><span class="binarynumber">0b1</span>
</td><td><span class="binarynumber">0b1</span>
</td><td>Root access to trace unit registers by an external debugger is permitted.
Secure, Non-secure, and Realm access to trace unit registers by an external debugger is not permitted.</td></tr></tbody></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-22_22-2"><span class="condition"><br/>When FEAT_TRC_EXT is implemented and FEAT_TRBE is implemented:
                        </span></h4><div class="field">
      <p>External Trace Access Disable. Controls Non-secure access to trace unit registers by an external debugger.</p>
    <table class="valuetable"><tr><th>ETAD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Non-secure accesses from an external debugger to trace unit are allowed.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Non-secure accesses from an external debugger to some trace unit registers are prohibited. See individual registers for the effect of this field.</p>
        </td></tr></table>
      <p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is 0, then the Effective value of this field is 1.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-22_22-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-21_21-1">EPMAD, bit [21]<span class="condition"><br/>When FEAT_RME is implemented and FEAT_PMUv3_EXT is implemented:
                        </span></h4><div class="field"><p>External Performance Monitors Access Disable. Together with MDCR_EL3.EPMADE, controls access to Performance Monitor registers by an external debugger.</p>
<table class="valuetable"><thead><tr><th>EPMADE</th><th>EPMAD</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b0</span></td><td>Access to Performance Monitor registers by an external debugger is permitted.</td></tr><tr><td><span class="binarynumber">0b0</span>
</td><td><span class="binarynumber">0b1</span>
</td><td>Root and Secure access to Performance Monitor registers by an external debugger is permitted.
Realm and Non-secure access to Performance Monitor registers by an external debugger is not permitted.</td></tr><tr><td><span class="binarynumber">0b1</span>
</td><td><span class="binarynumber">0b0</span>
</td><td>Root and Realm access to Performance Monitor registers by an external debugger is permitted.
Secure and Non-secure access to Performance Monitor registers by an external debugger is not permitted.</td></tr><tr><td><span class="binarynumber">0b1</span>
</td><td><span class="binarynumber">0b1</span>
</td><td>Root access to Performance Monitor registers by an external debugger is permitted.
Secure, Non-secure, and Realm access to Performance Monitor registers by an external debugger is not permitted.</td></tr></tbody></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-21_21-2"><span class="condition"><br/>When FEAT_Debugv8p4 is implemented and FEAT_PMUv3_EXT is implemented:
                        </span></h4><div class="field">
      <p>External Performance Monitors Non-secure Access Disable. Controls Non-secure access to Performance Monitor registers by an external debugger.</p>
    <table class="valuetable"><tr><th>EPMAD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Non-secure access to Performance Monitor registers from external debugger is permitted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Non-secure access to Performance Monitor registers from external debugger is not permitted.</p>
        </td></tr></table>
      <p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is <span class="binarynumber">0b0</span>, then the Effective value of this bit is <span class="binarynumber">0b1</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-21_21-3"><span class="condition"><br/>When FEAT_PMUv3_EXT is implemented:
                        </span></h4><div class="field">
      <p>External Performance Monitors Access Disable. Controls access to Performance Monitor registers by an external debugger.</p>
    <table class="valuetable"><tr><th>EPMAD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Access to Performance Monitor registers from external debugger is permitted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Access to Performance Monitor registers from external debugger is not permitted, unless overridden by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
        </td></tr></table>
      <p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is <span class="binarynumber">0b0</span>, then the Effective value of this bit is <span class="binarynumber">0b1</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-21_21-4"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-20_20-1">EDAD, bit [20]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field"><p>External Debug Access Disable. Together with MDCR_EL3.EDADE, controls access to breakpoint registers, watchpoint registers, and <a href="ext-oslar_el1.html">OSLAR_EL1</a> by an external debugger.</p>
<table class="valuetable"><thead><tr><th>EDADE</th><th>EDAD</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b0</span></td><td>Access to Debug registers by an external debugger is permitted.</td></tr><tr><td><span class="binarynumber">0b0</span>
</td><td><span class="binarynumber">0b1</span>
</td><td>Root and Secure access to Debug registers by an external debugger is permitted.
Realm and Non-secure access to Debug registers by an external debugger is not permitted.</td></tr><tr><td><span class="binarynumber">0b1</span>
</td><td><span class="binarynumber">0b0</span>
</td><td>Root and Realm access to Debug registers by an external debugger is permitted.
Secure and Non-secure access to Debug registers by an external debugger is not permitted.</td></tr><tr><td><span class="binarynumber">0b1</span>
</td><td><span class="binarynumber">0b1</span>
</td><td>Root access to Debug registers by an external debugger is permitted.
Secure, Non-secure, and Realm access to Debug registers by an external debugger is not permitted.</td></tr></tbody></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-20_20-2"><span class="condition"><br/>When FEAT_Debugv8p4 is implemented:
                        </span></h4><div class="field">
      <p>External Debug Non-secure Access Disable. Controls Non-secure access to breakpoint, watchpoint, and <a href="ext-oslar_el1.html">OSLAR_EL1</a> registers by an external debugger.</p>
    <table class="valuetable"><tr><th>EDAD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Non-secure access to debug registers from external debugger is permitted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Non-secure access to breakpoint and watchpoint registers, and <a href="ext-oslar_el1.html">OSLAR_EL1</a> from external debugger is not permitted.</p>
        </td></tr></table>
      <p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is <span class="binarynumber">0b0</span>, then the Effective value of this field is <span class="binarynumber">0b1</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-20_20-3"><span class="condition"><br/>When FEAT_Debugv8p2 is implemented:
                        </span></h4><div class="field">
      <p>External Debug Access Disable. Controls access to breakpoint, watchpoint, and <a href="ext-oslar_el1.html">OSLAR_EL1</a> registers by an external debugger.</p>
    <table class="valuetable"><tr><th>EDAD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Access to debug registers, and to <a href="ext-oslar_el1.html">OSLAR_EL1</a> from external debugger is permitted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Access to breakpoint and watchpoint registers, and to <a href="ext-oslar_el1.html">OSLAR_EL1</a> from external debugger is not permitted, unless overridden by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
        </td></tr></table>
      <p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is <span class="binarynumber">0b0</span>, then the Effective value of this field is <span class="binarynumber">0b1</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-20_20-4"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>External Debug Access disable. Controls access to breakpoint, watchpoint, and optionally <a href="ext-oslar_el1.html">OSLAR_EL1</a> registers by an external debugger.</p>
    <table class="valuetable"><tr><th>EDAD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Access to debug registers from external debugger is permitted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Access to breakpoint and watchpoint registers from an external debugger is not permitted, unless overridden by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
<p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether access to the <a href="ext-oslar_el1.html">OSLAR_EL1</a> register from an external debugger is permitted or not permitted.</p></td></tr></table>
      <p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is <span class="binarynumber">0b0</span>, then the Effective value of this field is <span class="binarynumber">0b1</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-19_19-1">TTRF, bit [19]<span class="condition"><br/>When FEAT_TRF is implemented:
                        </span></h4><div class="field"><p>Trap Trace Filter controls. Traps use of the Trace Filter control registers at EL2 and EL1 to EL3.</p>
<p>The Trace Filter registers trapped by this control are:</p>
<ul>
<li>
<p><a href="AArch64-trfcr_el2.html">TRFCR_EL2</a>, TRFCR_EL12, <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a>, reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>

</li><li>
<p><a href="AArch32-htrfcr.html">HTRFCR</a> and <a href="AArch32-trfcr.html">TRFCR</a>, reported using EC syndrome value <span class="hexnumber">0x03</span>.</p>

</li></ul><table class="valuetable"><tr><th>TTRF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses to Trace Filter registers at EL2 and EL1 are not affected by this bit.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses to Trace Filter registers at EL2 and EL1 generate a Trap exception to EL3, unless the access generates a higher priority exception.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-19_19-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-18_18-1">STE, bit [18]<span class="condition"><br/>When FEAT_TRF is implemented and Secure state is implemented:
                        </span></h4><div class="field">
      <p>Secure Trace enable. Enables tracing in Secure state.</p>
    <table class="valuetable"><tr><th>STE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Trace prohibited in Secure state unless overridden by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Trace in Secure state is not affected by this bit.</p>
        </td></tr></table><p>This bit also controls the level of authentication required by an external debugger to enable external tracing. See <span class="xref">'Register controls to enable self-hosted trace'</span>.</p>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is <span class="binarynumber">0b0</span>, the Effective value of this bit is <span class="binarynumber">0b1</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-18_18-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-17_17-1">SPME, bit [17]<span class="condition"><br/>When FEAT_PMUv3 is implemented and FEAT_PMUv3p7 is implemented:
                        </span></h4><div class="field">
      <p>Secure Performance Monitors Enable. Controls PMU operation in Secure state and at EL3 when MDCR_EL3.MPMX is 0.</p>
    <table class="valuetable"><tr><th>SPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>When MDCR_EL3.MPMX == 0: Affected counters are prohibited from counting in Secure state and at EL3. If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 1, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is disabled in Secure state and at EL3. Otherwise, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>When MDCR_EL3.MPMX == 0: Counters are not affected by this mechanism.</p>
        </td></tr></table><p>When MDCR_EL3.MPMX is 0, the counters affected by this field are:</p>
<ul>
<li>All event counters.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, the instruction counter, <a href="AArch64-pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 1, the cycle counter, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>When <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 0, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this field.</p>
<p>When MDCR_EL3.MPMX is 1, this field controls which event counters are affected by MDCR_EL3.MPMX at EL3. See MDCR_EL3.MPMX for more information.</p>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is 0, then the Effective value of this field is 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-17_17-2"><span class="condition"><br/>When FEAT_PMUv3 is implemented and FEAT_Debugv8p2 is implemented:
                        </span></h4><div class="field">
      <p>Secure Performance Monitors Enable. Controls PMU operation in Secure state.</p>
    <table class="valuetable"><tr><th>SPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Event counting is prohibited in Secure state.</p>
<p>If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 1, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is disabled in Secure state. Otherwise, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Event counting and <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> are not affected by this mechanism.</p>
        </td></tr></table><p>The counters affected by this field are:</p>
<ul>
<li>All event counters.
</li><li>If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 1, the cycle counter, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>When <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 0, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this field.</p>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is 0, then the Effective value of this field is 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-17_17-3"><span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field">
      <p>Secure Performance Monitors Enable. Controls PMU operation in Secure state.</p>
    <table class="valuetable"><tr><th>SPME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If <span class="function">ExternalSecureNoninvasiveDebugEnabled</span>() is FALSE, then all the following apply:</p>
<ul>
<li>Event counting is prohibited in Secure state.
</li><li>If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 1, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is disabled in Secure state. Otherwise, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this mechanism.
</li></ul></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Event counting and <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> are not affected by this mechanism.</p>
        </td></tr></table><p>If <span class="function">ExternalSecureNoninvasiveDebugEnabled</span>() is TRUE then the event counters and <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> are not affected by this field.</p>
<p>Otherwise, the counters affected by this field are:</p>
<ul>
<li>All event counters.
</li><li>If <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 1, the cycle counter, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a>.
</li></ul>
<p>When <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.DP is 0, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> is not affected by this field.</p>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is 0, then the Effective value of this field is 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-17_17-4"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-16_16-1">SDD, bit [16]<span class="condition"><br/>When Secure state is implemented:
                        </span></h4><div class="field">
      <p>AArch64 Secure Self-hosted invasive debug disable. Disables Software debug exceptions in Secure state, other than Breakpoint Instruction exceptions.</p>
    <table class="valuetable"><tr><th>SDD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Debug exceptions in Secure state are not affected by this bit.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Debug exceptions, other than Breakpoint Instruction exceptions, are disabled from all Exception levels in Secure state.</p>
        </td></tr></table><p>The SDD bit is ignored unless both of the following are true:</p>
<ul>
<li>The PE is in Secure state.
</li><li>The Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.RW is <span class="binarynumber">0b1</span>.
</li></ul>
<p>If Secure EL2 is implemented and enabled, and Secure EL1 is using AArch32, then:</p>
<ul>
<li>If debug exceptions from Secure EL1 are enabled, debug exceptions from Secure EL0 are also enabled.
</li><li>Otherwise, debug exceptions from Secure EL0 are enabled only if the value of <a href="AArch64-sder32_el3.html">SDER32_EL3</a>.SUIDEN is <span class="binarynumber">0b1</span>.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-16_16-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-15_14-1">SPD32, bits [15:14]<span class="condition"><br/>When EL1 is capable of using AArch32:
                        </span></h4><div class="field">
      <p>AArch32 Secure self-hosted privileged debug. Enables or disables debug exceptions from Secure EL1 using AArch32, other than Breakpoint Instruction exceptions.</p>
    <table class="valuetable"><tr><th>SPD32</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Legacy mode. Debug exceptions from Secure EL1 are enabled by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Secure privileged debug disabled. Debug exceptions from Secure EL1 are disabled.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>Secure privileged debug enabled. Debug exceptions from Secure EL1 are enabled.</p>
        </td></tr></table><p>Other values are reserved, and have the <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> behavior that they must have the same behavior as <span class="binarynumber">0b00</span>. Software must not rely on this property as the behavior of reserved values might change in a future revision of the architecture.</p>
<p>This field has no effect on Breakpoint Instruction exceptions. These are always enabled.</p>
<p>This field is ignored unless both of the following are true:</p>
<ul>
<li>The PE is in Secure state.
</li><li>The Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.RW is <span class="binarynumber">0b0</span>.
</li></ul>
<p>If Secure EL1 is using AArch32, then:</p>
<ul>
<li>If debug exceptions from Secure EL1 are enabled, then debug exceptions from Secure EL0 are also enabled.
</li><li>Otherwise, debug exceptions from Secure EL0 are enabled only if the value of <a href="AArch64-sder32_el3.html">SDER32_EL3</a>.SUIDEN is <span class="binarynumber">0b1</span>.
</li></ul>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is <span class="binarynumber">0b0</span>, then the Effective value of this field is <span class="binarynumber">0b11</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-15_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-13_12-1">NSPB, bits [13:12]<span class="condition"><br/>When FEAT_SPE is implemented and FEAT_RME is implemented:
                        </span></h4><div class="field"><p>Non-secure Profiling Buffer. Together with MDCR_EL3.NSPBE, controls the owning translation regime and accesses to Statistical Profiling and Profiling Buffer control registers from EL2 and EL1.</p>
<table class="valuetable"><thead><tr><th>NSPBE</th><th>NSPB</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b00</span></td><td>The Profiling Buffer uses Secure virtual addresses. Statistical Profiling is disabled in Realm and Non-secure states. Accesses to Statistical Profiling and Profiling Buffer control registers at EL2 and EL1 generate Trap exceptions to EL3. When Secure state is not implemented, this encoding is reserved.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b01</span></td><td>The Profiling Buffer uses Secure virtual addresses. Statistical Profiling is disabled in Realm and Non-secure states. Accesses to Statistical Profiling and Profiling Buffer control registers at Realm and Non-secure EL2, and Realm and Non-secure EL1, generate Trap exceptions to EL3. When Secure state is not implemented, this encoding is reserved.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b10</span></td><td>The Profiling Buffer uses Non-secure virtual addresses. Statistical Profiling is disabled in Secure and Realm states. Accesses to Statistical Profiling and Profiling Buffer control registers at EL2 and EL1 generate Trap exceptions to EL3.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b11</span></td><td>The Profiling Buffer uses Non-secure virtual addresses. Statistical Profiling is disabled in Secure and Realm states. Accesses to Statistical Profiling and Profiling Buffer control registers at Secure and Realm EL2, and Secure and Realm EL1, generate Trap exceptions to EL3.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b0x</span></td><td>Reserved</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b10</span></td><td>The Profiling Buffer uses Realm virtual addresses. Statistical Profiling is disabled in Secure and Non-secure states. Accesses to Statistical Profiling and Profiling Buffer control registers at EL2 and EL1 generate Trap exceptions to EL3.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b11</span></td><td>The Profiling Buffer uses Realm virtual addresses. Statistical Profiling is disabled in Secure and Non-secure states. Accesses to Statistical Profiling and Profiling Buffer control registers at Secure and Non-secure EL2, and Secure and Non-secure EL1, generate Trap exceptions to EL3.</td></tr></tbody></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li><span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a>, <a href="AArch64-pmbptr_el1.html">PMBPTR_EL1</a>, <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>, <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a>, <a href="AArch64-pmscr_el2.html">PMSCR_EL2</a>, <a href="AArch64-pmscr_el1.html">PMSCR_EL12</a>, <a href="AArch64-pmsevfr_el1.html">PMSEVFR_EL1</a>, <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>, <a href="AArch64-pmsicr_el1.html">PMSICR_EL1</a>, <a href="AArch64-pmsirr_el1.html">PMSIRR_EL1</a>, and <a href="AArch64-pmslatfr_el1.html">PMSLATFR_EL1</a>.
</li><li><span class="instruction">MRS</span> accesses to <a href="AArch64-pmsidr_el1.html">PMSIDR_EL1</a>.
</li><li>If <span class="xref">FEAT_SPEv1p2</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a>.
</li><li>If <span class="xref">FEAT_SPE_FDS</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmsdsfr_el1.html">PMSDSFR_EL1</a>.
</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>If profiling is enabled and MDCR_EL3.{NSPB, NSPBE} selects a reserved value, then the behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and the Statistical Profiling Unit does one of:</p>
<ul>
<li>Behaves as if profiling is disabled.
</li><li>Selects an implemented Security state as the owning Security state.
</li><li>When profiling data is generated, it is not written to memory and the Statistical Profiling Unit generates a Profiling Buffer management event:<ul>
<li>If <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.S is 0, then all of the following occur:<ul>
<li><a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.S is set to 1.
</li><li><a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.DL is set to 1.
</li><li><a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.EC is set to <span class="binarynumber">0b000000</span>, other buffer management event.
</li><li><a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>.BSC is set to <span class="binarynumber">0b000000</span>, access not allowed.
</li></ul>

</li><li>The other fields in <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a> are unchanged.
</li></ul>

</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-13_12-2"><span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field">
      <p>Non-secure Profiling Buffer. Controls the owning translation regime and accesses to Statistical Profiling and Profiling Buffer control registers.</p>
    <table class="valuetable"><tr><th>NSPB</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td>
          <p>Profiling Buffer uses Secure Virtual Addresses.
Statistical Profiling enabled in Secure state and disabled in Non-secure state. 
Accesses to Statistical Profiling and Profiling Buffer control registers at EL2 and EL1 in Non-secure and Secure states generate Trap exceptions to EL3.</p>
        </td></tr><tr><td class="bitfield">0b01</td><td>
          <p>Profiling Buffer uses Secure Virtual Addresses.
Statistical Profiling enabled in Secure state and disabled in Non-secure state. 
Accesses to Statistical Profiling and Profiling Buffer control registers at EL2 and EL1 in Non-secure state generate Trap exceptions to EL3.</p>
        </td></tr><tr><td class="bitfield">0b10</td><td>
          <p>Profiling Buffer uses Non-secure Virtual Addresses.
Statistical Profiling enabled in Non-secure state and disabled in Secure state. 
Accesses to Statistical Profiling and Profiling Buffer control registers at EL2 and EL1 in Non-secure and Secure states generate Trap exceptions to EL3.</p>
        </td></tr><tr><td class="bitfield">0b11</td><td>
          <p>Profiling Buffer uses Non-secure Virtual Addresses.
Statistical Profiling enabled in Non-secure state and disabled in Secure state. 
Accesses to Statistical Profiling and Profiling Buffer control registers at EL2 and EL1 in Secure state generate Trap exceptions to EL3.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li><span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a>, <a href="AArch64-pmbptr_el1.html">PMBPTR_EL1</a>, <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a>, <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a>, <a href="AArch64-pmscr_el2.html">PMSCR_EL2</a>, <a href="AArch64-pmscr_el1.html">PMSCR_EL12</a>, <a href="AArch64-pmsevfr_el1.html">PMSEVFR_EL1</a>, <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a>, <a href="AArch64-pmsicr_el1.html">PMSICR_EL1</a>, <a href="AArch64-pmsirr_el1.html">PMSIRR_EL1</a>, and <a href="AArch64-pmslatfr_el1.html">PMSLATFR_EL1</a>.
</li><li><span class="instruction">MRS</span> accesses to <a href="AArch64-pmsidr_el1.html">PMSIDR_EL1</a>.
</li><li>If <span class="xref">FEAT_SPEv1p2</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a>.
</li><li>If <span class="xref">FEAT_SPE_FDS</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmsdsfr_el1.html">PMSDSFR_EL1</a>.
</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is 1, then the Effective value of this field is <span class="binarynumber">0b11</span>.</p>
<p>If EL3 is not implemented and the Effective value of <a href="AArch64-scr_el3.html">SCR_EL3</a>.NS is 0, then the Effective value of this field is <span class="binarynumber">0b01</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-13_12-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-11_11-1">NSPBE, bit [11]<span class="condition"><br/>When FEAT_SPE is implemented and FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Non-secure Profiling Buffer Extended. Together with MDCR_EL3.NSPB, controls the owning translation regime and accesses to Statistical Profiling and Profiling Buffer control registers from EL2 and EL1.</p>
    
      <p>For a description of the values derived by evaluating NSPB and NSPBE together, see MDCR_EL3.NSPB.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-11_11-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-10_10-1">TDOSA, bit [10]<span class="condition"><br/>When FEAT_DoubleLock is implemented:
                        </span></h4><div class="field"><p>Trap debug OS-related register access. Traps EL2 and EL1 System register accesses to the powerdown debug registers to EL3.</p>
<p>Accesses to the registers are trapped as follows:</p>
<ul>
<li>Accesses from AArch64 state, <a href="AArch64-oslar_el1.html">OSLAR_EL1</a>, <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>, <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a>, <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a>, and any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit, are trapped to EL3 and reported using EC syndrome value <span class="hexnumber">0x18</span>.
</li><li>Accesses using MCR or MRC to <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, <a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, <a href="AArch32-dbgosdlr.html">DBGOSDLR</a>, and <a href="AArch32-dbgprcr.html">DBGPRCR</a>, are trapped to EL3 and reported using EC syndrome value <span class="hexnumber">0x05</span>.
</li><li>Accesses to any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.
</li></ul><table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>EL2 and EL1 System register accesses to the powerdown debug registers are trapped to EL3, unless it is trapped by <a href="AArch32-hdcr.html">HDCR</a>.TDOSA or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDOSA.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>The powerdown debug registers are not accessible at EL0.</p>
      </div>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-10_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Trap debug OS-related register access. Traps EL2 and EL1 System register accesses to the powerdown debug registers to EL3.</p>
<p>The following registers are affected by this trap:</p>
<ul>
<li>AArch64: <a href="AArch64-oslar_el1.html">OSLAR_EL1</a>, <a href="AArch64-oslsr_el1.html">OSLSR_EL1</a>, and <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a>.
</li><li>AArch32: <a href="AArch32-dbgoslar.html">DBGOSLAR</a>, <a href="AArch32-dbgoslsr.html">DBGOSLSR</a>, and <a href="AArch32-dbgprcr.html">DBGPRCR</a>.
</li><li>AArch64 and AArch32: Any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> register with similar functionality that the implementation specifies as trapped by this bit.
</li><li>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether accesses to <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a> and <a href="AArch32-dbgosdlr.html">DBGOSDLR</a> are trapped.
</li></ul><table class="valuetable"><tr><th>TDOSA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>EL2 and EL1 System register accesses to the powerdown debug registers are trapped to EL3, unless it is trapped by <a href="AArch32-hdcr.html">HDCR</a>.TDOSA or <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDOSA.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>The powerdown debug registers are not accessible at EL0.</p>
      </div>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-9_9">TDA, bit [9]</h4><div class="field">
      <p>Trap accesses of debug System registers. Enables a trap to EL3 on accesses of debug System registers.</p>
    <table class="valuetable"><tr><th>TDA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses of the specified debug System registers are not trapped by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified debug System registers at EL2, EL1, and EL0 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li><span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-dbgauthstatus_el1.html">DBGAUTHSTATUS_EL1</a>, <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n&gt;_EL1</a>, <a href="AArch64-dbgbvrn_el1.html">DBGBVR&lt;n&gt;_EL1</a>, <a href="AArch64-dbgclaimclr_el1.html">DBGCLAIMCLR_EL1</a>, <a href="AArch64-dbgclaimset_el1.html">DBGCLAIMSET_EL1</a>, <a href="AArch64-dbgvcr32_el2.html">DBGVCR32_EL2</a>, <a href="AArch64-dbgwcrn_el1.html">DBGWCR&lt;n&gt;_EL1</a>, <a href="AArch64-dbgwvrn_el1.html">DBGWVR&lt;n&gt;_EL1</a>, <a href="AArch64-mdccint_el1.html">MDCCINT_EL1</a>, <a href="AArch64-mdccsr_el0.html">MDCCSR_EL0</a>, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>, <a href="AArch64-mdrar_el1.html">MDRAR_EL1</a>, <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>, <a href="AArch64-osdtrrx_el1.html">OSDTRRX_EL1</a>, <a href="AArch64-osdtrtx_el1.html">OSDTRTX_EL1</a>, and <a href="AArch64-oseccr_el1.html">OSECCR_EL1</a>.
</li><li>If <span class="xref">FEAT_Debugv8p9</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a>.
</li><li>In Non-debug state, <span class="instruction">MRS</span> accesses to <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a> and <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a> and <span class="instruction">MSR</span> accesses to <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a> and <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>.
</li></ul>
<p>In AArch32 state, the instructions affected by this control are:</p>
<ul>
<li>
<p><span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses to <a href="AArch32-dbgauthstatus.html">DBGAUTHSTATUS</a>, <a href="AArch32-dbgbcrn.html">DBGBCR&lt;n&gt;</a>, <a href="AArch32-dbgbvrn.html">DBGBVR&lt;n&gt;</a>, <a href="AArch32-dbgbxvrn.html">DBGBXVR&lt;n&gt;</a>, <a href="AArch32-dbgclaimclr.html">DBGCLAIMCLR</a>, <a href="AArch32-dbgclaimset.html">DBGCLAIMSET</a>, <a href="AArch32-dbgdccint.html">DBGDCCINT</a>, <a href="AArch32-dbgdevid.html">DBGDEVID</a>, <a href="AArch32-dbgdevid1.html">DBGDEVID1</a>, <a href="AArch32-dbgdevid2.html">DBGDEVID2</a>, <a href="AArch32-dbgdidr.html">DBGDIDR</a>, <a href="AArch32-dbgdrar.html">DBGDRAR</a>, <a href="AArch32-dbgdsar.html">DBGDSAR</a>, <a href="AArch32-dbgdscrext.html">DBGDSCRext</a>, <a href="AArch32-dbgdscrint.html">DBGDSCRint</a>, <a href="AArch32-dbgdtrrxext.html">DBGDTRRXext</a>, <a href="AArch32-dbgdtrtxext.html">DBGDTRTXext</a>, <a href="AArch32-dbgoseccr.html">DBGOSECCR</a>, <a href="AArch32-dbgvcr.html">DBGVCR</a>, <a href="AArch32-dbgwcrn.html">DBGWCR&lt;n&gt;</a>, <a href="AArch32-dbgwfar.html">DBGWFAR</a>, <a href="AArch32-dbgwvrn.html">DBGWVR&lt;n&gt;</a>, <a href="AArch32-hdcr.html">HDCR</a>, and <a href="AArch32-sder.html">SDER</a>.</p>

</li><li>
<p><span class="instruction">MRRC</span> accesses to <a href="AArch32-dbgdrar.html">DBGDRAR</a> and <a href="AArch32-dbgdsar.html">DBGDSAR</a>.</p>

</li><li>
<p><span class="instruction">STC</span> accesses to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <span class="instruction">LDC</span> accesses to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.</p>

</li><li>
<p>In Non-debug state, <span class="instruction">MRC</span> accesses to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <span class="instruction">MCR</span> accesses to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.</p>

</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped AArch64 instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>Trapped AArch32 instructions are reported using EC syndrome value <span class="hexnumber">0x03</span> for <span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses with coproc == <span class="binarynumber">0b1111</span>, <span class="hexnumber">0x05</span> for <span class="instruction">MCR</span> and <span class="instruction">MCR</span> accesses with coproc == <span class="binarynumber">0b1110</span>, <span class="hexnumber">0x06</span> for <span class="instruction">LDC</span> and <span class="instruction">STC</span> accesses, and <span class="hexnumber">0x0C</span> for <span class="instruction">MRRC</span> accesses.</p>
<p>The following instructions are not trapped in Debug state:</p>
<ul>
<li>AArch64 <span class="instruction">MRS</span> accesses to <a href="AArch64-dbgdtrrx_el0.html">DBGDTRRX_EL0</a> and <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a> and <span class="instruction">MSR</span> accesses to <a href="AArch64-dbgdtrtx_el0.html">DBGDTRTX_EL0</a> and <a href="AArch64-dbgdtr_el0.html">DBGDTR_EL0</a>.
</li><li>AArch32 <span class="instruction">MRC</span> accesses to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> and <span class="instruction">MCR</span> accesses to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.
</li></ul>
<p>If 16 or fewer breakpoints and 16 or fewer watchpoints are implemented, and <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a> is implemented as RAZ/WI, then it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether AArch64 accesses to <a href="AArch64-mdselr_el1.html">MDSELR_EL1</a> are trapped to EL3 when MDCR_EL3.TDA is 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-8_8">Bit [8]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-7_7-1">EnPM2, bit [7]<span class="condition"><br/>When FEAT_PMUv3p9 is implemented, or FEAT_SPMU is implemented, or FEAT_EBEP is implemented or FEAT_PMUv3_SS is implemented:
                        </span></h4><div class="field">
      <p>Enable access to PMU registers. When disabled, accesses to PMU registers generate a trap to EL3.</p>
    <table class="valuetable"><tr><th>EnPM2</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Accesses of the specified PMU registers at EL2, EL1, and EL0 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
<p>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, then:</p>
<ul>
<li>
<p><a href="AArch64-pmcntenclr_el0.html">PMCNTENCLR_EL0</a>.F, <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>.F, <a href="AArch64-pmovsclr_el0.html">PMOVSCLR_EL0</a>.F, <a href="AArch64-pmovsset_el0.html">PMOVSSET_EL0</a>.F, and <a href="AArch64-pmzr_el0.html">PMZR_EL0</a>.F read-as-zero and ignore writes at EL2, EL1, and EL0.</p>

</li><li>
<p><a href="AArch64-pmintenclr_el1.html">PMINTENCLR_EL1</a>.F and <a href="AArch64-pmintenset_el1.html">PMINTENSET_EL1</a>.F read-as-zero and ignore writes at EL2 and EL1.</p>

</li></ul></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified PMU registers are not trapped by this mechanism.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li>If FEAT_EBEP is implemented or <span class="xref">FEAT_PMUv3_SS</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmecr_el1.html">PMECR_EL1</a>.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmicfiltr_el0.html">PMICFILTR_EL0</a> and <a href="AArch64-pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>If <span class="xref">FEAT_PMUv3p9</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmuacr_el1.html">PMUACR_EL1</a>.
</li><li>If <span class="xref">FEAT_SEBEP</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmiar_el1.html">PMIAR_EL1</a>.
</li><li>If <span class="xref">FEAT_SPMU</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-spmaccessr_el1.html">SPMACCESSR_EL1</a>, <a href="AArch64-spmaccessr_el2.html">SPMACCESSR_EL2</a>, SPMACCESSR_EL12, <a href="AArch64-spmcfgr_el1.html">SPMCFGR_EL1</a>, <a href="AArch64-spmcgcrn_el1.html">SPMCGCR&lt;n&gt;_EL1</a>, <a href="AArch64-spmcntenclr_el0.html">SPMCNTENCLR_EL0</a>, <a href="AArch64-spmcntenset_el0.html">SPMCNTENSET_EL0</a>, <a href="AArch64-spmcr_el0.html">SPMCR_EL0</a>, <a href="AArch64-spmdevaff_el1.html">SPMDEVAFF_EL1</a>, <a href="AArch64-spmdevarch_el1.html">SPMDEVARCH_EL1</a>, <a href="AArch64-spmevcntrn_el0.html">SPMEVCNTR&lt;n&gt;_EL0</a>, <a href="AArch64-spmevfilt2rn_el0.html">SPMEVFILT2R&lt;n&gt;_EL0</a>, <a href="AArch64-spmevfiltrn_el0.html">SPMEVFILTR&lt;n&gt;_EL0</a>, <a href="AArch64-spmevtypern_el0.html">SPMEVTYPER&lt;n&gt;_EL0</a>, <a href="AArch64-spmiidr_el1.html">SPMIIDR_EL1</a>, <a href="AArch64-spmintenclr_el1.html">SPMINTENCLR_EL1</a>, <a href="AArch64-spmintenset_el1.html">SPMINTENSET_EL1</a>, <a href="AArch64-spmovsclr_el0.html">SPMOVSCLR_EL0</a>, <a href="AArch64-spmovsset_el0.html">SPMOVSSET_EL0</a>, <a href="AArch64-spmscr_el1.html">SPMSCR_EL1</a>, and <a href="AArch64-spmselr_el0.html">SPMSELR_EL0</a>.
</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_7-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-6_6-1">TPM, bit [6]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field">
      <p>Trap accesses of PMU registers. Enables a trap to EL3 on accesses of PMU registers.</p>
    <table class="valuetable"><tr><th>TPM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses of the specified PMU registers are not trapped by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified PMU registers at EL2, EL1, and EL0 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li><span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmccfiltr_el0.html">PMCCFILTR_EL0</a>, <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a>, <a href="AArch64-pmcntenclr_el0.html">PMCNTENCLR_EL0</a>, <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>, <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>, <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n&gt;_EL0</a>, <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n&gt;_EL0</a>, <a href="AArch64-pmintenclr_el1.html">PMINTENCLR_EL1</a>, <a href="AArch64-pmintenset_el1.html">PMINTENSET_EL1</a>, <a href="AArch64-pmovsclr_el0.html">PMOVSCLR_EL0</a>, <a href="AArch64-pmovsset_el0.html">PMOVSSET_EL0</a>, <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>, <a href="AArch64-pmswinc_el0.html">PMSWINC_EL0</a>, <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>, <a href="AArch64-pmxevcntr_el0.html">PMXEVCNTR_EL0</a>, and <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a>.
</li><li><span class="instruction">MRS</span> accesses to <a href="AArch64-pmceid0_el0.html">PMCEID0_EL0</a> and <a href="AArch64-pmceid1_el0.html">PMCEID1_EL0</a>.
</li><li>If <span class="xref">FEAT_PMUv3p4</span> is implemented, <span class="instruction">MRS</span> accesses to <a href="AArch64-pmmir_el1.html">PMMIR_EL1</a>.
</li><li>If <span class="xref">FEAT_PMUv3p9</span> is implemented, <span class="instruction">MSR</span> accesses to <a href="AArch64-pmzr_el0.html">PMZR_EL0</a>.
</li><li>If <span class="xref">FEAT_PMUv3_ICNTR</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmicfiltr_el0.html">PMICFILTR_EL0</a> and <a href="AArch64-pmicntr_el0.html">PMICNTR_EL0</a>.
</li><li>If FEAT_EBEP is implemented or <span class="xref">FEAT_PMUv3_SS</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmecr_el1.html">PMECR_EL1</a>.
</li><li>If <span class="xref">FEAT_SEBEP</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pmiar_el1.html">PMIAR_EL1</a>.
</li></ul>
<p>In AArch32 state, the instructions affected by this control are:</p>
<ul>
<li>
<p><span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses to <a href="AArch32-pmccfiltr.html">PMCCFILTR</a>, <a href="AArch32-pmccntr.html">PMCCNTR</a>, <a href="AArch32-pmceid0.html">PMCEID0</a>, <a href="AArch32-pmceid1.html">PMCEID1</a>, <a href="AArch32-pmcntenclr.html">PMCNTENCLR</a>, <a href="AArch32-pmcntenset.html">PMCNTENSET</a>, <a href="AArch32-pmcr.html">PMCR</a>, <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n&gt;</a>, <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n&gt;</a>, <a href="AArch32-pmintenclr.html">PMINTENCLR</a>, <a href="AArch32-pmintenset.html">PMINTENSET</a>, <a href="AArch32-pmovsr.html">PMOVSR</a>, <a href="AArch32-pmovsset.html">PMOVSSET</a>, <a href="AArch32-pmselr.html">PMSELR</a>, <a href="AArch32-pmswinc.html">PMSWINC</a>, <a href="AArch32-pmuserenr.html">PMUSERENR</a>, <a href="AArch32-pmxevcntr.html">PMXEVCNTR</a>, and <a href="AArch32-pmxevtyper.html">PMXEVTYPER</a>.</p>

</li><li>
<p><span class="instruction">MRRC</span> and <span class="instruction">MCRR</span> accesses to <a href="AArch32-pmccntr.html">PMCCNTR</a>.</p>

</li><li>
<p>If <span class="xref">FEAT_PMUv3p1</span> is implemented, <span class="instruction">MRC</span> accesses to <a href="AArch32-pmceid2.html">PMCEID2</a> and <a href="AArch32-pmceid3.html">PMCEID3</a>.</p>

</li><li>
<p>If <span class="xref">FEAT_PMUv3p4</span> is implemented, <span class="instruction">MRC</span> accesses to <a href="AArch32-pmmir.html">PMMIR</a>.</p>

</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped AArch64 instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>Trapped AArch32 instructions are reported using EC syndrome value <span class="hexnumber">0x03</span> for <span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses, and <span class="hexnumber">0x04</span> for <span class="instruction">MRRC</span> and <span class="instruction">MCRR</span> accesses.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-5_5">Bit [5]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-4_4-1">EDADE, bit [4]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field"><p>External Debug Access Disable Extended. Together with MDCR_EL3.EDAD, controls access to breakpoint registers, watchpoint registers, and <a href="ext-oslar_el1.html">OSLAR_EL1</a> by an external debugger.</p>
<p>For a description of the values derived by evaluating EDAD and EDADE together, see MDCR_EL3.EDAD.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-4_4-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-3_3-1">ETADE, bit [3]<span class="condition"><br/>When FEAT_RME is implemented, FEAT_TRC_EXT is implemented and FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>External Trace Access Disable Extended. Together with MDCR_EL3.ETAD, controls access to trace unit registers by an external debugger.</p>
<p>For a description of the values derived by evaluating ETAD and ETADE together, see MDCR_EL3.ETAD.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-3_3-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-2_2-1">EPMADE, bit [2]<span class="condition"><br/>When FEAT_RME is implemented and FEAT_PMUv3_EXT is implemented:
                        </span></h4><div class="field"><p>External Performance Monitors Access Disable Extended. Together with MDCR_EL3.EPMAD, controls access to Performance Monitor registers by an external debugger.</p>
<p>For a description of the values derived by evaluating EPMAD and EPMADE together, see MDCR_EL3.EPMAD.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-2_2-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-1_1">Bit [1]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-0_0-1">RLTE, bit [0]<span class="condition"><br/>When FEAT_RME is implemented and FEAT_TRF is implemented:
                        </span></h4><div class="field">
      <p>Realm Trace enable. Enables tracing in Realm state.</p>
    <table class="valuetable"><tr><th>RLTE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Trace prohibited in Realm state, unless overridden by the <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> authentication interface.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Trace in Realm state is not affected by this bit.</p>
        </td></tr></table>
      <p>This bit also controls the level of authentication that is required by an external debugger to enable external tracing.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-0_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><div class="access_mechanisms"><h2>Accessing MDCR_EL3</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt&gt;, MDCR_EL3</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0001</td><td>0b0011</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    X[t, 64] = MDCR_EL3;
                </p><h4 class="assembler">MSR MDCR_EL3, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0001</td><td>0b0011</td><td>0b001</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    MDCR_EL3 = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:07; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright  2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
