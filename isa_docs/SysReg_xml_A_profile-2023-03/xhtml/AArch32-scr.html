<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>SCR</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">SCR, Secure Configuration Register</h1><p>The SCR characteristics are:</p><h2>Purpose</h2>
        <p>When EL3 is implemented and can use AArch32, defines the configuration of the current Security state. It specifies:</p>

      
        <ul>
<li>The Security state, either Secure or Non-secure.
</li><li>What mode the PE branches to if an IRQ, FIQ, or External abort occurs.
</li><li>Whether the PSTATE.F or PSTATE.A bits can be modified when SCR.NS==1.
</li></ul>
      <h2>Configuration</h2><p>This register is present only when EL3 is capable of using AArch32. Otherwise, direct accesses to SCR are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>SCR is a 32-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_0-31_16">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-15_15-1">TERR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-14_14">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-13_13">TWE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-12_12">TWI</a></td><td class="lr" colspan="2"><a href="#fieldset_0-11_10">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9">SIF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8">HCE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7">SCD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6">nET</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5">AW</a></td><td class="lr" colspan="1"><a href="#fieldset_0-4_4">FW</a></td><td class="lr" colspan="1"><a href="#fieldset_0-3_3">EA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2">FIQ</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">IRQ</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">NS</a></td></tr></tbody></table><h4 id="fieldset_0-31_16">Bits [31:16]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-15_15-1">TERR, bit [15]<span class="condition"><br/>When FEAT_RAS is implemented:
                        </span></h4><div class="field"><p>Trap Error record accesses. Generate a Monitor Trap exception on accesses to the following registers from modes other than Monitor mode:</p>
<p><a href="AArch32-erridr.html">ERRIDR</a>, <a href="AArch32-errselr.html">ERRSELR</a>, <a href="AArch32-erxaddr.html">ERXADDR</a>, <a href="AArch32-erxaddr2.html">ERXADDR2</a>, <a href="AArch32-erxctlr.html">ERXCTLR</a>, <a href="AArch32-erxctlr2.html">ERXCTLR2</a>, <a href="AArch32-erxfr.html">ERXFR</a>, <a href="AArch32-erxfr2.html">ERXFR2</a>, <a href="AArch32-erxmisc0.html">ERXMISC0</a>, <a href="AArch32-erxmisc1.html">ERXMISC1</a>, <a href="AArch32-erxmisc2.html">ERXMISC2</a>, <a href="AArch32-erxmisc3.html">ERXMISC3</a>, and <a href="AArch32-erxstatus.html">ERXSTATUS</a>. When <span class="xref">FEAT_RASv1p1</span> is implemented, <a href="AArch32-erxmisc4.html">ERXMISC4</a>, <a href="AArch32-erxmisc5.html">ERXMISC5</a>, <a href="AArch32-erxmisc6.html">ERXMISC6</a>, <a href="AArch32-erxmisc7.html">ERXMISC7</a>.</p><table class="valuetable"><tr><th>TERR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses to the specified registers from modes other than Monitor mode generate a Monitor Trap exception.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-15_15-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-14_14">Bit [14]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-13_13">TWE, bit [13]</h4><div class="field">
      <p>Traps WFE instructions to Monitor mode.</p>
    <table class="valuetable"><tr><th>TWE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute a WFE instruction in any mode other than Monitor mode is trapped to Monitor mode, if the instruction would otherwise have caused the PE to enter a low-power state and the attempted execution does not generate an exception that is taken to EL1 or EL2 by <a href="AArch32-sctlr.html">SCTLR</a>.nTWE or <a href="AArch32-hcr.html">HCR</a>.TWE.</p>
<p>Any exception that is taken to EL1 or to EL2 has priority over this trap.</p></td></tr></table><p>The attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p>
<div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-12_12">TWI, bit [12]</h4><div class="field">
      <p>Traps WFI instructions to Monitor mode.</p>
    <table class="valuetable"><tr><th>TWI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>Any attempt to execute a WFI instruction in any mode other than Monitor mode is trapped to Monitor mode, if the instruction would otherwise have caused the PE to enter a low-power state and the attempted execution does not generate an exception that is taken to EL1 or EL2 by <a href="AArch32-sctlr.html">SCTLR</a>.nTWI or <a href="AArch32-hcr.html">HCR</a>.TWI.</p>
<p>Any exception that is taken to EL1 or to EL2 has priority over this trap.</p></td></tr></table><p>The attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p>
<div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-11_10">Bits [11:10]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-9_9">SIF, bit [9]</h4><div class="field">
      <p>Secure instruction fetch. When the PE is in Secure state, this bit disables instruction execution from Non-secure memory.</p>
    <table class="valuetable"><tr><th>SIF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Secure state instruction execution from Non-secure memory is permitted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Secure state instruction execution from Non-secure memory is not permitted.</p>
        </td></tr></table>
      <p>This bit is permitted to be cached in a TLB.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-8_8">HCE, bit [8]</h4><div class="field">
      <p>Hypervisor Call instruction enable. If EL2 is implemented, enables execution of HVC instructions at Non-secure EL1 and EL2.</p>
    <table class="valuetable"><tr><th>HCE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>HVC instructions are:</p>
<ul>
<li><span class="arm-defined-word">UNDEFINED</span> at Non-secure EL1. The Undefined Instruction exception is taken from PL1 to PL1.
</li><li><span class="arm-defined-word">UNPREDICTABLE</span> at EL2. Behavior is one of the following:<ul>
<li>The instruction is <span class="arm-defined-word">UNDEFINED</span>.
</li><li>The instruction executes as a NOP.
</li></ul>

</li></ul></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>HVC instructions are enabled at Non-secure EL1 and EL2.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>HVC instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0 and in Secure state.</p>
      </div>
      <p>If EL2 is not implemented, this bit is <span class="arm-defined-word">RES0</span> and HVC is <span class="arm-defined-word">UNDEFINED</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-7_7">SCD, bit [7]</h4><div class="field">
      <p>Secure Monitor Call disable. Disables SMC instructions.</p>
    <table class="valuetable"><tr><th>SCD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>SMC instructions are enabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>In Non-secure state, SMC instructions are <span class="arm-defined-word">UNDEFINED</span>. The Undefined Instruction exception is taken from the current Exception level to the current Exception level.</p>
<p>In Secure state, behavior is one of the following:</p>
<ul>
<li>The instruction is <span class="arm-defined-word">UNDEFINED</span>.
</li><li>The instruction executes as a NOP.
</li></ul></td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>SMC instructions are always <span class="arm-defined-word">UNDEFINED</span> at PL0.</p>
      </div>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-6_6">nET, bit [6]</h4><div class="field">
      <p>Not Early Termination. This bit disables early termination.</p>
    <table class="valuetable"><tr><th>nET</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Early termination permitted. Execution time of data operations can depend on the data values.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Disable early termination. The number of cycles required for data operations is forced to be independent of the data values.</p>
        </td></tr></table><p>This <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> mechanism can disable data dependent timing optimizations from multiplies and data operations. It can provide system support against information leakage that might be exploited by timing correlation types of attack.</p>
<p>On implementations that do not support early termination or do not support disabling early termination, this bit is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-5_5">AW, bit [5]</h4><div class="field">
      <p>When the value of SCR.EA is 1 and the value of <a href="AArch32-hcr.html">HCR</a>.AMO is 0, this bit controls whether PSTATE.A masks an External abort taken from Non-secure state.</p>
    <table class="valuetable"><tr><th>AW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>External aborts taken from Non-secure state are not masked by PSTATE.A, and are taken to EL3.</p>
<p>External aborts taken from Secure state are masked by PSTATE.A.</p></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>External aborts taken from either Security state are masked by PSTATE.A. When PSTATE.A is 0, the abort is taken to EL3.</p>
        </td></tr></table>
      <p>When SCR.EA is 0 or <a href="AArch32-hcr.html">HCR</a>.AMO is 1, this bit has no effect.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-4_4">FW, bit [4]</h4><div class="field">
      <p>When the value of SCR.FIQ is 1 and the value of <a href="AArch32-hcr.html">HCR</a>.FMO is 0, this bit controls whether PSTATE.F masks an FIQ interrupt taken from Non-secure state.</p>
    <table class="valuetable"><tr><th>FW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>An FIQ taken from Non-secure state is not masked by PSTATE.F, and is taken to EL3.</p>
<p>An FIQ taken from Secure state is masked by PSTATE.F.</p></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>An FIQ taken from either Security state is masked by PSTATE.F. When PSTATE.F is 0, the FIQ is taken to EL3.</p>
        </td></tr></table>
      <p>When SCR.FIQ is 0 or <a href="AArch32-hcr.html">HCR</a>.FMO is 1, this bit has no effect.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-3_3">EA, bit [3]</h4><div class="field">
      <p>External Abort handler. This bit controls which mode takes External aborts and SError interrupt exceptions.</p>
    <table class="valuetable"><tr><th>EA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>External aborts taken to Abort mode.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>External aborts taken to Monitor mode.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-2_2">FIQ, bit [2]</h4><div class="field">
      <p>FIQ handler. This bit controls which mode takes FIQ exceptions.</p>
    <table class="valuetable"><tr><th>FIQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>FIQs taken to FIQ mode.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>FIQs taken to Monitor mode.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-1_1">IRQ, bit [1]</h4><div class="field">
      <p>IRQ handler. This bit controls which mode takes IRQ exceptions.</p>
    <table class="valuetable"><tr><th>IRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>IRQs taken to IRQ mode.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>IRQs taken to Monitor mode.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-0_0">NS, bit [0]</h4><div class="field">
      <p>Non-secure bit. Except when the PE is in Monitor mode, this bit determines the Security state of the PE:</p>
    <table class="valuetable"><tr><th>NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>PE is in Secure state.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>PE is in Non-secure state.</p>
        </td></tr></table>
      <p>If the <a href="AArch32-hcr.html">HCR</a>.TGE bit is set, an attempt to change from a Secure PL1 mode to a Non-secure EL1 mode by changing the SCR.NS bit from 0 to 1 results in the SCR.NS bit remaining as 0.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL3, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><div class="access_mechanisms"><h2>Accessing SCR</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif !ELUsingAArch32(EL2) &amp;&amp; SCR_EL3.&lt;NS,EEL2&gt; == '01' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    R[t] = SCR;
                </p><h4 class="assembler">MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif !ELUsingAArch32(EL2) &amp;&amp; SCR_EL3.&lt;NS,EEL2&gt; == '01' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif !ELUsingAArch32(EL3) &amp;&amp; SCR_EL3.NS == '0' then
        AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    SCR = R[t];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:06; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
