<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>ICC_SRE</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">ICC_SRE, Interrupt Controller System Register Enable register</h1><p>The ICC_SRE characteristics are:</p><h2>Purpose</h2>
        <p>Controls whether the System register interface or the memory-mapped interface to the GIC CPU interface is used for EL0 and EL1.</p>
      <h2>Configuration</h2><p>This register is banked between ICC_SRE and ICC_SRE_S and ICC_SRE_NS.<br/></p><p>AArch32 System register ICC_SRE bits [31:0] (ICC_SRE_S) are architecturally mapped to AArch64 System register <a href="AArch64-icc_sre_el1.html">ICC_SRE_EL1[31:0]</a> (ICC_SRE_EL1_S).</p><p>AArch32 System register ICC_SRE bits [31:0] (ICC_SRE_NS) are architecturally mapped to AArch64 System register <a href="AArch64-icc_sre_el1.html">ICC_SRE_EL1[31:0]</a> (ICC_SRE_EL1_NS).</p><p>This register is present only when EL1 is capable of using AArch32 and FEAT_GICv3 is implemented. Otherwise, direct accesses to ICC_SRE are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>ICC_SRE is a 32-bit register.</p>

      
        <p>This register has the following instances:</p>

      
        <ul>
<li>ICC_SRE, when EL3 is not implemented
</li><li>ICC_SRE_S, when EL3 is implemented
</li><li>ICC_SRE_NS, when EL3 is implemented
</li></ul>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="29"><a href="#fieldset_0-31_3">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2">DIB</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">DFB</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">SRE</a></td></tr></tbody></table><h4 id="fieldset_0-31_3">Bits [31:3]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-2_2">DIB, bit [2]</h4><div class="field">
      <p>Disable IRQ bypass.</p>
    <table class="valuetable"><tr><th>DIB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>IRQ bypass enabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>IRQ bypass disabled.</p>
        </td></tr></table><p>If EL3 is implemented and <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 0, this field is a read-only alias of <a href="AArch32-icc_msre.html">ICC_MSRE</a>.DIB.</p>
<p>If EL3 is implemented and <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 1, and EL2 is not implemented, this field is a read/write alias of <a href="AArch32-icc_msre.html">ICC_MSRE</a>.DIB.</p>
<p>If EL3 is not implemented and EL2 is implemented, this field is a read-only alias of <a href="AArch32-icc_hsre.html">ICC_HSRE</a>.DIB.</p>
<p>If <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 1 and EL2 is implemented, this field is a read-only alias of <a href="AArch32-icc_hsre.html">ICC_HSRE</a>.DIB.</p>
<p>In systems that do not support IRQ bypass, this field is RAO/WI.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-1_1">DFB, bit [1]</h4><div class="field">
      <p>Disable FIQ bypass.</p>
    <table class="valuetable"><tr><th>DFB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>FIQ bypass enabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>FIQ bypass disabled.</p>
        </td></tr></table><p>If EL3 is implemented and <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 0, this field is a read-only alias of <a href="AArch32-icc_msre.html">ICC_MSRE</a>.DFB.</p>
<p>If EL3 is implemented and <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 1, and EL2 is not implemented, this field is a read/write alias of <a href="AArch32-icc_msre.html">ICC_MSRE</a>.DFB.</p>
<p>If EL3 is not implemented and EL2 is implemented, this field is a read-only alias of <a href="AArch32-icc_hsre.html">ICC_HSRE</a>.DFB.</p>
<p>If <a href="ext-gicd_ctlr.html">GICD_CTLR</a>.DS == 1 and EL2 is implemented, this field is a read-only alias of <a href="AArch32-icc_hsre.html">ICC_HSRE</a>.DFB.</p>
<p>In systems that do not support FIQ bypass, this field is RAO/WI.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-0_0">SRE, bit [0]</h4><div class="field">
      <p>System Register Enable.</p>
    <table class="valuetable"><tr><th>SRE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>The memory-mapped interface must be used. Accesses at EL1 to any ICC_* System register other than ICC_SRE are <span class="arm-defined-word">UNDEFINED</span>.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The System register interface for the current Security state is enabled.</p>
        </td></tr></table><p>If software changes this bit from 1 to 0 in the Secure instance of this register, the results are <span class="arm-defined-word">UNPREDICTABLE</span>.</p>
<p>If an implementation supports only a System register interface to the GIC CPU interface, this bit is RAO/WI.</p>
<p>If EL3 is implemented and using AArch64:</p>
<ul>
<li>When <a href="AArch64-icc_sre_el3.html">ICC_SRE_EL3</a>.SRE==0 the Secure copy of this bit is RAZ/WI.
</li><li>When <a href="AArch64-icc_sre_el3.html">ICC_SRE_EL3</a>.SRE==0 the Non-secure copy of this bit is RAZ/WI.
</li></ul>
<p>If EL3 is implemented and using AArch32:</p>
<ul>
<li>When <a href="AArch32-icc_msre.html">ICC_MSRE</a>.SRE==0 the Secure copy of this bit is RAZ/WI.
</li><li>When <a href="AArch32-icc_msre.html">ICC_MSRE</a>.SRE==0 the Non-secure copy of this bit is RAZ/WI.
</li></ul>
<p>If EL2 is implemented and using AArch64:</p>
<ul>
<li>When <a href="AArch64-icc_sre_el2.html">ICC_SRE_EL2</a>.SRE==0 the Non-secure copy of this bit is RAZ/WI.
</li></ul>
<p>If EL2 is implemented and using AArch32:</p>
<ul>
<li>When <a href="AArch32-icc_hsre.html">ICC_HSRE</a>.SRE==0 the Non-secure copy of this bit is RAZ/WI.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><div class="access_mechanisms"><h2>Accessing ICC_SRE</h2>
        <p>The GIC architecture permits, but does not require, that registers can be shared between memory-mapped registers and the equivalent System registers. This means that if the memory-mapped registers have been accessed while ICC_SRE.SRE==0, then the System registers might be modified. Therefore, software must only rely on the reset values of the System registers if there has been no use of the GIC functionality while the memory-mapped registers are in use. Otherwise, the System register values must be treated as <span class="arm-defined-word">UNKNOWN</span>.</p>
      <p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b1100</td><td>0b1100</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; ICC_SRE_EL3.Enable == '0' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T12 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T12 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; ICC_SRE_EL2.Enable == '0' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; ICC_HSRE.Enable == '0' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) &amp;&amp; ICC_MSRE.Enable == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; ICC_SRE_EL3.Enable == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    elsif HaveEL(EL3) then
        if SCR_EL3.NS == '0' then
            R[t] = ICC_SRE_S;
        else
            R[t] = ICC_SRE_NS;
    else
        R[t] = ICC_SRE;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; ICC_SRE_EL3.Enable == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; ICC_SRE_EL3.Enable == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    elsif ICC_MSRE.Enable == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) then
        if SCR_EL3.NS == '0' then
            R[t] = ICC_SRE_S;
        else
            R[t] = ICC_SRE_NS;
    else
        R[t] = ICC_SRE;
elsif PSTATE.EL == EL3 then
    if SCR_EL3.NS == '0' then
        R[t] = ICC_SRE_S;
    else
        R[t] = ICC_SRE_NS;
                </p><h4 class="assembler">MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b1100</td><td>0b1100</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; ICC_SRE_EL3.Enable == '0' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T12 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T12 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; ICC_SRE_EL2.Enable == '0' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; ICC_HSRE.Enable == '0' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) &amp;&amp; ICC_MSRE.Enable == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; ICC_SRE_EL3.Enable == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    elsif HaveEL(EL3) then
        if SCR_EL3.NS == '0' then
            ICC_SRE_S = R[t];
        else
            ICC_SRE_NS = R[t];
    else
        ICC_SRE = R[t];
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; ICC_SRE_EL3.Enable == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; ICC_SRE_EL3.Enable == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    elsif ICC_MSRE.Enable == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) then
        if SCR_EL3.NS == '0' then
            ICC_SRE_S = R[t];
        else
            ICC_SRE_NS = R[t];
    else
        ICC_SRE = R[t];
elsif PSTATE.EL == EL3 then
    if SCR_EL3.NS == '0' then
        ICC_SRE_S = R[t];
    else
        ICC_SRE_NS = R[t];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:07; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
