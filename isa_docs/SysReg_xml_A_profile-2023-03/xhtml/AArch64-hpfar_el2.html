<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>HPFAR_EL2</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">HPFAR_EL2, Hypervisor IPA Fault Address Register</h1><p>The HPFAR_EL2 characteristics are:</p><h2>Purpose</h2>
        <p>Holds the faulting IPA for some aborts on a stage 2 translation taken to EL2.</p>
      <h2>Configuration</h2><p>AArch64 System register HPFAR_EL2 bits [31:0] are architecturally mapped to AArch32 System register <a href="AArch32-hpfar.html">HPFAR[31:0]</a>.</p>
        <p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p>

      
        <p>This register has no effect if EL2 is not enabled in the current Security state.</p>

      
        <p>The HPFAR_EL2 is written for:</p>

      
        <ul>
<li>Translation or Access faults in the second stage of translation.
</li><li>An abort in the second stage of translation performed during the translation table walk of a first stage translation, caused by a Translation fault, an Access flag fault, or a Permission fault.
</li><li>A stage 2 Address size fault.
</li><li>If <span class="xref">FEAT_RME</span> is implemented, a Granule Protection Check fault in the second stage of translation.
</li></ul>

      
        <p>For all other exceptions taken to EL2, this register is <span class="arm-defined-word">UNKNOWN</span>.</p>

      
        <div class="note"><span class="note-header">Note</span><p>The address held in this register is an address accessed by the instruction fetch or data access that caused the exception that gave rise to the Instruction Abort exception or Data Abort exception. It is the lower address that gave rise to the fault that is reported. Where different faults from different addresses arise from the same instruction, such as for an instruction that loads or stores an unaligned address that crosses a page boundary, the architecture does not prioritize which fault is reported.</p></div>
      <h2>Attributes</h2>
        <p>HPFAR_EL2 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-63_63-1">NS</a></td><td class="lr" colspan="15"><a href="#fieldset_0-62_48">RES0</a></td><td class="lr" colspan="16"><a href="#fieldset_0-47_4">FIPA</a></td></tr><tr class="firstrow"><td class="lr" colspan="28"><a href="#fieldset_0-47_4">FIPA</a></td><td class="lr" colspan="4"><a href="#fieldset_0-3_0">RES0</a></td></tr></tbody></table><div class="text_before_fields">
    <p>Execution at EL1 or EL0 makes HPFAR_EL2 become <span class="arm-defined-word">UNKNOWN</span>.</p>
  </div><h4 id="fieldset_0-63_63-1">NS, bit [63]<span class="condition"><br/>When FEAT_SEL2 is implemented:
                        </span></h4><div class="field">
      <p>Faulting IPA address space.</p>
    <table class="valuetable"><tr><th>NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Faulting IPA is from the Secure IPA space.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Faulting IPA is from the Non-secure IPA space.</p>
        </td></tr></table><p>For Data Abort exceptions or Instruction Abort exceptions taken to Non-secure EL2:</p>
<ul>
<li>This field is <span class="arm-defined-word">RES0</span>.
</li><li>The address is from the Non-secure IPA space.
</li></ul>
<p>If <span class="xref">FEAT_RME</span> is implemented, for Data Abort exceptions or Instruction Abort exceptions taken to Realm EL2:</p>
<ul>
<li>This field is <span class="arm-defined-word">RES0</span>.
</li><li>The address is from the Realm IPA space.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-63_63-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-62_48">Bits [62:48]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-47_4">FIPA, bits [47:4]</h4><div class="field"><div class="partial_fieldset"><h3 id="fieldset_0-47_4_0">FIPA encoding when FEAT_D128 is implemented</h3><table class="regdiagram"><thead><tr><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="12"><a href="#fieldset_0-47_4_0-43_0">FIPA</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-47_4_0-43_0">FIPA</a></td></tr></tbody></table><h4 id="fieldset_0-47_4_0-43_0">FIPA, bits [43:0]</h4><div class="field"><p>Bits [55:12] of the Faulting Intermediate Physical Address.</p>
<p>For implementations with fewer than 55 physical address bits, the corresponding upper bits in this field are <span class="arm-defined-word">RES0</span>.</p>
<p>When <span class="xref">FEAT_MOPS</span> is implemented, the value presented in FIPA on a synchronous exception that set the HPFAR_EL2 from any of the Memory Copy and Memory Set instructions is within the address range of the current stage 2 translation granule, aligned to the size of the current stage 2 translation granule, of the address that generated the Data abort.</p>
<p>Bits[(n-1):0] of the value are <span class="arm-defined-word">UNKNOWN</span>, where 2<sup>n</sup> is the current stage 2 translation granule size in bytes.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-47_4_1">FIPA encoding when FEAT_LPA is implemented and FEAT_D128 is not implemented</h3><table class="regdiagram"><thead><tr><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="4"><a href="#fieldset_0-47_4_1-43_40">RES0</a></td><td class="lr" colspan="8"><a href="#fieldset_0-47_4_1-39_0">FIPA</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-47_4_1-39_0">FIPA</a></td></tr></tbody></table><h4 id="fieldset_0-47_4_1-43_40">Bits [43:40]</h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div><h4 id="fieldset_0-47_4_1-39_0">FIPA, bits [39:0]</h4><div class="field"><p>Bits [51:12] of the Faulting Intermediate Physical Address.</p>
<p>For implementations with fewer than 52 physical address bits, the corresponding upper bits in this field are <span class="arm-defined-word">RES0</span>.</p>
<p>When <span class="xref">FEAT_MOPS</span> is implemented, the value presented in FIPA on a synchronous exception that set the HPFAR_EL2 from any of the Memory Copy and Memory Set instructions is within the address range of the current stage 2 translation granule, aligned to the size of the current stage 2 translation granule, of the address that generated the Data abort.</p>
<p>Bits[(n-1):0] of the value are <span class="arm-defined-word">UNKNOWN</span>, where 2<sup>n</sup> is the current stage 2 translation granule size in bytes.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-47_4_2">FIPA encoding when FEAT_LPA is not implemented</h3><table class="regdiagram"><thead><tr><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_0-47_4_2-43_36">RES0</a></td><td class="lr" colspan="4"><a href="#fieldset_0-47_4_2-35_0">FIPA</a></td></tr><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-47_4_2-35_0">FIPA</a></td></tr></tbody></table><h4 id="fieldset_0-47_4_2-43_36">Bits [43:36]</h4><div class="field">
            <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
          </div><h4 id="fieldset_0-47_4_2-35_0">FIPA, bits [35:0]</h4><div class="field"><p>Bits[47:12] Faulting Intermediate Physical Address.</p>
<p>For implementations with fewer than 48 physical address bits, the corresponding upper bits in this field are <span class="arm-defined-word">RES0</span>.</p>
<p>When <span class="xref">FEAT_MOPS</span> is implemented, the value presented in FIPA on a synchronous exception that set the HPFAR_EL2 from any of the Memory Copy and Memory Set instructions is within the address range of the current stage 2 translation granule, aligned to the size of the current stage 2 translation granule, of the address that generated the Data abort.</p>
<p>Bits[(n-1):0] of the value are <span class="arm-defined-word">UNKNOWN</span>, where 2<sup>n</sup> is the current stage 2 translation granule size in bytes.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div></div><h4 id="fieldset_0-3_0">Bits [3:0]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><div class="access_mechanisms"><h2>Accessing HPFAR_EL2</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt&gt;, HPFAR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0110</td><td>0b0000</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    X[t, 64] = HPFAR_EL2;
elsif PSTATE.EL == EL3 then
    X[t, 64] = HPFAR_EL2;
                </p><h4 class="assembler">MSR HPFAR_EL2, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0110</td><td>0b0000</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    HPFAR_EL2 = X[t, 64];
elsif PSTATE.EL == EL3 then
    HPFAR_EL2 = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:06; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
