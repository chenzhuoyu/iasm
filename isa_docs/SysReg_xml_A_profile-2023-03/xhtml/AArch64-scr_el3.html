<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>SCR_EL3</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">SCR_EL3, Secure Configuration Register</h1><p>The SCR_EL3 characteristics are:</p><h2>Purpose</h2>
        <p>Defines the configuration of the current Security state. It specifies:</p>

      
        <ul>
<li>The Security state of EL0, EL1, and EL2. The Security state is Secure, Non-secure, or Realm.
</li><li>The Execution state at lower Exception levels.
</li><li>Whether IRQ, FIQ, SError interrupts, and External abort exceptions are taken to EL3.
</li><li>Whether various operations are trapped to EL3.
</li></ul>
      <h2>Configuration</h2><p>This register is present only when EL3 is implemented. Otherwise, direct accesses to SCR_EL3 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2>
        <p>SCR_EL3 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-63_63">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-62_62-1">NSE</a></td><td class="lr" colspan="2"><a href="#fieldset_0-61_60">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-59_59-1">FGTEn2</a></td><td class="lr" colspan="3"><a href="#fieldset_0-58_56">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_55-1">EnIDCP128</a></td><td class="lr" colspan="1"><a href="#fieldset_0-54_54">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-53_53-1">PFAREn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-52_52-1">TWERR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-51_51-1">TMEA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-50_50">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-49_49-1">MECEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-48_48-1">GPF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-47_47-1">D128En</a></td><td class="lr" colspan="1"><a href="#fieldset_0-46_46-1">AIEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-45_45-1">PIEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-44_44-1">SCTLR2En</a></td><td class="lr" colspan="1"><a href="#fieldset_0-43_43-1">TCR2En</a></td><td class="lr" colspan="1"><a href="#fieldset_0-42_42-1">RCWMASKEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-41_41-1">EnTP2</a></td><td class="lr" colspan="1"><a href="#fieldset_0-40_40-1">TRNDR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-39_39-1">GCSEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-38_38-1">HXEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-37_37-1">ADEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-36_36-1">EnAS0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-35_35-1">AMVOFFEN</a></td><td class="lr" colspan="1"><a href="#fieldset_0-34_34-1">TME</a></td><td class="lr" colspan="2"><a href="#fieldset_0-33_30-1">TWEDEL</a></td></tr><tr class="firstrow"><td class="lr" colspan="2"><a href="#fieldset_0-33_30-1">TWEDEL</a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29-1">TWEDEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-28_28-1">ECVEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-27_27-1">FGTEn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-26_26-1">ATA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-25_25-1">EnSCXT</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_22">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-21_21-1">FIEN</a></td><td class="lr" colspan="1"><a href="#fieldset_0-20_20-1">NMEA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-19_19-1">EASE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-18_18-1">EEL2</a></td><td class="lr" colspan="1"><a href="#fieldset_0-17_17-1">API</a></td><td class="lr" colspan="1"><a href="#fieldset_0-16_16-1">APK</a></td><td class="lr" colspan="1"><a href="#fieldset_0-15_15-1">TERR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-14_14-1">TLOR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-13_13">TWE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-12_12">TWI</a></td><td class="lr" colspan="1"><a href="#fieldset_0-11_11">ST</a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10-1">RW</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9">SIF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8">HCE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7">SMD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-5_4">RES1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-3_3">EA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2">FIQ</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">IRQ</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0-1">NS</a></td></tr></tbody></table><h4 id="fieldset_0-63_63">Bit [63]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-62_62-1">NSE, bit [62]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>This field, evaluated with SCR_EL3.NS, selects the Security state of EL2 and lower Exception levels.</p>
    
      <p>For a description of the values derived by evaluating NS and NSE together, see SCR_EL3.NS.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-62_62-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>, and the Effective value of this bit is <span class="binarynumber">0b0</span>.</p>
    </div><h4 id="fieldset_0-61_60">Bits [61:60]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-59_59-1">FGTEn2, bit [59]<span class="condition"><br/>When FEAT_FGT2 is implemented:
                        </span></h4><div class="field"><p>Fine-Grained Traps Enable 2.</p>
<p>When EL2 is implemented, enables the traps to EL2 controlled by <a href="AArch64-hdfgrtr2_el2.html">HDFGRTR2_EL2</a>, <a href="AArch64-hdfgwtr2_el2.html">HDFGWTR2_EL2</a>, <a href="AArch64-hfgitr2_el2.html">HFGITR2_EL2</a>, <a href="AArch64-hfgrtr2_el2.html">HFGRTR2_EL2</a>, and <a href="AArch64-hfgwtr2_el2.html">HFGWTR2_EL2</a>, and controls access to those registers.</p><table class="valuetable"><tr><th>FGTEn2</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL2 accesses to the specified registers are trapped to EL3. The values in these registers are treated as 0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>EL2 accesses to the specified registers are not trapped to EL3 by this mechanism.</p>
        </td></tr></table>
      <p>Traps caused by accesses to the fine-grained trap registers are reported using an <a href="AArch64-esr_elx.html">ESR_ELx</a>.EC value of <span class="hexnumber">0x18</span> and its associated ISS.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-59_59-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-58_56">Bits [58:56]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-55_55-1">EnIDCP128, bit [55]<span class="condition"><br/>When FEAT_SYSREG128 is implemented:
                        </span></h4><div class="field">
      <p>Enables access to <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> 128-bit System registers.</p>
    <table class="valuetable"><tr><th>EnIDCP128</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Accesses at EL2, EL1, EL0 to <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> 128-bit System registers are trapped to EL3 using an ESR_EL3.EC value of <span class="hexnumber">0x14</span>, unless the access generates a higher priority exception.</p>
<p>Disables the functionality of the 128-bit <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> System registers that are accessible at EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>No accesses are trapped by this control.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_55-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-54_54">Bit [54]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-53_53-1">PFAREn, bit [53]<span class="condition"><br/>When FEAT_PFAR is implemented:
                        </span></h4><div class="field">
      <p>Enable access to Physical Fault Address Registers. When disabled, accesses to Physical Fault Address Registers generate a trap to EL3.</p>
    <table class="valuetable"><tr><th>PFAREn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses of the specified Physical Fault Address Registers at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified Physical Fault Address Registers are not trapped by this mechanism.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are: <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-pfar_el1.html">PFAR_EL1</a>, <a href="AArch64-pfar_el2.html">PFAR_EL2</a>, and PFAR_EL12.</p>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-53_53-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-52_52-1">TWERR, bit [52]<span class="condition"><br/>When FEAT_RASv2 is implemented:
                        </span></h4><div class="field">
      <p>Trap writes of error record registers. Enables a trap to EL3 on writes of error record registers.</p>
    <table class="valuetable"><tr><th>TWERR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Writes of the specified error record registers are not trapped by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Writes of the specified error record registers at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are: <span class="instruction">MSR</span> accesses to <a href="AArch64-errselr_el1.html">ERRSELR_EL1</a>, <a href="AArch64-erxaddr_el1.html">ERXADDR_EL1</a>, <a href="AArch64-erxctlr_el1.html">ERXCTLR_EL1</a>, <a href="AArch64-erxmisc0_el1.html">ERXMISC0_EL1</a>, <a href="AArch64-erxmisc1_el1.html">ERXMISC1_EL1</a>, <a href="AArch64-erxmisc2_el1.html">ERXMISC2_EL1</a>, <a href="AArch64-erxmisc3_el1.html">ERXMISC3_EL1</a>, and <a href="AArch64-erxstatus_el1.html">ERXSTATUS_EL1</a>.</p>
<p>In AArch32 state, the instructions affected by this control are: <span class="instruction">MCR</span> accesses to <a href="AArch32-errselr.html">ERRSELR</a>, <a href="AArch32-erxaddr.html">ERXADDR</a>, <a href="AArch32-erxaddr2.html">ERXADDR2</a>, <a href="AArch32-erxctlr.html">ERXCTLR</a>, <a href="AArch32-erxctlr2.html">ERXCTLR2</a>, <a href="AArch32-erxmisc0.html">ERXMISC0</a>, <a href="AArch32-erxmisc1.html">ERXMISC1</a>, <a href="AArch32-erxmisc2.html">ERXMISC2</a>, <a href="AArch32-erxmisc3.html">ERXMISC3</a>, <a href="AArch32-erxmisc4.html">ERXMISC4</a>, <a href="AArch32-erxmisc5.html">ERXMISC5</a>, <a href="AArch32-erxmisc6.html">ERXMISC6</a>, <a href="AArch32-erxmisc7.html">ERXMISC7</a>, and <a href="AArch32-erxstatus.html">ERXSTATUS</a>.</p>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped AArch64 instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>Trapped AArch32 instructions are reported using EC syndrome value <span class="hexnumber">0x03</span>.</p>
<p>Accessing this field has the following behavior:</p>
<ul>
<li>This field is permitted to be <span class="arm-defined-word">RES0</span> if all of the following are true:<ul>
<li><a href="AArch64-errselr_el1.html">ERRSELR_EL1</a> and all ERX* registers are implemented as <span class="arm-defined-word">UNDEFINED</span> or RAZ/WI.
</li><li><a href="AArch64-erridr_el1.html">ERRIDR_EL1</a>.NUM is zero.
</li></ul>

</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-52_52-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-51_51-1">TMEA, bit [51]<span class="condition"><br/>When FEAT_DoubleFault2 is implemented:
                        </span></h4><div class="field">
      <p>Trap Masked External Aborts. Controls whether a masked error exception at a lower Exception level is taken to EL3.</p>
    <table class="valuetable"><tr><th>TMEA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Synchronous External Abort exceptions and SError exceptions at EL2, EL1, and EL0 are unaffected by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Synchronous External Abort exceptions when PSTATE.A is 1 and masked SError exceptions at EL2, EL1, and EL0 are taken to EL3, unless routed to another Exception level by a higher priority control.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-51_51-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-50_50">Bit [50]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-49_49-1">MECEn, bit [49]<span class="condition"><br/>When FEAT_MEC is implemented:
                        </span></h4><div class="field"><p>Enables access to the following EL2 MECID registers, from EL2:</p>
<ul>
<li>
<p><a href="AArch64-mecid_p0_el2.html">MECID_P0_EL2</a>.</p>

</li><li>
<p><a href="AArch64-mecid_a0_el2.html">MECID_A0_EL2</a></p>

</li><li>
<p><a href="AArch64-mecid_p1_el2.html">MECID_P1_EL2</a></p>

</li><li>
<p><a href="AArch64-mecid_a1_el2.html">MECID_A1_EL2</a></p>

</li><li>
<p><a href="AArch64-vmecid_p_el2.html">VMECID_P_EL2</a></p>

</li><li>
<p><a href="AArch64-vmecid_a_el2.html">VMECID_A_EL2</a></p>

</li></ul>
<p>Accesses to these registers are trapped and reported using an ESR_EL3.EC value of <span class="hexnumber">0x18</span>.</p><table class="valuetable"><tr><th>MECEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses from EL2 to a listed MECID register are trapped to EL3. The value of a listed EL2 MECID register is treated as 0 for all purposes other than direct reads or writes to the register from EL3.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-49_49-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-48_48-1">GPF, bit [48]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Controls the reporting of Granule protection faults at EL0, EL1 and EL2.</p>
    <table class="valuetable"><tr><th>GPF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause exceptions to be routed from EL0, EL1 or EL2 to EL3.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>GPFs at EL0, EL1 and EL2 are routed to EL3 and reported as Granule Protection Check exceptions.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-48_48-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-47_47-1">D128En, bit [47]<span class="condition"><br/>When FEAT_D128 is implemented:
                        </span></h4><div class="field"><p>128-bit System Register trap control. Enables access to 128-bit System Registers via <span class="instruction">MRRS</span>, <span class="instruction">MSRR</span> instructions.</p>
<ul>
<li>
<p>MRRS and MSRR accesses from EL1 and EL2 using AArch64 to the following registers are trapped and reported using an ESR_ELx.EC value of <span class="hexnumber">0x14</span>:</p>
<ul>
<li>
<p><a href="AArch64-ttbr0_el1.html">TTBR0_EL1</a>.</p>

</li><li>
<p><a href="AArch64-ttbr1_el1.html">TTBR1_EL1</a>.</p>

</li><li>
<p><a href="AArch64-rcwmask_el1.html">RCWMASK_EL1</a>, <a href="AArch64-rcwsmask_el1.html">RCWSMASK_EL1</a>.</p>

</li><li>
<p><a href="AArch64-par_el1.html">PAR_EL1</a>.</p>

</li></ul>

</li><li>
<p>MRRS and MSRR accesses from EL2 using AArch64 to the following registers are trapped and reported using an ESR_ELx.EC value of <span class="hexnumber">0x14</span>:</p>
<ul>
<li>
<p><a href="AArch64-ttbr1_el2.html">TTBR1_EL2</a> and accesses using the register name TTBR1_EL12.</p>

</li><li>
<p><a href="AArch64-ttbr0_el2.html">TTBR0_EL2</a> and accesses using the register name TTBR0_EL12.</p>

</li><li>
<p><a href="AArch64-vttbr_el2.html">VTTBR_EL2</a>.</p>

</li></ul>

</li></ul><table class="valuetable"><tr><th>D128En</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL1 and EL2 accesses to the specificed registers are disabled, and trapped to EL3.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table>
      <p>Traps are not taken if there is a higher priority exception generated by the access.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-47_47-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-46_46-1">AIEn, bit [46]<span class="condition"><br/>When FEAT_AIE is implemented:
                        </span></h4><div class="field"><p>MAIR2_ELx, AMAIR2_ELx Register access trap control.</p>
<ul>
<li>
<p>Accesses from EL1 and EL2 using AArch64 to the following registers are trapped and reported using an ESR_ELx.EC value of <span class="hexnumber">0x18</span>:</p>
<ul>
<li>
<p><a href="AArch64-amair2_el1.html">AMAIR2_EL1</a>.</p>

</li><li>
<p><a href="AArch64-mair2_el1.html">MAIR2_EL1</a>.</p>

</li></ul>

</li><li>
<p>Accesses from EL2 using AArch64 to the following registers are trapped and reported using an ESR_ELx.EC value of <span class="hexnumber">0x18</span>:</p>
<ul>
<li>
<p><a href="AArch64-amair2_el2.html">AMAIR2_EL2</a> and accesses using the register name AMAIR2_EL12.</p>

</li><li>
<p><a href="AArch64-mair2_el2.html">MAIR2_EL2</a> and accesses using the register name MAIR2_EL12.</p>

</li></ul>

</li></ul><table class="valuetable"><tr><th>AIEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL1 and EL2 accesses to the specificed registers are disabled, and trapped to EL3. The values in these registers are treated as 0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table>
      <p>Traps are not taken if there is a higher priority exception generated by the access.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-46_46-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-45_45-1">PIEn, bit [45]<span class="condition"><br/>When FEAT_S1PIE is implemented, or FEAT_S2PIE is implemented, or FEAT_S1POE is implemented or FEAT_S2POE is implemented:
                        </span></h4><div class="field"><p>Permission Indirection, Overlay Register access trap control. Enables access to Permission Indirection and Overlay registers.</p>
<ul>
<li>
<p>Accesses from EL0, EL1 and EL2 using AArch64 to the following registers are trapped and reported using an ESR_ELx.EC value of <span class="hexnumber">0x18</span>:</p>
<ul>
<li><a href="AArch64-por_el0.html">POR_EL0</a>.
</li></ul>

</li><li>
<p>Accesses from EL1 and EL2 using AArch64 to the following registers are trapped and reported using an ESR_ELx.EC value of <span class="hexnumber">0x18</span>:</p>
<ul>
<li>
<p><a href="AArch64-pire0_el1.html">PIRE0_EL1</a>.</p>

</li><li>
<p><a href="AArch64-pir_el1.html">PIR_EL1</a>.</p>

</li><li>
<p><a href="AArch64-por_el1.html">POR_EL1</a>.</p>

</li><li>
<p><a href="AArch64-s2por_el1.html">S2POR_EL1</a>.</p>

</li></ul>

</li><li>
<p>Accesses from EL2 using AArch64 to the following registers are trapped and reported using an ESR_ELx.EC value of <span class="hexnumber">0x18</span>:</p>
<ul>
<li>
<p><a href="AArch64-pire0_el2.html">PIRE0_EL2</a> and accesses using the register name PIRE0_EL12.</p>

</li><li>
<p><a href="AArch64-pir_el2.html">PIR_EL2</a> and accesses using the register name PIR_EL12.</p>

</li><li>
<p><a href="AArch64-por_el2.html">POR_EL2</a> and accesses using the register name POR_EL12.</p>

</li><li>
<p><a href="AArch64-s2pir_el2.html">S2PIR_EL2</a>.</p>

</li></ul>

</li></ul><table class="valuetable"><tr><th>PIEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL0, EL1 and EL2 accesses to the specificed registers are disabled, and trapped to EL3. The values in these registers are treated as 0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table>
      <p>Traps are not taken if there is a higher priority exception generated by the access.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-45_45-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-44_44-1">SCTLR2En, bit [44]<span class="condition"><br/>When FEAT_SCTLR2 is implemented:
                        </span></h4><div class="field">
      <p>SCTLR2_ELx register trap control. Enables access to <a href="AArch64-sctlr2_el1.html">SCTLR2_EL1</a> and <a href="AArch64-sctlr2_el2.html">SCTLR2_EL2</a> registers.</p>
    <table class="valuetable"><tr><th>SCTLR2En</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL1 and EL2 accesses to <a href="AArch64-sctlr2_el1.html">SCTLR2_EL1</a> and <a href="AArch64-sctlr2_el2.html">SCTLR2_EL2</a> registers are disabled, and trapped to EL3. The values in these registers are treated as 0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table><p>Traps are reported using an <a href="AArch64-esr_el3.html">ESR_EL3</a>.EC value of <span class="hexnumber">0x18</span>.</p>
<p>Traps are not taken if there is a higher priority exception generated by the access.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-44_44-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-43_43-1">TCR2En, bit [43]<span class="condition"><br/>When FEAT_TCR2 is implemented:
                        </span></h4><div class="field">
      <p>TCR2_ELx register trap control. Enables access to <a href="AArch64-tcr2_el1.html">TCR2_EL1</a> and <a href="AArch64-tcr2_el2.html">TCR2_EL2</a> registers.</p>
    <table class="valuetable"><tr><th>TCR2En</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL1 and EL2 accesses to <a href="AArch64-tcr2_el1.html">TCR2_EL1</a> and <a href="AArch64-tcr2_el2.html">TCR2_EL2</a> registers are disabled, and trapped to EL3. The values in these registers are treated as 0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table><p>Traps are reported using an <a href="AArch64-esr_el3.html">ESR_EL3</a>.EC value of <span class="hexnumber">0x18</span>.</p>
<p>Traps are not taken if there is a higher priority exception generated by the access.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-43_43-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-42_42-1">RCWMASKEn, bit [42]<span class="condition"><br/>When FEAT_THE is implemented:
                        </span></h4><div class="field">
      <p>RCW and RCWS Mask register trap control. Enables access to <a href="AArch64-rcwmask_el1.html">RCWMASK_EL1</a>, <a href="AArch64-rcwsmask_el1.html">RCWSMASK_EL1</a>.</p>
    <table class="valuetable"><tr><th>RCWMASKEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL1 and EL2 accesses to <a href="AArch64-rcwmask_el1.html">RCWMASK_EL1</a> and <a href="AArch64-rcwsmask_el1.html">RCWSMASK_EL1</a> registers are disabled, and trapped to EL3.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table><p>Traps for <span class="instruction">MRS</span>, <span class="instruction">MSR</span> access are reported using an <a href="AArch64-esr_el3.html">ESR_EL3</a>.EC value of <span class="hexnumber">0x18</span>.</p>
<p>Traps for <span class="instruction">MRRS</span>, <span class="instruction">MSRR</span> acceess are reported using an <a href="AArch64-esr_el3.html">ESR_EL3</a>.EC value of <span class="hexnumber">0x14</span>.</p>
<p>Traps are not taken if there is a higher priority exception generated by the access.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-42_42-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-41_41-1">EnTP2, bit [41]<span class="condition"><br/>When FEAT_SME is implemented:
                        </span></h4><div class="field">
      <p>Traps instructions executed at EL2, EL1, and EL0 that access <a href="AArch64-tpidr2_el0.html">TPIDR2_EL0</a> to EL3. The exception is reported using ESR_ELx.EC value <span class="hexnumber">0x18</span>.</p>
    <table class="valuetable"><tr><th>EnTP2</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control causes execution of these instructions at EL2, EL1, and EL0 to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause execution of any instructions to be trapped.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-41_41-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-40_40-1">TRNDR, bit [40]<span class="condition"><br/>When FEAT_RNG_TRAP is implemented:
                        </span></h4><div class="field">
      <p>Controls trapping of reads of <a href="AArch64-rndr.html">RNDR</a> and <a href="AArch64-rndrrs.html">RNDRRS</a>. The exception is reported using ESR_ELx.EC value <span class="hexnumber">0x18</span>.</p>
    <table class="valuetable"><tr><th>TRNDR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>This control does not cause <a href="AArch64-rndr.html">RNDR</a> and <a href="AArch64-rndrrs.html">RNDRRS</a> to be trapped.</p>
<p>When FEAT_RNG is implemented:</p>
<ul>
<li><a href="AArch64-id_aa64isar0_el1.html">ID_AA64ISAR0_EL1</a>.RNDR returns the value <span class="binarynumber">0b0001</span>.
</li></ul>
<p>When FEAT_RNG is not implemented:</p>
<ul>
<li>
<p><a href="AArch64-id_aa64isar0_el1.html">ID_AA64ISAR0_EL1</a>.RNDR returns the value <span class="binarynumber">0b0000</span>.</p>

</li><li>
<p>MRS reads of <a href="AArch64-rndr.html">RNDR</a> and <a href="AArch64-rndrrs.html">RNDRRS</a> are <span class="arm-defined-word">UNDEFINED</span>.</p>

</li></ul></td></tr><tr><td class="bitfield">0b1</td><td><p><a href="AArch64-id_aa64isar0_el1.html">ID_AA64ISAR0_EL1</a>.RNDR returns the value <span class="binarynumber">0b0001</span>.</p>
<p>Any attempt to read <a href="AArch64-rndr.html">RNDR</a> or <a href="AArch64-rndrrs.html">RNDRRS</a> is trapped to EL3.</p></td></tr></table>
      <p>When FEAT_RNG is not implemented, Arm recommends that SCR_EL3.TRNDR is initialized before entering Exception levels below EL3 and not subsequently changed.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-40_40-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-39_39-1">GCSEn, bit [39]<span class="condition"><br/>When FEAT_GCS is implemented:
                        </span></h4><div class="field">
      <p>Guarded control stack enable. Controls access to the Guarded Control Stack registers from EL2, EL1, and EL0, and controls whether the Guarded Control Stack is enabled.</p>
    <table class="valuetable"><tr><th>GCSEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Trap read and write accesses to all Guarded Control Stack registers to EL3. All Guarded Control Stack behavior is disabled at EL2, EL1, and EL0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped, and does not disable Guarded Control Stack behavior at EL2, EL1, or EL0.</p>
        </td></tr></table><p>The Guarded Control Stack registers trapped by this control are: <a href="AArch64-gcscre0_el1.html">GCSCRE0_EL1</a>, <a href="AArch64-gcscr_el1.html">GCSCR_EL1</a>, <a href="AArch64-gcscr_el2.html">GCSCR_EL2</a>, GCSCR_EL12, <a href="AArch64-gcspr_el0.html">GCSPR_EL0</a>, <a href="AArch64-gcspr_el1.html">GCSPR_EL1</a>, <a href="AArch64-gcspr_el2.html">GCSPR_EL2</a>, and GCSPR_EL12.</p>
<p>Traps are reported using an <a href="AArch64-esr_el3.html">ESR_EL3</a>.EC value of <span class="hexnumber">0x18</span>.</p>
<p>Traps are not taken if there is a higher priority exception generated by the access.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-39_39-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-38_38-1">HXEn, bit [38]<span class="condition"><br/>When FEAT_HCX is implemented:
                        </span></h4><div class="field">
      <p>Enables access to the <a href="AArch64-hcrx_el2.html">HCRX_EL2</a> register at EL2 from EL3.</p>
    <table class="valuetable"><tr><th>HXEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses at EL2 to <a href="AArch64-hcrx_el2.html">HCRX_EL2</a> are trapped to EL3. Indirect reads of <a href="AArch64-hcrx_el2.html">HCRX_EL2</a> return 0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-38_38-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-37_37-1">ADEn, bit [37]<span class="condition"><br/>When FEAT_LS64_ACCDATA is implemented:
                        </span></h4><div class="field">
      <p>Enables access to the <a href="AArch64-accdata_el1.html">ACCDATA_EL1</a> register at EL1 and EL2.</p>
    <table class="valuetable"><tr><th>ADEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses to <a href="AArch64-accdata_el1.html">ACCDATA_EL1</a> at EL1 and EL2 are trapped to EL3, unless the accesses are trapped to EL2 by the EL2 fine-grained trap.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause accesses to <a href="AArch64-accdata_el1.html">ACCDATA_EL1</a> to be trapped.</p>
        </td></tr></table>
      <p>If the <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a>.nACCDATA_EL1 or <a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a>.nACCDATA_EL1 traps are enabled, they take priority over this trap.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-37_37-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-36_36-1">EnAS0, bit [36]<span class="condition"><br/>When FEAT_LS64_ACCDATA is implemented:
                        </span></h4><div class="field">
      <p>Traps execution of an ST64BV0 instruction at EL0, EL1, or EL2 to EL3.</p>
    <table class="valuetable"><tr><th>EnAS0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>EL0 execution of an ST64BV0 instruction is trapped to EL3, unless it is trapped to EL1 by <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.EnAS0, or to EL2 by either <a href="AArch64-hcrx_el2.html">HCRX_EL2</a>.EnAS0 or <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.EnAS0.</p>
<p>EL1 execution of an ST64BV0 instruction is trapped to EL3, unless it is trapped to EL2 by <a href="AArch64-hcrx_el2.html">HCRX_EL2</a>.EnAS0.</p>
<p>EL2 execution of an ST64BV0 instruction is trapped to EL3.</p></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table>
      <p>A trap of an ST64BV0 instruction is reported using an ESR_ELx.EC value of <span class="hexnumber">0x0A</span>, with an ISS code of <span class="hexnumber">0x0000001</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-36_36-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-35_35-1">AMVOFFEN, bit [35]<span class="condition"><br/>When FEAT_AMUv1p1 is implemented:
                        </span></h4><div class="field">
      <p>Activity Monitors Virtual Offsets Enable.</p>
    <table class="valuetable"><tr><th>AMVOFFEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses to <a href="AArch64-amevcntvoff0n_el2.html">AMEVCNTVOFF0&lt;n&gt;_EL2</a> and <a href="AArch64-amevcntvoff1n_el2.html">AMEVCNTVOFF1&lt;n&gt;_EL2</a> at EL2 are trapped to EL3. Indirect reads of the virtual offset registers are zero.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses to <a href="AArch64-amevcntvoff0n_el2.html">AMEVCNTVOFF0&lt;n&gt;_EL2</a> and <a href="AArch64-amevcntvoff1n_el2.html">AMEVCNTVOFF1&lt;n&gt;_EL2</a> are not affected by this field.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-35_35-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-34_34-1">TME, bit [34]<span class="condition"><br/>When FEAT_TME is implemented:
                        </span></h4><div class="field">
      <p>Enables access to the TSTART, TCOMMIT, TTEST and TCANCEL instructions at EL0, EL1 and EL2.</p>
    <table class="valuetable"><tr><th>TME</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL0, EL1 and EL2 accesses to TSTART, TCOMMIT, TTEST and TCANCEL instructions are <span class="arm-defined-word">UNDEFINED</span>.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instruction to be <span class="arm-defined-word">UNDEFINED</span>.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-34_34-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-33_30-1">TWEDEL, bits [33:30]<span class="condition"><br/>When FEAT_TWED is implemented:
                        </span></h4><div class="field">
      <p>TWE Delay. A 4-bit unsigned number that, when SCR_EL3.TWEDEn is 1, encodes the minimum delay in taking a trap of WFE* caused by SCR_EL3.TWE as 2<sup>(TWEDEL + 8)</sup> cycles.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-33_30-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-29_29-1">TWEDEn, bit [29]<span class="condition"><br/>When FEAT_TWED is implemented:
                        </span></h4><div class="field"><p>TWE Delay Enable. Enables a configurable delayed trap of the WFE* instruction caused by SCR_EL3.TWE.</p>
<p>Traps are reported using an ESR_ELx.EC value of <span class="hexnumber">0x01</span>.</p><table class="valuetable"><tr><th>TWEDEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>The delay for taking the trap is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>The delay for taking the trap is at least the number of cycles defined in SCR_EL3.TWEDEL.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-28_28-1">ECVEn, bit [28]<span class="condition"><br/>When FEAT_ECV is implemented:
                        </span></h4><div class="field">
      <p>ECV Enable. Enables access to the <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a> register.</p>
    <table class="valuetable"><tr><th>ECVEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL2 accesses to <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a> are trapped to EL3, and the value of <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a> is treated as 0 for all purposes other than direct reads or writes to the register from EL3.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>EL2 accesses to <a href="AArch64-cntpoff_el2.html">CNTPOFF_EL2</a> are not trapped to EL3 by this mechanism.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-28_28-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-27_27-1">FGTEn, bit [27]<span class="condition"><br/>When FEAT_FGT is implemented:
                        </span></h4><div class="field"><p>Fine-Grained Traps Enable. When EL2 is implemented, enables the traps to EL2 controlled by <a href="AArch64-hafgrtr_el2.html">HAFGRTR_EL2</a>, <a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a>, <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a>, <a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a>, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a>, and <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a>, and controls access to those registers.</p>
<div class="note"><span class="note-header">Note</span><p>If EL2 is not implemented but EL3 is implemented, <span class="xref">FEAT_FGT</span> implements the <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDCC traps.</p></div><table class="valuetable"><tr><th>FGTEn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>EL2 accesses to <a href="AArch64-hafgrtr_el2.html">HAFGRTR_EL2</a>, <a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a>, <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a>, <a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a>, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a> and <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a> registers are trapped to EL3, and the traps to EL2 controlled by those registers are disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>EL2 accesses to <a href="AArch64-hafgrtr_el2.html">HAFGRTR_EL2</a>, <a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a>, <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a>, <a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a>, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a> and <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a> registers are not trapped to EL3 by this mechanism.</p>
        </td></tr></table>
      <p>Traps caused by accesses to the fine-grained trap registers are reported using an ESR_ELx.EC value of <span class="hexnumber">0x18</span> and its associated ISS.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-27_27-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-26_26-1">ATA, bit [26]<span class="condition"><br/>When FEAT_MTE2 is implemented:
                        </span></h4><div class="field">
      <p>Allocation Tag Access. Controls access to Allocation Tags, System registers for Memory tagging, and prevention of Tag checking, at EL2, EL1 and EL0.</p>
    <table class="valuetable"><tr><th>ATA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Access to Allocation Tags is prevented at EL2, EL1, and EL0.</p>
<p>Accesses at EL1 and EL2 to <a href="AArch64-gcr_el1.html">GCR_EL1</a>, <a href="AArch64-rgsr_el1.html">RGSR_EL1</a>, <a href="AArch64-tfsr_el1.html">TFSR_EL1</a>, <a href="AArch64-tfsr_el2.html">TFSR_EL2</a> or <a href="AArch64-tfsre0_el1.html">TFSRE0_EL1</a> that are not <span class="arm-defined-word">UNDEFINED</span> or trapped to a lower Exception level are trapped to EL3.</p>
<p>Accesses at EL2 using MRS or MSR with the register name TFSR_EL12 that are not <span class="arm-defined-word">UNDEFINED</span> are trapped to EL3.</p>
<p>Memory accesses at EL2, EL1, and EL0 are not subject to a Tag Check operation.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>This control does not prevent access to Allocation Tags at EL2, EL1, and EL0.</p>
<p>This control does not prevent Tag checking at EL2, EL1, and EL0.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-26_26-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-25_25-1">EnSCXT, bit [25]<span class="condition"><br/>When FEAT_CSV2_2 is implemented or FEAT_CSV2_1p2 is implemented:
                        </span></h4><div class="field">
      <p>Enables access to the <a href="AArch64-scxtnum_el2.html">SCXTNUM_EL2</a>, <a href="AArch64-scxtnum_el1.html">SCXTNUM_EL1</a>, and <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a> registers.</p>
    <table class="valuetable"><tr><th>EnSCXT</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses at EL0, EL1 and EL2 to <a href="AArch64-scxtnum_el0.html">SCXTNUM_EL0</a>, <a href="AArch64-scxtnum_el1.html">SCXTNUM_EL1</a>, or <a href="AArch64-scxtnum_el2.html">SCXTNUM_EL2</a> registers are trapped to EL3 if they are not trapped by a higher priority exception, and the values of these registers are treated as 0.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any accesses to be trapped, or register values to be treated as 0.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_25-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-24_22">Bits [24:22]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-21_21-1">FIEN, bit [21]<span class="condition"><br/>When FEAT_RASv1p1 is implemented:
                        </span></h4><div class="field">
      <p>Fault Injection enable. Trap accesses to the registers <a href="AArch64-erxpfgcdn_el1.html">ERXPFGCDN_EL1</a>, <a href="AArch64-erxpfgctl_el1.html">ERXPFGCTL_EL1</a>, and <a href="AArch64-erxpfgf_el1.html">ERXPFGF_EL1</a> from EL1 and EL2 to EL3, reported using an ESR_ELx.EC value of <span class="hexnumber">0x18</span>.</p>
    <table class="valuetable"><tr><th>FIEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses to the specified registers from EL1 and EL2 generate a Trap exception to EL3.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table><p>If EL3 is not implemented, the Effective value of SCR_EL3.FIEN is <span class="binarynumber">0b1</span>.</p>
<p>If <a href="AArch64-erridr_el1.html">ERRIDR_EL1</a>.NUM is zero, meaning no error records are implemented, or no error record accessible using System registers is owned by a node that implements the RAS Common Fault Injection Model Extension, then this bit might be <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-21_21-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-20_20-1">NMEA, bit [20]<span class="condition"><br/>When FEAT_DoubleFault is implemented:
                        </span></h4><div class="field">
      <p>Non-maskable External Aborts. Controls whether PSTATE.A masks SError exceptions at EL3.</p>
    <table class="valuetable"><tr><th>NMEA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>SError exceptions are not taken at EL3 if PSTATE.A == 1.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>SError exceptions are taken at EL3 regardless of the value of PSTATE.A.</p>
        </td></tr></table><p>This field is ignored by the PE and treated as zero when all of the following are true:</p>
<ul>
<li><span class="xref">FEAT_DoubleFault2</span> is not implemented.
</li><li>SCR_EL3.EA == 0.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-20_20-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-19_19-1">EASE, bit [19]<span class="condition"><br/>When FEAT_DoubleFault is implemented:
                        </span></h4><div class="field">
      <p>External aborts to SError interrupt vector.</p>
    <table class="valuetable"><tr><th>EASE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Synchronous External abort exceptions taken to EL3 are taken to the appropriate synchronous exception vector offset from <a href="AArch64-vbar_el3.html">VBAR_EL3</a>.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Synchronous External abort exceptions taken to EL3 are taken to the appropriate SError interrupt vector offset from <a href="AArch64-vbar_el3.html">VBAR_EL3</a>.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-19_19-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-18_18-1">EEL2, bit [18]<span class="condition"><br/>When FEAT_SEL2 is implemented:
                        </span></h4><div class="field">
      <p>Secure EL2 Enable.</p>
    <table class="valuetable"><tr><th>EEL2</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>All behaviors associated with Secure EL2 are disabled. All registers, including timer registers, defined by <span class="xref">FEAT_SEL2</span> are <span class="arm-defined-word">UNDEFINED</span>, and those timers are disabled.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>All behaviors associated with Secure EL2 are enabled.</p>
        </td></tr></table><p>When the value of this bit is 1, then:</p>
<ul>
<li>
<p>When SCR_EL3.NS == 0, the SCR_EL3.RW bit is treated as 1 for all purposes other than reading or writing the register.</p>

</li><li>
<p>If Secure EL1 is using AArch32, then any of the following operations, executed in Secure EL1, is trapped to Secure EL2, using the EC value of <a href="AArch64-esr_el2.html">ESR_EL2</a>.EC== <span class="hexnumber">0x3</span> :</p>
<ul>
<li>A read or write of the <a href="AArch32-scr.html">SCR</a>.
</li><li>A read or write of the <a href="AArch32-nsacr.html">NSACR</a>.
</li><li>A read or write of the <a href="AArch32-mvbar.html">MVBAR</a>.
</li><li>A read or write of the <a href="AArch32-sdcr.html">SDCR</a>.
</li><li>Execution of an ATS12NSO** instruction.
</li></ul>

</li><li>
<p>If Secure EL1 is using AArch32, then any of the following operations, executed in Secure EL1, is trapped to Secure EL2 using the EC value of <a href="AArch64-esr_el2.html">ESR_EL2</a>.EC== <span class="hexnumber">0x0</span> :</p>
<ul>
<li>Execution of an SRS instruction that uses R13_mon.
</li><li>Execution of an MRS (Banked register) or MSR (Banked register) instruction that would access <a href="AArch32-spsr_mon.html">SPSR_mon</a>, R13_mon, or R14_mon.
</li></ul>

</li></ul>
<div class="note"><span class="note-header">Note</span><p>If the Effective value of SCR_EL3.EEL2 is 0, then these operations executed in Secure EL1 using AArch32 are trapped to EL3.</p></div><p>A Secure only implementation that does not implement EL3 but implements EL2, behaves as if SCR_EL3.EEL2 == 1.</p>
<p>This bit is permitted to be cached in a TLB.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-18_18-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-17_17-1">API, bit [17]<span class="condition"><br/>When FEAT_SEL2 is implemented and FEAT_PAuth is implemented:
                        </span></h4><div class="field"><p>Controls the use of the following instructions related to Pointer Authentication. Traps are reported using an ESR_ELx.EC value of <span class="hexnumber">0x09</span>:</p>
<ul>
<li>PACGA, which is always enabled.
</li><li>AUTDA, AUTDB, AUTDZA, AUTDZB, AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZA, AUTIZB, PACDA, PACDB, PACDZA, PACDZB, PACIA, PACIA1716, PACIASP, PACIAZ, PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZA, PACIZB, RETAA, RETAB, BRAA, BRAB, BLRAA, BLRAB, BRAAZ, BRABZ, BLRAAZ, BLRABZ, ERETAA, ERETAB, LDRAA and LDRAB when:<ul>
<li>In EL0, when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 0 or <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H == 0, and the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N&gt;&lt;M&gt; == 1.
</li><li>In EL0, when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1 and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H == 1, and the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N&gt;&lt;M&gt; == 1.
</li><li>In EL1, when the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N&gt;&lt;M&gt; == 1.
</li><li>In EL2, when the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N&gt;&lt;M&gt; == 1.
</li></ul>

</li></ul><table class="valuetable"><tr><th>API</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>The use of any instruction related to pointer authentication in any Exception level except EL3 when the instructions are enabled are trapped to EL3 unless they are trapped to EL2 as a result of the <a href="AArch64-hcr_el2.html">HCR_EL2</a>.API bit.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table><p>An instruction is trapped only if Pointer Authentication is enabled for that instruction, for more information, see <span class="xref">'PAC generation and verification keys'</span>.</p>
<div class="note"><span class="note-header">Note</span><p>If <span class="xref">FEAT_PAuth</span> is implemented but EL3 is not implemented, the system behaves as if this bit is 1.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-17_17-2"><span class="condition"><br/>When FEAT_SEL2 is not implemented and FEAT_PAuth is implemented:
                        </span></h4><div class="field"><p>Controls the use of instructions related to Pointer Authentication:</p>
<ul>
<li>PACGA.
</li><li>AUTDA, AUTDB, AUTDZA, AUTDZB, AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZA, AUTIZB, PACDA, PACDB, PACDZA, PACDZB, PACIA, PACIA1716, PACIASP, PACIAZ, PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZA, PACIZ, RETAA, RETAB, BRAA, BRAB, BLRAA, BLRAB, BRAAZ, BRABZ, BLRAAZ, BLRABZ, ERETAA, ERETAB, LDRAA and LDRAB when:<ul>
<li>In Non-secure EL0, when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 0 or <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H == 0, and the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N&gt;&lt;M&gt;== 1.
</li><li>In Non-secure EL0, when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE == 1 and <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H == 1, and the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N&gt;&lt;M&gt; == 1.
</li><li>In Secure EL0, when the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N&gt;&lt;M&gt; == 1.
</li><li>In Secure or Non-secure EL1, when the associated <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.En&lt;N&gt;&lt;M&gt; == 1.
</li><li>In EL2, when the associated <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.En&lt;N&gt;&lt;M&gt; == 1.
</li></ul>

</li></ul><table class="valuetable"><tr><th>API</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>The use of any instruction related to pointer authentication in any Exception level except EL3 when the instructions are enabled are trapped to EL3 unless they are trapped to EL2 as a result of the <a href="AArch64-hcr_el2.html">HCR_EL2</a>.API bit.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>If <span class="xref">FEAT_PAuth</span> is implemented but EL3 is not implemented, the system behaves as if this bit is 1.</p>
      </div>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-17_17-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-16_16-1">APK, bit [16]<span class="condition"><br/>When FEAT_PAuth is implemented:
                        </span></h4><div class="field"><p>Trap registers holding "key" values for Pointer Authentication. Traps accesses to the following registers, using an ESR_ELx.EC value of <span class="hexnumber">0x18</span>, from EL1 or EL2 to EL3 unless they are trapped to EL2 as a result of the HCR_EL2.APK bit or other traps:</p>
<ul>
<li>
<p><a href="AArch64-apiakeylo_el1.html">APIAKeyLo_EL1</a>, <a href="AArch64-apiakeyhi_el1.html">APIAKeyHi_EL1</a>, <a href="AArch64-apibkeylo_el1.html">APIBKeyLo_EL1</a>, <a href="AArch64-apibkeyhi_el1.html">APIBKeyHi_EL1</a>.</p>

</li><li>
<p><a href="AArch64-apdakeylo_el1.html">APDAKeyLo_EL1</a>, <a href="AArch64-apdakeyhi_el1.html">APDAKeyHi_EL1</a>, <a href="AArch64-apdbkeylo_el1.html">APDBKeyLo_EL1</a>, <a href="AArch64-apdbkeyhi_el1.html">APDBKeyHi_EL1</a>.</p>

</li><li>
<p><a href="AArch64-apgakeylo_el1.html">APGAKeyLo_EL1</a>, and <a href="AArch64-apgakeyhi_el1.html">APGAKeyHi_EL1</a>.</p>

</li></ul><table class="valuetable"><tr><th>APK</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Access to the registers holding "key" values for pointer authentication from EL1 or EL2 are trapped to EL3 unless they are trapped to EL2 as a result of the <a href="AArch64-hcr_el2.html">HCR_EL2</a>.APK bit or other traps.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table><p>For more information, see <span class="xref">'PAC generation and verification keys'</span>.</p>
<div class="note"><span class="note-header">Note</span><p>If <span class="xref">FEAT_PAuth</span> is implemented but EL3 is not implemented, the system behaves as if this bit is 1.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-16_16-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-15_15-1">TERR, bit [15]<span class="condition"><br/>When FEAT_RAS is implemented:
                        </span></h4><div class="field">
      <p>Trap accesses of error record registers. Enables a trap to EL3 on accesses of error record registers.</p>
    <table class="valuetable"><tr><th>TERR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Accesses of the specified error record registers are not trapped by this mechanism.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Accesses of the specified error record registers at EL2 and EL1 are trapped to EL3, unless the instruction generates a higher priority exception.</p>
        </td></tr></table><p>In AArch64 state, the instructions affected by this control are:</p>
<ul>
<li><span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-errselr_el1.html">ERRSELR_EL1</a>, <a href="AArch64-erxaddr_el1.html">ERXADDR_EL1</a>, <a href="AArch64-erxctlr_el1.html">ERXCTLR_EL1</a>, <a href="AArch64-erxmisc0_el1.html">ERXMISC0_EL1</a>, <a href="AArch64-erxmisc1_el1.html">ERXMISC1_EL1</a>, and <a href="AArch64-erxstatus_el1.html">ERXSTATUS_EL1</a>.
</li><li><span class="instruction">MRS</span> accesses to <a href="AArch64-erridr_el1.html">ERRIDR_EL1</a> and <a href="AArch64-erxfr_el1.html">ERXFR_EL1</a>.
</li><li>If <span class="xref">FEAT_RASv1p1</span> is implemented, <span class="instruction">MRS</span> and <span class="instruction">MSR</span> accesses to <a href="AArch64-erxmisc2_el1.html">ERXMISC2_EL1</a> and <a href="AArch64-erxmisc3_el1.html">ERXMISC3_EL1</a>.
</li><li>If <span class="xref">FEAT_RASv2</span> is implemented, <span class="instruction">MRS</span> accesses to <a href="AArch64-erxgsr_el1.html">ERXGSR_EL1</a>.
</li></ul>
<p>In AArch32 state, the instructions affected by this control are:</p>
<ul>
<li>
<p><span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses to <a href="AArch32-errselr.html">ERRSELR</a>, <a href="AArch32-erxaddr.html">ERXADDR</a>, <a href="AArch32-erxaddr2.html">ERXADDR2</a>, <a href="AArch32-erxctlr.html">ERXCTLR</a>, <a href="AArch32-erxctlr2.html">ERXCTLR2</a>, <a href="AArch32-erxmisc0.html">ERXMISC0</a>, <a href="AArch32-erxmisc1.html">ERXMISC1</a>, <a href="AArch32-erxmisc2.html">ERXMISC2</a>, <a href="AArch32-erxmisc3.html">ERXMISC3</a>, and <a href="AArch32-erxstatus.html">ERXSTATUS</a>.</p>

</li><li>
<p><span class="instruction">MRC</span> accesses to <a href="AArch32-erridr.html">ERRIDR</a>, <a href="AArch32-erxfr.html">ERXFR</a>, and <a href="AArch32-erxfr2.html">ERXFR2</a>.</p>

</li><li>
<p>If <span class="xref">FEAT_RASv1p1</span> is implemented, <span class="instruction">MRC</span> and <span class="instruction">MCR</span> accesses to <a href="AArch32-erxmisc4.html">ERXMISC4</a>, <a href="AArch32-erxmisc5.html">ERXMISC5</a>, <a href="AArch32-erxmisc6.html">ERXMISC6</a>, and <a href="AArch32-erxmisc7.html">ERXMISC7</a>.</p>

</li></ul>
<p>Unless the instruction generates a higher priority exception, trapped instructions generate an exception to EL3.</p>
<p>Trapped AArch64 instructions are reported using EC syndrome value <span class="hexnumber">0x18</span>.</p>
<p>Trapped AArch32 instructions are reported using EC syndrome value <span class="hexnumber">0x03</span>.</p>
<p>Accessing this field has the following behavior:</p>
<ul>
<li>This field is permitted to be <span class="arm-defined-word">RES0</span> if all of the following are true:<ul>
<li><a href="AArch64-errselr_el1.html">ERRSELR_EL1</a> and all ERX* registers are implemented as <span class="arm-defined-word">UNDEFINED</span> or RAZ/WI.
</li><li><a href="AArch64-erridr_el1.html">ERRIDR_EL1</a>.NUM is zero.
</li></ul>

</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-15_15-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-14_14-1">TLOR, bit [14]<span class="condition"><br/>When FEAT_LOR is implemented:
                        </span></h4><div class="field">
      <p>Trap LOR registers. Traps accesses to the <a href="AArch64-lorsa_el1.html">LORSA_EL1</a>, <a href="AArch64-lorea_el1.html">LOREA_EL1</a>, <a href="AArch64-lorn_el1.html">LORN_EL1</a>, <a href="AArch64-lorc_el1.html">LORC_EL1</a>, and <a href="AArch64-lorid_el1.html">LORID_EL1</a> registers from EL1 and EL2 to EL3, unless the access has been trapped to EL2.</p>
    <table class="valuetable"><tr><th>TLOR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>EL1 and EL2 accesses to the LOR registers that are not <span class="arm-defined-word">UNDEFINED</span> are trapped to EL3, unless it is trapped <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TLOR.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-14_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-13_13">TWE, bit [13]</h4><div class="field"><p>Traps EL2, EL1, and EL0 execution of WFE instructions to EL3, from any Security state and both Execution states, reported using an ESR_ELx.EC value of <span class="hexnumber">0x01</span>.</p>
<p>When <span class="xref">FEAT_WFxT</span> is implemented, this trap also applies to the WFET instruction.</p><table class="valuetable"><tr><th>TWE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Any attempt to execute a WFE instruction at any Exception level lower than EL3 is trapped to EL3, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by <a href="AArch32-sctlr.html">SCTLR</a>.nTWE, <a href="AArch32-hcr.html">HCR</a>.TWE, <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.nTWE, <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.nTWE, or <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TWE.</p>
        </td></tr></table><p>In AArch32 state, the attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</p>
<div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>For more information about when WFE instructions can cause the PE to enter a low-power state, see <span class="xref">'Wait for Event mechanism and Send event'</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-12_12">TWI, bit [12]</h4><div class="field"><p>Traps EL2, EL1, and EL0 execution of WFI instructions to EL3, from any Security state and both Execution states, reported using an ESR_ELx.EC value of <span class="hexnumber">0x01</span>.</p>
<p>When <span class="xref">FEAT_WFxT</span> is implemented, this trap also applies to the WFIT instruction.</p><table class="valuetable"><tr><th>TWI</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Any attempt to execute a WFI instruction at any Exception level lower than EL3 is trapped to EL3, if the instruction would otherwise have caused the PE to enter a low-power state and it is not trapped by <a href="AArch32-sctlr.html">SCTLR</a>.nTWI, <a href="AArch32-hcr.html">HCR</a>.TWI, <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.nTWI, <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.nTWI, or <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TWI.</p>
        </td></tr></table><p>In AArch32 state, the attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</p>
<div class="note"><span class="note-header">Note</span><p>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</p></div><p>For more information about when WFI instructions can cause the PE to enter a low-power state, see <span class="xref">'Wait for Interrupt'</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-11_11">ST, bit [11]</h4><div class="field">
      <p>Traps Secure EL1 accesses to the Counter-timer Physical Secure timer registers to EL3, from AArch64 state only, reported using an ESR_ELx.EC value of <span class="hexnumber">0x18</span>.</p>
    <table class="valuetable"><tr><th>ST</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Secure EL1 using AArch64 accesses to the <a href="AArch64-cntps_tval_el1.html">CNTPS_TVAL_EL1</a>, <a href="AArch64-cntps_ctl_el1.html">CNTPS_CTL_EL1</a>, and <a href="AArch64-cntps_cval_el1.html">CNTPS_CVAL_EL1</a> are trapped to EL3 when Secure EL2 is disabled. If Secure EL2 is enabled, the behavior is as if the value of this field was <span class="binarynumber">0b1</span>.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>This control does not cause any instructions to be trapped.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>Accesses to the Counter-timer Physical Secure timer registers are always enabled at EL3. These registers are not accessible at EL0.</p>
      </div>
      <p>When <span class="xref">FEAT_RME</span> is implemented and Secure state is not implemented, this bit is <span class="arm-defined-word">RES0</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-10_10-1">RW, bit [10]<span class="condition"><br/>When EL1 is capable of using AArch32 or EL2 is capable of using AArch32:
                        </span></h4><div class="field">
      <p>Execution state control for lower Exception levels.</p>
    <table class="valuetable"><tr><th>RW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Lower levels are all AArch32.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td><p>The next lower level is AArch64.</p>
<p>If EL2 is present:</p>
<ul>
<li>
<p>EL2 is AArch64.</p>

</li><li>
<p>EL2 controls EL1 and EL0 behaviors.</p>

</li></ul>
<p>If EL2 is not present:</p>
<ul>
<li>
<p>EL1 is AArch64.</p>

</li><li>
<p>EL0 is determined by the Execution state described in the current process state when executing at EL0.</p>

</li></ul></td></tr></table><p>If AArch32 state is supported by the implementation at EL1, SCR_EL3.NS == 1 and AArch32 state is not supported by the implementation at EL2, the Effective value of this bit is 1.</p>
<p>If AArch32 state is supported by the implementation at EL1, <span class="xref">FEAT_SEL2</span> is implemented and SCR_EL3.{EEL2, NS} == {1, 0}, the Effective value of this bit is 1.</p>
<p>This bit is permitted to be cached in a TLB.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-10_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Reserved, RAO/WI.</p>
    </div><h4 id="fieldset_0-9_9">SIF, bit [9]</h4><div class="field">
      <p>Secure instruction fetch. When the PE is in Secure state, this bit disables instruction execution from memory marked in the first stage of translation as being Non-secure.</p>
    <table class="valuetable"><tr><th>SIF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>Secure state instruction execution from memory marked in the first stage of translation as being Non-secure is permitted.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Secure state instruction execution from memory marked in the first stage of translation as being Non-secure is not permitted.</p>
        </td></tr></table><p>When <span class="xref">FEAT_RME</span> is implemented and Secure state is not implemented, this bit is <span class="arm-defined-word">RES0</span>.</p>
<p>When <span class="xref">FEAT_PAN3</span> is implemented, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether SCR_EL3.SIF is also used to determine instruction access permission for the purpose of PAN.</p>
<p>This bit is permitted to be cached in a TLB.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-8_8">HCE, bit [8]</h4><div class="field">
      <p>Hypervisor Call instruction enable. Enables HVC instructions at EL3 and, if EL2 is enabled in the current Security state, at EL2 and EL1, in both Execution states, reported using an ESR_ELx.EC value of <span class="hexnumber">0x00</span>.</p>
    <table class="valuetable"><tr><th>HCE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p>HVC instructions are <span class="arm-defined-word">UNDEFINED</span>.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p>HVC instructions are enabled at EL3, EL2, and EL1.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p>HVC instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0 and, if Secure EL2 is disabled, at Secure EL1. Any resulting exception is taken from the current Exception level to the current Exception level.</p>
      </div>
      <p>If EL2 is not implemented, this bit is <span class="arm-defined-word">RES0</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_7">SMD, bit [7]</h4><div class="field">
      <p>Secure Monitor Call disable. Disables <span class="instruction">SMC</span> instructions at EL1 and above, from any Security state and both Execution states, reported using an ESR_ELx.EC value of <span class="hexnumber">0x00</span>.</p>
    <table class="valuetable"><tr><th>SMD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td>
          <p><span class="instruction">SMC</span> instructions are enabled at EL3, EL2 and EL1.</p>
        </td></tr><tr><td class="bitfield">0b1</td><td>
          <p><span class="instruction">SMC</span> instructions are <span class="arm-defined-word">UNDEFINED</span>.</p>
        </td></tr></table>
      <div class="note"><span class="note-header">Note</span>
        <p><span class="instruction">SMC</span> instructions are always <span class="arm-defined-word">UNDEFINED</span> at EL0. Any resulting exception is taken from the current Exception level to the current Exception level.</p>
        <p>If <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TSC or <a href="AArch32-hcr.html">HCR</a>.TSC traps attempted EL1 execution of <span class="instruction">SMC</span> instructions to EL2, that trap has priority over this disable.</p>
      </div>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_6">Bit [6]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><h4 id="fieldset_0-5_4">Bits [5:4]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES1</span>.</p>
    </div><h4 id="fieldset_0-3_3">EA, bit [3]</h4><div class="field">
      <p>External Abort and SError interrupt routing.</p>
    <table class="valuetable"><tr><th>EA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When executing at Exception levels below EL3, External aborts and SError interrupts are not taken to EL3.</p>
<p>In addition, when executing at EL3:</p>
<ul>
<li>
<p>SError interrupts are not taken.</p>

</li><li>
<p>External aborts are taken to EL3.</p>

</li></ul></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>When executing at any Exception level, External aborts and SError interrupts are taken to EL3.</p>
        </td></tr></table>
      <p>For more information, see <span class="xref">'Asynchronous exception routing'</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-2_2">FIQ, bit [2]</h4><div class="field">
      <p>Physical FIQ Routing.</p>
    <table class="valuetable"><tr><th>FIQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When executing at Exception levels below EL3, physical FIQ interrupts are not taken to EL3.</p>
<p>When executing at EL3, physical FIQ interrupts are not taken.</p></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>When executing at any Exception level, physical FIQ interrupts are taken to EL3.</p>
        </td></tr></table>
      <p>For more information, see <span class="xref">'Asynchronous exception routing'</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-1_1">IRQ, bit [1]</h4><div class="field">
      <p>Physical IRQ Routing.</p>
    <table class="valuetable"><tr><th>IRQ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When executing at Exception levels below EL3, physical IRQ interrupts are not taken to EL3.</p>
<p>When executing at EL3, physical IRQ interrupts are not taken.</p></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>When executing at any Exception level, physical IRQ interrupts are taken to EL3.</p>
        </td></tr></table>
      <p>For more information, see <span class="xref">'Asynchronous exception routing'</span>.</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-0_0-1">NS, bit [0]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field">
      <p>Non-secure bit. This field is used in combination with SCR_EL3.NSE to select the Security state of EL2 and lower Exception levels.</p>
    <table class="valuetable"><thead><tr><th>NSE</th><th>NS</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b0</span></td><td>Secure.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b1</span></td><td>Non-secure.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b0</span></td><td>Reserved.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b1</span></td><td>Realm.</td></tr></tbody></table>
<p>When Secure state is not implemented, SCR_EL3.NS is <span class="arm-defined-word">RES1</span> and its effective value is 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-0_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field">
      <p>Non-secure bit.</p>
    <table class="valuetable"><tr><th>NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Indicates that EL0 and EL1 are in Secure state.</p>
<p>When <span class="xref">FEAT_SEL2</span> is implemented and SCR_EL3.EEL2 == 1, then EL2 is using AArch64 and in Secure state.</p></td></tr><tr><td class="bitfield">0b1</td><td>
          <p>Indicates that Exception levels lower than EL3 are in Non-secure state, so memory accesses from those Exception levels cannot access Secure memory.</p>
        </td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing SCR_EL3</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt&gt;, SCR_EL3</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    X[t, 64] = SCR_EL3;
                </p><h4 class="assembler">MSR SCR_EL3, &lt;Xt&gt;</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0001</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    SCR_EL3 = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:07; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
