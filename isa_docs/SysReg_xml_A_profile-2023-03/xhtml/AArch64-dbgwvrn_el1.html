<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>DBGWVR&lt;n&gt;_EL1</title>
    <link href="insn.css" rel="stylesheet" type="text/css"/>
  </head>
  <body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">DBGWVR&lt;n&gt;_EL1, Debug Watchpoint Value Registers, n = 0 - 63</h1><p>The DBGWVR&lt;n&gt;_EL1 characteristics are:</p><h2>Purpose</h2>
        <p>Holds a data address value for use in watchpoint matching. Forms watchpoint n together with control register <a href="AArch64-dbgwcrn_el1.html">DBGWCR&lt;n&gt;_EL1</a>.</p>
      <h2>Configuration</h2><p>AArch64 System register DBGWVR&lt;n&gt;_EL1 bits [31:0] are architecturally mapped to AArch32 System register <a href="AArch32-dbgwvrn.html">DBGWVR&lt;n&gt;[31:0]</a>.</p><p>AArch64 System register DBGWVR&lt;n&gt;_EL1 bits [63:0] are architecturally mapped to External register <a href="ext-dbgwvrn_el1.html">DBGWVR&lt;n&gt;_EL1[63:0]</a>.</p>
        <p>If watchpoint n is not implemented then accesses to this register are <span class="arm-defined-word">UNDEFINED</span>.</p>
      <h2>Attributes</h2>
        <p>DBGWVR&lt;n&gt;_EL1 is a 64-bit register.</p>
      <h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="7"><a href="#fieldset_0-63_57">RESS[14:8]</a></td><td class="lr" colspan="4"><a href="#fieldset_0-56_53-1">Bits[56:53]</a></td><td class="lr" colspan="4"><a href="#fieldset_0-52_49-1">Bits[52:49]</a></td><td class="lr" colspan="17"><a href="#fieldset_0-48_2">VA[48:2]</a></td></tr><tr class="firstrow"><td class="lr" colspan="30"><a href="#fieldset_0-48_2">VA[48:2]</a></td><td class="lr" colspan="2"><a href="#fieldset_0-1_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-63_57">RESS[14:8], bits [63:57]</h4><div class="field"><p>Reserved, Sign extended. Software must set all bits in this field to the same value as the most significant bit of the VA field. If all bits in this field are not the same value as the most significant bit of the VA field, then all of the following apply:</p>
<ul>
<li>It is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span> whether the PE ignores this field when comparing an address.
</li><li>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the value read back in each bit of this field is a copy of the most significant bit of the VA field or the value written.
</li></ul></div><h4 id="fieldset_0-56_53-1">Bits[56:53]<span class="condition"><br/>When FEAT_LVA3 is implemented:
                        </span></h4><h5>VA[56:53], bits [3:0]
                 of bits 
                        [56:53]</h5><div class="field">
      <p>Extension to VA[48:2]. For more information, see VA[48:2].</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-56_53-2"><span class="condition"><br/>Otherwise:
                        </span></h4><h5>RESS[7:4], bits [3:0]
                 of bits 
                        [56:53]</h5><div class="field">
      <p>Extension to RESS[14:8]. For more information, see RESS[14:8].</p>
    </div><h4 id="fieldset_0-52_49-1">Bits[52:49]<span class="condition"><br/>When FEAT_LVA is implemented:
                        </span></h4><h5>VA[52:49], bits [3:0]
                 of bits 
                        [52:49]</h5><div class="field">
      <p>Extension to VA[48:2]. For more information, see VA[48:2].</p>
    <p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-52_49-2"><span class="condition"><br/>Otherwise:
                        </span></h4><h5>RESS[3:0], bits [3:0]
                 of bits 
                        [52:49]</h5><div class="field">
      <p>Extension to RESS[14:8]. For more information, see RESS[14:8].</p>
    </div><h4 id="fieldset_0-48_2">VA[48:2], bits [48:2]</h4><div class="field"><p>Bits[48:2] of the address value for comparison.</p>
<p>When <span class="xref">FEAT_LVA3</span> is implemented, (VA[56:53]:VA[52:49]) forms the upper part of the address value. If FEAT_LVA3 is not implemented, bits VA[56:53] are part of the RESS field.</p>
<p>When <span class="xref">FEAT_LVA</span> is implemented, VA[52:49] forms the upper part of the address value. If FEAT_LVA is not implemented, bits [52:49] are part of the RESS field.</p>
<p>Arm deprecates setting <a href="AArch64-dbgwvrn_el1.html">DBGWVR&lt;n&gt;_EL1</a>[2] == 1.</p><p>The reset behavior of this field is:</p><ul><li>On a Cold reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-1_0">Bits [1:0]</h4><div class="field">
      <p>Reserved, <span class="arm-defined-word">RES0</span>.</p>
    </div><div class="access_mechanisms"><h2>Accessing DBGWVR&lt;n&gt;_EL1</h2>
        <p>When <span class="xref">FEAT_Debugv8p9</span> is implemented, a PE is permitted to support up to 64 implemented watchpoints.</p>
      <p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt&gt;, DBGWVR&lt;m&gt;_EL1
     ; Where m = 0-15</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b10</td><td>0b000</td><td>0b0000</td><td>m[3:0]</td><td>0b110</td></tr></table><p class="pseudocode">
integer m = UInt(CRm&lt;3:0&gt;);

if (!IsFeatureImplemented(FEAT_Debugv8p9) &amp;&amp; m &gt;= NUM_WATCHPOINTS) || (IsFeatureImplemented(FEAT_Debugv8p9) &amp;&amp; m + (UInt(MDSELR_EL1.BANK) * 16) &gt;= NUM_WATCHPOINTS) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; MDCR_EL3.TDA == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGRTR_EL2.DBGWVRn_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.&lt;TDE,TDA&gt; != '00' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            X[t, 64] = DBGWVR_EL1[m + (UInt(EffectiveMDSELR_EL1_BANK()) * 16)];
        else
            X[t, 64] = DBGWVR_EL1[m];
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; MDCR_EL3.TDA == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            X[t, 64] = DBGWVR_EL1[m + (UInt(EffectiveMDSELR_EL1_BANK()) * 16)];
        else
            X[t, 64] = DBGWVR_EL1[m];
elsif PSTATE.EL == EL3 then
    if OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            X[t, 64] = DBGWVR_EL1[m + (UInt(EffectiveMDSELR_EL1_BANK()) * 16)];
        else
            X[t, 64] = DBGWVR_EL1[m];
                </p><h4 class="assembler">MSR DBGWVR&lt;m&gt;_EL1, &lt;Xt&gt;
     ; Where m = 0-15</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b10</td><td>0b000</td><td>0b0000</td><td>m[3:0]</td><td>0b110</td></tr></table><p class="pseudocode">
integer m = UInt(CRm&lt;3:0&gt;);

if (!IsFeatureImplemented(FEAT_Debugv8p9) &amp;&amp; m &gt;= NUM_WATCHPOINTS) || (IsFeatureImplemented(FEAT_Debugv8p9) &amp;&amp; m + (UInt(MDSELR_EL1.BANK) * 16) &gt;= NUM_WATCHPOINTS) then
    UNDEFINED;
elsif PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; MDCR_EL3.TDA == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HDFGWTR_EL2.DBGWVRn_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; MDCR_EL2.&lt;TDE,TDA&gt; != '00' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            DBGWVR_EL1[m + (UInt(EffectiveMDSELR_EL1_BANK()) * 16)] = X[t, 64];
        else
            DBGWVR_EL1[m] = X[t, 64];
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; MDCR_EL3.TDA == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; MDCR_EL3.TDA == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            DBGWVR_EL1[m + (UInt(EffectiveMDSELR_EL1_BANK()) * 16)] = X[t, 64];
        else
            DBGWVR_EL1[m] = X[t, 64];
elsif PSTATE.EL == EL3 then
    if OSLSR_EL1.OSLK == '0' &amp;&amp; HaltingAllowed() &amp;&amp; EDSCR.TDA == '1' then
        Halt(DebugHalt_SoftwareAccess);
    else
        if IsFeatureImplemented(FEAT_Debugv8p9) then
            DBGWVR_EL1[m + (UInt(EffectiveMDSELR_EL1_BANK()) * 16)] = X[t, 64];
        else
            DBGWVR_EL1[m] = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">30/03/2023 19:06; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p></body>
</html>
