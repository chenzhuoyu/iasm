<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2023 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<!--The data contained in this document is preliminary and subject to change or correction following further review. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>







<register_page>
  <registers>
  
    <register is_register="True" is_internal="False" is_banked="False" is_stub_entry="False">
      <reg_short_name>ERR&lt;n&gt;CTLR</reg_short_name>
        
        <reg_long_name>Error Record &lt;n&gt; Control Register</reg_long_name>



      
        <reg_condition otherwise="RES0">when error record &lt;n&gt; is implemented and error record &lt;n&gt; is the first error record owned by a node</reg_condition>
          <reg_array>
              <reg_array_start>0</reg_array_start>
              <reg_array_end>65534</reg_array_end>
         </reg_array>
      
  <reg_address
      external_access="False"
    mem_map_access="True"
      power_domain="None"
  >
    <reg_component>RAS</reg_component>
    <reg_offset><hexnumber>0x008</hexnumber> + (64 * n)</reg_offset>
    <reg_instance>ERR&lt;n&gt;CTLR</reg_instance>
    <reg_access>
      
        
      <reg_access_state>
          <reg_access_type>RW</reg_access_type>
      </reg_access_state>
    </reg_access>
</reg_address>



          <reg_reset_value>

      </reg_reset_value>

      <reg_mappings>
        




      </reg_mappings>

        <reg_purpose>
          
    
      <purpose_text>
        <para>The error control register contains enable bits for the node that writes to this record:</para>

      </purpose_text>
      <purpose_text>
        <list type="unordered">
<listitem><content>Enabling error detection and correction.</content>
</listitem><listitem><content>Enabling the critical error, error recovery, and fault handling interrupts.</content>
</listitem><listitem><content>Enabling in-band error response for uncorrected errors.</content>
</listitem></list>

      </purpose_text>
      <purpose_text>
        <para>For each bit, if the node does not support the feature, then the bit is <arm-defined-word>RES0</arm-defined-word>. The definition of each record is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>.</para>
      </purpose_text>

        </reg_purpose>

      <reg_groups>
          <reg_group>RAS registers</reg_group>
      </reg_groups>
      <reg_configuration>
        
    
      <configuration_text>
        <para><register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link> contains additional information about the node.</para>
      </configuration_text>

      </reg_configuration>
      
      
        
      <reg_attributes>
          
    
      <attributes_text>
        <para>ERR&lt;n&gt;CTLR is a 64-bit register.</para>
      </attributes_text>

      </reg_attributes>
      <reg_fieldsets>
        






<fields id="fieldset_0" length="64">
  <fields_instance>ERR&lt;n&gt;CTLR</fields_instance>
  <text_before_fields/>
  <field id="fieldset_0-63_32" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>IMPLEMENTATION DEFINED</field_name>
    <field_msb>63</field_msb>
    <field_lsb>32</field_lsb>
    <rel_range>63:32</rel_range>
    <field_description order="before">
      <para>Reserved for <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> controls. Must permit SBZP write policy for software.</para>
    </field_description>
  </field>
  <field id="fieldset_0-31_16" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>31</field_msb>
    <field_lsb>16</field_lsb>
    <rel_range>31:16</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-15_15-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>WDFI</field_name>
    <field_msb>15</field_msb>
    <field_lsb>15</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt for Deferred errors on writes enable, with ERR&lt;n&gt;CTLR.WFI.</para>
<para>When enabled by ERR&lt;n&gt;CTLR.{WDFI, <instruction>WFI</instruction>}:</para>
<list type="unordered">
<listitem><content>The fault handling interrupt is generated for errors recorded as Deferred error on writes.</content>
</listitem><listitem><content>If the corresponding fault handling interrupt control for corrected error events, ERR&lt;n&gt;CTLR.WCFI, is not implemented, then the fault handling interrupt is generated for corrected error events on writes.</content>
</listitem></list></field_description>
    <field_description order="after"><para>See ERR&lt;n&gt;CTLR.CFI for more information on corrected error events.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description><para>When ERR&lt;n&gt;CTLR.WFI == 0, Fault handling interrupt not generated for Deferred errors on writes.</para>
<para>When ERR&lt;n&gt;CTLR.WFI == 1, Fault handling interrupt generated for Deferred errors on writes.</para></field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>When ERR&lt;n&gt;CTLR.WFI == 0, Fault handling interrupt generated for Deferred errors on writes.</para>
<para>When ERR&lt;n&gt;CTLR.WFI == 1, Fault handling interrupt not generated for Deferred errors on writes.</para></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When RAS System Architecture v2 is implemented and ERR&lt;n&gt;FR.DFI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-15_15-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>15</field_msb>
    <field_lsb>15</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-14_14-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>DFI</field_name>
    <field_msb>14</field_msb>
    <field_lsb>14</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt for Deferred errors enable, with ERR&lt;n&gt;CTLR.FI.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.DFI == <binarynumber>0b10</binarynumber>, this control applies to errors on both reads and writes.</para>
<para>When enabled by ERR&lt;n&gt;CTLR.{DFI, FI}:</para>
<list type="unordered">
<listitem><content>The fault handling interrupt is generated for all errors recorded as Deferred error.</content>
</listitem><listitem><content>If the fault handling interrupt control for corrected error events, ERR&lt;n&gt;CTLR.CFI, is not implemented, then the fault handling interrupt is generated for all corrected error events.</content>
</listitem></list></field_description>
    <field_description order="after"><para>See ERR&lt;n&gt;CTLR.CFI for more information on corrected error events.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description><para>When ERR&lt;n&gt;CTLR.FI == 0, Fault handling interrupt not generated for Deferred errors.</para>
<para>When ERR&lt;n&gt;CTLR.FI == 1, Fault handling interrupt generated for Deferred errors.</para></field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>When ERR&lt;n&gt;CTLR.FI == 0, Fault handling interrupt generated for Deferred errors.</para>
<para>When ERR&lt;n&gt;CTLR.FI == 1, Fault handling interrupt not generated for Deferred errors.</para></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When RAS System Architecture v2 is implemented and ERR&lt;n&gt;FR.DFI == 0b10</fields_condition>
  </field>
  <field id="fieldset_0-14_14-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>RDFI</field_name>
    <field_msb>14</field_msb>
    <field_lsb>14</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt for Deferred errors on reads enable, with ERR&lt;n&gt;CTLR.RFI.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.DFI == <binarynumber>0b11</binarynumber>, this field is named RDFI.</para>
<para>When enabled by ERR&lt;n&gt;CTLR.{RDFI, RFI}:</para>
<list type="unordered">
<listitem><content>The fault handling interrupt is generated for errors recorded as Deferred error on reads.</content>
</listitem><listitem><content>If the corresponding fault handling interrupt control for corrected error events, ERR&lt;n&gt;CTLR.RCFI, is not implemented, then the fault handling interrupt is generated for corrected error events on reads.</content>
</listitem></list></field_description>
    <field_description order="after"><para>See ERR&lt;n&gt;CTLR.CFI for more information on corrected error events.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description><para>When ERR&lt;n&gt;CTLR.RFI == 0, Fault handling interrupt not generated for Deferred errors on reads.</para>
<para>When ERR&lt;n&gt;CTLR.RFI == 1, Fault handling interrupt generated for Deferred errors on reads.</para></field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>When ERR&lt;n&gt;CTLR.RFI == 0, Fault handling interrupt generated for Deferred errors on reads.</para>
<para>When ERR&lt;n&gt;CTLR.RFI == 1, Fault handling interrupt not generated for Deferred errors on reads.</para></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When RAS System Architecture v2 is implemented and ERR&lt;n&gt;FR.DFI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-14_14-3" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>14</field_msb>
    <field_lsb>14</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-13_13-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>CI</field_name>
    <field_msb>13</field_msb>
    <field_lsb>13</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Critical error interrupt enable. When enabled, the critical error interrupt is generated for a critical error condition.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Critical error interrupt not generated for critical errors. Critical errors are treated as Uncontained errors.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Critical error interrupt generated for critical errors.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.CI == 0b10</fields_condition>
  </field>
  <field id="fieldset_0-13_13-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>13</field_msb>
    <field_lsb>13</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-12_12-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>CED</field_name>
    <field_msb>12</field_msb>
    <field_lsb>12</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Disable generation of corrected error events from error counters.</para>
    </field_description>
    <field_description order="after">
      <para>See ERR&lt;n&gt;CTLR.CFI for more information on corrected error events.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Corrected error events are generated by the error counter or counters.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Corrected error events are generated when a Corrected error is recorded.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When RAS System Architecture v2 is implemented, ERR&lt;n&gt;FR.CEC != 0b000 and ERR&lt;n&gt;FR.CED == 1</fields_condition>
  </field>
  <field id="fieldset_0-12_12-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>12</field_msb>
    <field_lsb>12</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-11_11-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>WDUI</field_name>
    <field_msb>11</field_msb>
    <field_lsb>11</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Error recovery interrupt for Deferred errors on writes enable.</para>
<para>When enabled, the error recovery interrupt is generated for errors recorded as Deferred error on writes.</para></field_description>
    <field_description order="after">
      <para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Error recovery interrupt not generated for Deferred errors on writes.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Error recovery interrupt generated for Deferred errors on writes.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.DUI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-11_11-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>11</field_msb>
    <field_lsb>11</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-10_10-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>DUI</field_name>
    <field_msb>10</field_msb>
    <field_lsb>10</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Error recovery interrupt for Deferred errors enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.DUI == <binarynumber>0b10</binarynumber>, this control applies to errors arising from both reads and writes.</para>
<para>When enabled, the error recovery interrupt is generated for all errors recorded as Deferred error.</para></field_description>
    <field_description order="after">
      <para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Error recovery interrupt not generated for Deferred errors.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Error recovery interrupt generated for Deferred errors.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.DUI == 0b10</fields_condition>
  </field>
  <field id="fieldset_0-10_10-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>RDUI</field_name>
    <field_msb>10</field_msb>
    <field_lsb>10</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Error recovery interrupt for Deferred errors on reads enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.DUI == <binarynumber>0b11</binarynumber>, this field is named RDUI.</para>
<para>When enabled, the error recovery interrupt is generated for errors recorded as Deferred error on reads.</para></field_description>
    <field_description order="after">
      <para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Error recovery interrupt not generated for Deferred errors on reads.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Error recovery interrupt generated for Deferred errors on reads.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.DUI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-10_10-3" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>10</field_msb>
    <field_lsb>10</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-9_9-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>WCFI</field_name>
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt for corrected error events on writes enable.</para>
<para>When enabled, the fault handling interrupt is generated for corrected error events on writes.</para></field_description>
    <field_description order="after"><para>See ERR&lt;n&gt;CTLR.CFI for more information on corrected error events.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Fault handling interrupt not generated for corrected error events on writes.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Fault handling interrupt generated for corrected error events on writes.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.CFI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-9_9-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-8_8-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>CFI</field_name>
    <field_msb>8</field_msb>
    <field_lsb>8</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt for corrected error events enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.CFI == <binarynumber>0b10</binarynumber>, this control applies to errors on both reads and writes.</para>
<para>When enabled, the fault handling interrupt is generated for all corrected error events.</para></field_description>
    <field_description order="after"><para>If the node implements a corrected error counter or counters, and either ERR&lt;n&gt;CTLR.CED is not implemented or ERR&lt;n&gt;CTLR.CED is 0, then a corrected error event is defined as follows:</para>
<list type="unordered">
<listitem><content>
<para>A corrected error event occurs when a counter overflows and sets a counter overflow flag to 1.</para>
</content>
</listitem><listitem><content>
<para>It is <arm-defined-word>UNPREDICTABLE</arm-defined-word> whether a corrected error event occurs when a software write sets a counter overflow flag to 1.</para>
</content>
</listitem><listitem><content>
<para>It is <arm-defined-word>UNPREDICTABLE</arm-defined-word> whether a corrected error event occurs when a counter overflows and the overflow flag was previously set to 1.</para>
</content>
</listitem></list>
<para>Otherwise, a corrected error event occurs when the error record records an error as a Corrected error.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Fault handling interrupt not generated for corrected error events.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Fault handling interrupt generated for corrected error events.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.CFI == 0b10</fields_condition>
  </field>
  <field id="fieldset_0-8_8-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>RCFI</field_name>
    <field_msb>8</field_msb>
    <field_lsb>8</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt for corrected error events on reads enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.CFI == <binarynumber>0b11</binarynumber>, this field is named RCFI.</para>
<para>When enabled, the fault handling interrupt is generated for corrected error events on reads.</para></field_description>
    <field_description order="after"><para>If the node implements a corrected error counter or counters, and either ERR&lt;n&gt;CTLR.CED is not implemented or ERR&lt;n&gt;CTLR.CED is 0, then a corrected error event is defined as follows:</para>
<list type="unordered">
<listitem><content>
<para>A corrected error event occurs when a counter overflows and sets a counter overflow flag to 1.</para>
</content>
</listitem><listitem><content>
<para>It is <arm-defined-word>UNPREDICTABLE</arm-defined-word> whether a corrected error event occurs when a software write sets a counter overflow flag to 1.</para>
</content>
</listitem><listitem><content>
<para>It is <arm-defined-word>UNPREDICTABLE</arm-defined-word> whether a corrected error event occurs when a counter overflows and the overflow flag was previously set to 1.</para>
</content>
</listitem></list>
<para>Otherwise, a corrected error event occurs when the error record records an error as a Corrected error.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Fault handling interrupt not generated for corrected error events on reads.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Fault handling interrupt generated for corrected error events on reads.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.CFI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-8_8-3" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>8</field_msb>
    <field_lsb>8</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-7_7-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>WUE</field_name>
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>In-band error response on writes enable.</para>
<para>When enabled, responses to writes that detect an error that is not corrected and is not deferred are signaled with an in-band error response (External Abort).</para>
<para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether an uncorrected error that is deferred and recorded as Deferred error, but is not deferred to the Requester, will signal an in-band error response to the Requester.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>In-band error response for uncorrected errors on writes disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>In-band error response for uncorrected errors on writes enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.UE == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-7_7-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-6_6-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>WFI</field_name>
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt on writes enable.</para>
<para>When enabled:</para>
<list type="unordered">
<listitem><content>The fault handling interrupt is generated for errors recorded as Uncorrected error on writes.</content>
</listitem><listitem><content>If the corresponding fault handling interrupt control for Deferred errors, ERR&lt;n&gt;CTLR.WDFI, is not implemented, then the fault handling interrupt is generated for errors recorded as Deferred error on writes.</content>
</listitem><listitem><content>If the corresponding fault handling interrupt controls for Deferred errors and corrected error events, ERR&lt;n&gt;CTLR.{WDFI, WCFI}, are not implemented, then the fault handling interrupt is generated for corrected error events on writes.</content>
</listitem></list></field_description>
    <field_description order="after"><para>See ERR&lt;n&gt;CTLR.CFI for more information on corrected error events.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Fault handling interrupt on writes disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Fault handling interrupt on writes enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.FI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-6_6-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-5_5-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>WUI</field_name>
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Uncorrected error recovery interrupt on writes enable.</para>
<para>When enabled, the error recovery interrupt is generated for errors recorded as Uncorrected error on writes.</para></field_description>
    <field_description order="after">
      <para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Error recovery interrupt on writes disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Error recovery interrupt on writes enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.UI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-5_5-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-4_4-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>UE</field_name>
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>In-band error response enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.UE == <binarynumber>0b10</binarynumber>, this control applies to errors arising from both reads and writes.</para>
<para>When enabled, responses to transactions that detect an error that is not corrected and is not deferred are signaled with an in-band error response (External Abort).</para>
<para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether an uncorrected error that is deferred and recorded as Deferred error, but is not deferred to the Requester, will signal an in-band error response to the Requester.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>In-band error response for uncorrected errors disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>In-band error response for uncorrected errors enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.UE == 0b10</fields_condition>
  </field>
  <field id="fieldset_0-4_4-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>RUE</field_name>
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>In-band error response on reads enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.UE == <binarynumber>0b11</binarynumber>, this field is named RUE.</para>
<para>When enabled, responses to reads that detect an error that is not corrected and is not deferred are signaled with an in-band error response (External Abort).</para>
<para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether an uncorrected error that is deferred and recorded as Deferred error, but is not deferred to the Requester, will signal an in-band error response to the Requester.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>In-band error response for uncorrected errors on reads disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>In-band error response for uncorrected errors on reads enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.UE == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-4_4-3" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-3_3-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>FI</field_name>
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.FI == <binarynumber>0b10</binarynumber>, this control applies to errors on both reads and writes.</para>
<para>When enabled:</para>
<list type="unordered">
<listitem><content>The fault handling interrupt is generated for all errors recorded as Uncorrected error.</content>
</listitem><listitem><content>If the fault handling interrupt control for Deferred errors, ERR&lt;n&gt;CTLR.DFI, is not implemented, then the fault handling interrupt is generated for all errors recorded as Deferred error.</content>
</listitem><listitem><content>If the fault handling interrupt controls for Deferred errors and corrected error events, ERR&lt;n&gt;CTLR.{DFI, CFI}, are not implemented, then the fault handling interrupt is generated for all corrected error events.</content>
</listitem></list></field_description>
    <field_description order="after"><para>See ERR&lt;n&gt;CTLR.CFI for more information on corrected error events.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Fault handling interrupt disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Fault handling interrupt enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.FI == 0b10</fields_condition>
  </field>
  <field id="fieldset_0-3_3-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>RFI</field_name>
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Fault handling interrupt on reads enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.FI == <binarynumber>0b11</binarynumber>, this field is named RFI.</para>
<para>When enabled:</para>
<list type="unordered">
<listitem><content>The fault handling interrupt is generated for errors recorded as Uncorrected error on reads.</content>
</listitem><listitem><content>If the corresponding fault handling interrupt control for Deferred errors, ERR&lt;n&gt;CTLR.RDFI, is not implemented, then the fault handling interrupt is generated for errors recorded as Deferred error on reads.</content>
</listitem><listitem><content>If the corresponding fault handling interrupt controls for Deferred errors and corrected error events, ERR&lt;n&gt;CTLR.{RDFI, RCFI}, are not implemented, then the fault handling interrupt is generated for corrected error events on reads.</content>
</listitem></list></field_description>
    <field_description order="after"><para>See ERR&lt;n&gt;CTLR.CFI for more information on corrected error events.</para>
<para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Fault handling interrupt on reads disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Fault handling interrupt on reads enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.FI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-3_3-3" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-2_2-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>UI</field_name>
    <field_msb>2</field_msb>
    <field_lsb>2</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Uncorrected error recovery interrupt enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.UI == <binarynumber>0b10</binarynumber>, this control applies to errors arising from both reads and writes.</para>
<para>When enabled, the error recovery interrupt is generated for all errors recorded as Uncorrected error.</para></field_description>
    <field_description order="after">
      <para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Error recovery interrupt disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Error recovery interrupt enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.UI == 0b10</fields_condition>
  </field>
  <field id="fieldset_0-2_2-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="True" reserved_type="RES0">
    <field_name>RUI</field_name>
    <field_msb>2</field_msb>
    <field_lsb>2</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Uncorrected error recovery interrupt on reads enable.</para>
<para>When <register_link state="ext" id="ext-errnfr.xml">ERR&lt;n&gt;FR</register_link>.UI == <binarynumber>0b11</binarynumber>, this field is named RUI.</para>
<para>When enabled, the error recovery interrupt is generated for errors recorded as Uncorrected error on reads.</para></field_description>
    <field_description order="after">
      <para>The interrupt is generated even if the error syndrome is discarded because the error record already records a higher priority error.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Error recovery interrupt on reads disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Error recovery interrupt on reads enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Cold">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.UI == 0b11</fields_condition>
  </field>
  <field id="fieldset_0-2_2-3" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>2</field_msb>
    <field_lsb>2</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-1_1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>IMPLEMENTATION DEFINED</field_name>
    <field_msb>1</field_msb>
    <field_lsb>1</field_lsb>
    <rel_range>1</rel_range>
    <field_description order="before">
      <para>Reserved for <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> controls. Must permit SBZP write policy for software.</para>
    </field_description>
  </field>
  <field id="fieldset_0-0_0-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>ED</field_name>
    <field_msb>0</field_msb>
    <field_lsb>0</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Error reporting and logging enable. When disabled, the node behaves as if error detection and correction are disabled, and no errors are recorded or signaled by the node. Arm recommends that, when disabled, correct error detection and correction codes are written for writes, unless disabled by an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> control for error injection.</para>
    </field_description>
    <field_description order="after"><para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether the node fully disables error detection and correction when reporting is disabled. That is, even with error reporting disabled, the node might continue to silently correct errors. Uncorrected errors might result in corrupt data being silently propagated by the node.</para>
<note><para>If this node requires initialization after Cold reset to prevent signaling false errors, then Arm recommends this field is set to 0 on Cold reset, meaning errors are not reported from Cold reset. This allows boot software to initialize a node without signaling errors. Software can enable error reporting after the node is initialized. Otherwise, the Cold reset value is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word>. If the Cold reset value is 1, the reset values of other controls in this register are also <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> and should not be <arm-defined-word>UNKNOWN</arm-defined-word>.</para></note></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Error reporting disabled.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Error reporting enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Error recovery">
        <field_reset_conditions>
          <field_reset_condition condition="RAS System Architecture v2 is implemented and ERR&lt;n&gt;FR.SRV == 1">
            <field_reset>
              <field_reset_number>0</field_reset_number>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
      <field_reset reset_type="Cold">
        <field_reset_conditions>
          <field_reset_condition condition="RAS System Architecture v2 is implemented and ERR&lt;n&gt;FR.SRV == 1">
            <field_reset>
              <field_reset_number>0</field_reset_number>
            </field_reset>
          </field_reset_condition>
          <field_reset_condition>
            <field_reset impdef="true">
              <field_reset_standard_text>ID</field_reset_standard_text>
            </field_reset>
          </field_reset_condition>
        </field_reset_conditions>
      </field_reset>
    </field_resets>
    <fields_condition>When ERR&lt;n&gt;FR.ED == 0b10</fields_condition>
  </field>
  <field id="fieldset_0-0_0-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>0</field_msb>
    <field_lsb>0</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <text_after_fields/>
</fields>




    
<reg_fieldset length="64">
  <fieldat id="fieldset_0-63_32" msb="63" lsb="32"/>
  <fieldat id="fieldset_0-31_16" msb="31" lsb="16"/>
  <fieldat id="fieldset_0-15_15-1" msb="15" lsb="15"/>
  <fieldat id="fieldset_0-14_14-1" label="Bit[14]" msb="14" lsb="14"/>
  <fieldat id="fieldset_0-13_13-1" msb="13" lsb="13"/>
  <fieldat id="fieldset_0-12_12-1" msb="12" lsb="12"/>
  <fieldat id="fieldset_0-11_11-1" msb="11" lsb="11"/>
  <fieldat id="fieldset_0-10_10-1" label="Bit[10]" msb="10" lsb="10"/>
  <fieldat id="fieldset_0-9_9-1" msb="9" lsb="9"/>
  <fieldat id="fieldset_0-8_8-1" label="Bit[8]" msb="8" lsb="8"/>
  <fieldat id="fieldset_0-7_7-1" msb="7" lsb="7"/>
  <fieldat id="fieldset_0-6_6-1" msb="6" lsb="6"/>
  <fieldat id="fieldset_0-5_5-1" msb="5" lsb="5"/>
  <fieldat id="fieldset_0-4_4-1" label="Bit[4]" msb="4" lsb="4"/>
  <fieldat id="fieldset_0-3_3-1" label="Bit[3]" msb="3" lsb="3"/>
  <fieldat id="fieldset_0-2_2-1" label="Bit[2]" msb="2" lsb="2"/>
  <fieldat id="fieldset_0-1_1" msb="1" lsb="1"/>
  <fieldat id="fieldset_0-0_0-1" msb="0" lsb="0"/>
</reg_fieldset>


      </reg_fieldsets>
        <reg_variables>
              <reg_variable variable="n" max="65534"/>
        </reg_variables>

      <access_mechanisms>
          







      </access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>30/03/2023 19:07; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</timestamp>
</register_page>