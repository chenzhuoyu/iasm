<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2023 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<!--The data contained in this document is preliminary and subject to change or correction following further review. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>







<register_page>
  <registers>
  
    <register execution_state="AArch32" is_register="True" is_internal="True" is_banked="False" is_stub_entry="False">
      <reg_short_name>SCTLR</reg_short_name>
        
        <reg_long_name>System Control Register</reg_long_name>



      
        <reg_condition otherwise="UNDEFINED">when EL1 is capable of using AArch32</reg_condition>
      



          <reg_reset_value></reg_reset_value>

      <reg_mappings>
        



      
      <reg_mapping>
        
  

    

    <mapped_name filename="AArch64-sctlr_el1.xml">SCTLR_EL1</mapped_name>
  <mapped_type>Architectural</mapped_type>
      <mapped_execution_state>AArch64</mapped_execution_state>
    <mapped_from_startbit>31</mapped_from_startbit>
    <mapped_from_endbit>0</mapped_from_endbit>
    <mapped_to_startbit>31</mapped_to_startbit>
    <mapped_to_endbit>0</mapped_to_endbit>
    <mapped_from_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_to_rangeset>

      </reg_mapping>

      </reg_mappings>

        <reg_purpose>
          
    
      <purpose_text>
        <para>Provides the top level control of the system, including its memory system.</para>
      </purpose_text>

        </reg_purpose>

      <reg_groups>
          <reg_group>Other system control registers</reg_group>
      </reg_groups>
      <reg_configuration>
        
    
      <configuration_text>
        <para>Some bits in the register are read-only. These bits relate to non-configurable features of an implementation, and are provided for compatibility with previous versions of the architecture.</para>
      </configuration_text>

      </reg_configuration>
      
      
        
      <reg_attributes>
          
    
      <attributes_text>
        <para>SCTLR is a 32-bit register.</para>
      </attributes_text>

      </reg_attributes>
      <reg_fieldsets>
        






<fields id="fieldset_0" length="32">
  <text_before_fields/>
  <field id="fieldset_0-31_31-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>DSSBS</field_name>
    <field_msb>31</field_msb>
    <field_lsb>31</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Default PSTATE.SSBS value on Exception Entry. The defined values are:</para>
    </field_description>
    <field_description order="after">
      <note>
        <para>When EL3 is implemented and is using AArch32, this bit is banked between the two Security states.</para>
      </note>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>PSTATE.SSBS is set to 0 on an exception to any mode in this security state except Hyp mode</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>PSTATE.SSBS is set to 1 on an exception to any mode in this security state except Hyp mode</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm" impdef="true">
        <field_reset_standard_text>ID</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_SSBS is implemented</fields_condition>
  </field>
  <field id="fieldset_0-31_31-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>31</field_msb>
    <field_lsb>31</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-30_30" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>TE</field_name>
    <field_msb>30</field_msb>
    <field_lsb>30</field_lsb>
    <rel_range>30</rel_range>
    <field_description order="before">
      <para>T32 Exception Enable. This bit controls whether exceptions to an Exception level that is executing at PL1 are taken to A32 or T32 state:</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Exceptions, including reset, taken to A32 state.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Exceptions, including reset, taken to T32 state.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm" impdef="true">
        <field_reset_standard_text>ID</field_reset_standard_text>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-29_29" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>AFE</field_name>
    <field_msb>29</field_msb>
    <field_lsb>29</field_lsb>
    <rel_range>29</rel_range>
    <field_description order="before">
      <para>Access Flag Enable. When using the Short-descriptor translation table format for the PL1&amp;0 translation regime, this bit enables use of the AP[0] bit in the translation descriptors as the Access flag, and restricts access permissions in the translation descriptors to the simplified model.</para>
    </field_description>
    <field_description order="after"><para>When using the Long-descriptor translation table format, the VMSA behaves as if this bit is set to 1, regardless of the value of this bit.</para>
<para>The AFE bit is permitted to be cached in a TLB.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>In the Translation table descriptors, AP[0] is an access permissions bit. The full range of access permissions is supported. No Access flag is implemented.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>In the Translation table descriptors, AP[0] is the Access flag. Only the simplified model for access permissions is supported.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-28_28" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>TRE</field_name>
    <field_msb>28</field_msb>
    <field_lsb>28</field_lsb>
    <rel_range>28</rel_range>
    <field_description order="before">
      <para>TEX remap enable. This bit enables remapping of the TEX[2:1] bits in the PL1&amp;0 translation regime for use as two translation table bits that can be managed by the operating system. Enabling this remapping also changes the scheme used to describe the memory region attributes in the VMSA.</para>
    </field_description>
    <field_description order="after"><para>When the value of <register_link state="AArch32" id="AArch32-ttbcr.xml">TTBCR</register_link>.EAE is 1, this bit is <arm-defined-word>RES1</arm-defined-word>.</para>
<para>The TRE bit is permitted to be cached in a TLB.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>TEX remap disabled. TEX[2:0] are used, with the C and B bits, to describe the memory region attributes.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>TEX remap enabled. TEX[2:1] are reassigned for use as bits managed by the operating system. The TEX[0], C, and B bits are used to describe the memory region attributes, with the MMU remap registers.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-27_26" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>27</field_msb>
    <field_lsb>26</field_lsb>
    <rel_range>27:26</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-25_25" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>EE</field_name>
    <field_msb>25</field_msb>
    <field_lsb>25</field_lsb>
    <rel_range>25</rel_range>
    <field_description order="before">
      <para>The value of the PSTATE.E bit on branch to an exception vector or coming out of reset, and the endianness of stage 1 translation table walks in the PL1&amp;0 translation regime.</para>
    </field_description>
    <field_description order="after"><para>If an implementation does not provide Big-endian support for data accesses at Exception levels higher than EL0, this bit is <arm-defined-word>RES0</arm-defined-word>.</para>
<para>If an implementation does not provide Little-endian support for data accesses at Exception levels higher than EL0, this bit is <arm-defined-word>RES1</arm-defined-word>.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Little-endian. PSTATE.E is cleared to 0 on taking an exception or coming out of reset. Stage 1 translation table walks in the PL1&amp;0 translation regime are little-endian.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Big-endian. PSTATE.E is set to 1 on taking an exception or coming out of reset. Stage 1 translation table walks in the PL1&amp;0 translation regime are big-endian.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm" impdef="true">
        <field_reset_standard_text>ID</field_reset_standard_text>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-24_24" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>24</field_msb>
    <field_lsb>24</field_lsb>
    <rel_range>24</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-23_23-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES1">
    <field_name>SPAN</field_name>
    <field_msb>23</field_msb>
    <field_lsb>23</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Set Privileged Access Never, on taking an exception to EL1 from either Secure or Non-secure state, or to EL3 from Secure state when EL3 is using AArch32.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description><para>PSTATE.PAN is set to 1 in the following situations:</para>
<list type="unordered">
<listitem><content>In Non-secure state, on taking an exception to EL1.</content>
</listitem><listitem><content>In Secure state, when EL3 is using AArch64, on taking an exception to EL1.</content>
</listitem><listitem><content>In Secure state, when EL3 is using AArch32, on taking an exception to EL3.</content>
</listitem></list></field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>The value of PSTATE.PAN is left unchanged on taking an exception to EL1.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_PAN is implemented</fields_condition>
  </field>
  <field id="fieldset_0-23_23-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES1" reserved_type="RES1">
    <field_msb>23</field_msb>
    <field_lsb>23</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-22_22" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES1">
    <field_msb>22</field_msb>
    <field_lsb>22</field_lsb>
    <rel_range>22</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-21_21" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>21</field_msb>
    <field_lsb>21</field_lsb>
    <rel_range>21</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-20_20" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>UWXN</field_name>
    <field_msb>20</field_msb>
    <field_lsb>20</field_lsb>
    <rel_range>20</rel_range>
    <field_description order="before">
      <para>Unprivileged write permission implies PL1 XN (Execute-never). This bit can force all memory regions that are writable at PL0 to be treated as XN for accesses from software executing at PL1.</para>
    </field_description>
    <field_description order="after">
      <para>The UWXN bit is permitted to be cached in a TLB.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>This control has no effect on memory access permissions.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Any region that is writable at PL0 forced to XN for accesses from software executing at PL1.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-19_19" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>WXN</field_name>
    <field_msb>19</field_msb>
    <field_lsb>19</field_lsb>
    <rel_range>19</rel_range>
    <field_description order="before">
      <para>Write permission implies XN (Execute-never). For the PL1&amp;0 translation regime, this bit can force all memory regions that are writable to be treated as XN.</para>
    </field_description>
    <field_description order="after"><para>This bit applies only when SCTLR.M bit is set.</para>
<para>The WXN bit is permitted to be cached in a TLB.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>This control has no effect on memory access permissions.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>Any region that is writable in the PL1&amp;0 translation regime is forced to XN for accesses from software executing at PL1 or PL0.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-18_18" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>nTWE</field_name>
    <field_msb>18</field_msb>
    <field_lsb>18</field_lsb>
    <rel_range>18</rel_range>
    <field_description order="before">
      <para>Traps EL0 execution of WFE instructions to Undefined mode.</para>
    </field_description>
    <field_description order="after"><para>The attempted execution of a conditional WFE instruction is only trapped if the instruction passes its condition code check.</para>
<note><para>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</para></note></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Any attempt to execute a WFE instruction at EL0 is trapped to Undefined mode, if the instruction would otherwise have caused the PE to enter a low-power state.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>This control does not cause any instructions to be trapped.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>1</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-17_17" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>17</field_msb>
    <field_lsb>17</field_lsb>
    <rel_range>17</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-16_16" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>nTWI</field_name>
    <field_msb>16</field_msb>
    <field_lsb>16</field_lsb>
    <rel_range>16</rel_range>
    <field_description order="before">
      <para>Traps EL0 execution of WFI instructions to Undefined mode.</para>
    </field_description>
    <field_description order="after"><para>The attempted execution of a conditional WFI instruction is only trapped if the instruction passes its condition code check.</para>
<note><para>Since a WFE or WFI can complete at any time, even without a Wakeup event, the traps on WFE of WFI are not guaranteed to be taken, even if the WFE or WFI is executed when there is no Wakeup event. The only guarantee is that if the instruction does not complete in finite time in the absence of a Wakeup event, the trap will be taken.</para></note></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Any attempt to execute a WFI instruction at EL0 is trapped to Undefined mode, if the instruction would otherwise have caused the PE to enter a low-power state.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>This control does not cause any instructions to be trapped.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>1</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-15_14" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>15</field_msb>
    <field_lsb>14</field_lsb>
    <rel_range>15:14</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-13_13" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>V</field_name>
    <field_msb>13</field_msb>
    <field_lsb>13</field_lsb>
    <rel_range>13</rel_range>
    <field_description order="before">
      <para>Vectors bit. This bit selects the base address of the exception vectors for exceptions taken to a PE mode other than Monitor mode or Hyp mode:</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>Normal exception vectors. Base address is held in <register_link state="AArch32" id="AArch32-vbar.xml">VBAR</register_link>.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>High exception vectors (Hivecs), base address <hexnumber>0xFFFF0000</hexnumber>. This base address cannot be remapped.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm" impdef="true">
        <field_reset_standard_text>ID</field_reset_standard_text>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-12_12" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>I</field_name>
    <field_msb>12</field_msb>
    <field_lsb>12</field_lsb>
    <rel_range>12</rel_range>
    <field_description order="before">
      <para>Instruction access Cacheability control, for accesses at EL1 and EL0:</para>
    </field_description>
    <field_description order="after"><para>Instruction accesses to Normal memory from EL1 and EL0 are Cacheable regardless of the value of the SCTLR.I bit if either:</para>
<list type="unordered">
<listitem><content>EL2 is using AArch32 and the value of <register_link state="AArch32" id="AArch32-hcr.xml">HCR</register_link>.DC is 1.</content>
</listitem><listitem><content>EL2 is using AArch64 and the value of <register_link state="AArch64" id="AArch64-hcr_el2.xml">HCR_EL2</register_link>.DC is 1.</content>
</listitem></list></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description><para>All instruction access to Normal memory from PL1 and PL0 are Non-cacheable for all levels of instruction and unified cache.</para>
<para>If the value of SCTLR.M is 0, instruction accesses from stage 1 of the PL1&amp;0 translation regime are to Normal, Outer Shareable, Inner Non-cacheable, Outer Non-cacheable memory.</para></field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>All instruction access to Normal memory from PL1 and PL0 can be cached at all levels of instruction and unified cache.</para>
<para>If the value of SCTLR.M is 0, instruction accesses from stage 1 of the PL1&amp;0 translation regime are to Normal, Outer Shareable, Inner Write-Through, Outer Write-Through memory.</para></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-11_11" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES1">
    <field_msb>11</field_msb>
    <field_lsb>11</field_lsb>
    <rel_range>11</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-10_10-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES0">
    <field_name>EnRCTX</field_name>
    <field_msb>10</field_msb>
    <field_lsb>10</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before"><para>Enable EL0 access to the following System instructions:</para>
<list type="unordered">
<listitem><content><register_link state="AArch32" id="AArch32-cfprctx.xml">CFPRCTX</register_link>.</content>
</listitem><listitem><content><register_link state="AArch32" id="AArch32-dvprctx.xml">DVPRCTX</register_link>.</content>
</listitem><listitem><content><register_link state="AArch32" id="AArch32-cpprctx.xml">CPPRCTX</register_link>.</content>
</listitem><listitem><content>If FEAT_SPECRES2 is implemented, <register_link state="AArch32" id="AArch32-cosprctx.xml">COSPRCTX</register_link>.</content>
</listitem></list></field_description>
    <field_description order="after">
      <note>
        <para>When EL3 is implemented and is using AArch32, this bit is banked between the two Security states.</para>
      </note>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>EL0 access to these instructions is disabled, and these instructions are trapped to EL1.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>EL0 access to these instructions is enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_SPECRES is implemented</fields_condition>
  </field>
  <field id="fieldset_0-10_10-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0" reserved_type="RES0">
    <field_msb>10</field_msb>
    <field_lsb>10</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-9_9" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>9</field_msb>
    <field_lsb>9</field_lsb>
    <rel_range>9</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-8_8" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>SED</field_name>
    <field_msb>8</field_msb>
    <field_lsb>8</field_lsb>
    <rel_range>8</rel_range>
    <field_description order="before">
      <para>SETEND instruction disable. Disables SETEND instructions at PL0 and PL1.</para>
    </field_description>
    <field_description order="after">
      <para>If the implementation does not support mixed-endian operation at any Exception level, this bit is <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>SETEND instruction execution is enabled at PL0 and PL1.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>SETEND instructions are <arm-defined-word>UNDEFINED</arm-defined-word> at PL0 and PL1.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-7_7" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>ITD</field_name>
    <field_msb>7</field_msb>
    <field_lsb>7</field_lsb>
    <rel_range>7</rel_range>
    <field_description order="before">
      <para>IT Disable. Disables some uses of IT instructions at PL1 and PL0.</para>
    </field_description>
    <field_description order="after"><para>If an instruction in an active IT block that would be disabled by this field sets this field to 1 then behavior is <arm-defined-word>CONSTRAINED UNPREDICTABLE</arm-defined-word>. For more information see <xref browsertext="'Changes to an ITD control by an instruction in an IT block'" filename="E_the_aarch32_application_level_programmers__.fm" linkend="CJAHCDBA"/>.</para>
<para>ITD is optional, but if it is implemented in the SCTLR then it must also be implemented in the <register_link state="AArch64" id="AArch64-sctlr_el1.xml">SCTLR_EL1</register_link>, <register_link state="AArch64" id="AArch64-sctlr_el2.xml">SCTLR_EL2</register_link>, and <register_link state="AArch32" id="AArch32-hsctlr.xml">HSCTLR</register_link>.</para></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>All IT instruction functionality is enabled at PL1 and PL0.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>Any attempt at PL1 or PL0 to execute any of the following is <arm-defined-word>UNDEFINED</arm-defined-word>:</para>
<list type="unordered">
<listitem><content>All encodings of the IT instruction with hw1[3:0]!=1000.</content>
</listitem><listitem><content>All encodings of the subsequent instruction with the following values for hw1:<list type="unordered">
<listitem><content>11xxxxxxxxxxxxxx: All 32-bit instructions, and the 16-bit instructions B, UDF, SVC, LDM, and STM.</content>
</listitem><listitem><content>1011xxxxxxxxxxxx: All instructions in <xref browsertext="'Miscellaneous 16-bit instructions'" filename="F_t32_instruction_set_encoding.fm" linkend="T32.encoding_index.misc16"/>.</content>
</listitem><listitem><content>10100xxxxxxxxxxx: ADD Rd, PC, #imm</content>
</listitem><listitem><content>01001xxxxxxxxxxx: LDR Rd, [PC, #imm]</content>
</listitem><listitem><content>0100x1xxx1111xxx: ADD Rdn, PC; CMP Rn, PC; MOV Rd, PC; BX PC; BLX PC.</content>
</listitem><listitem><content>010001xx1xxxx111: ADD PC, Rm; CMP PC, Rm; MOV PC, Rm. This pattern also covers unpredictable cases with BLX Rn.</content>
</listitem></list>
</content>
</listitem></list>
<para>These instructions are always <arm-defined-word>UNDEFINED</arm-defined-word>, regardless of whether they would pass or fail the condition code check that applies to them as a result of being in an IT block.</para>
<para>It is <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> whether the IT instruction is treated as:</para>
<list type="unordered">
<listitem><content>A 16-bit instruction, that can only be followed by another 16-bit instruction.</content>
</listitem><listitem><content>The first half of a 32-bit instruction.</content>
</listitem></list>
<para>This means that, for the situations that are <arm-defined-word>UNDEFINED</arm-defined-word>, either the second 16-bit instruction or the 32-bit instruction is <arm-defined-word>UNDEFINED</arm-defined-word>.</para>
<para>An implementation might vary dynamically as to whether IT is treated as a 16-bit instruction or the first half of a 32-bit instruction.</para></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
    <field_access>
      <field_access_state>
        <field_access_level>When an implementation does not implement ITD</field_access_level>
        <field_access_type>RAZ/WI</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-6_6" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>UNK</field_name>
    <field_msb>6</field_msb>
    <field_lsb>6</field_lsb>
    <rel_range>6</rel_range>
    <field_description order="before">
      <para>Writes to this bit are IGNORED. Reads of this bit return an <arm-defined-word>UNKNOWN</arm-defined-word> value.</para>
    </field_description>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_standard_text>AU</field_reset_standard_text>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-5_5" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>CP15BEN</field_name>
    <field_msb>5</field_msb>
    <field_lsb>5</field_lsb>
    <rel_range>5</rel_range>
    <field_description order="before">
      <para>System instruction memory barrier enable. Enables accesses to the DMB, DSB, and ISB System instructions in the (coproc==<binarynumber>0b1111</binarynumber>) encoding space from PL1 and PL0:</para>
    </field_description>
    <field_description order="after">
      <para>CP15BEN is optional, but if it is implemented in the SCTLR then it must also be implemented in the <register_link state="AArch64" id="AArch64-sctlr_el1.xml">SCTLR_EL1</register_link>, <register_link state="AArch64" id="AArch64-sctlr_el2.xml">SCTLR_EL2</register_link>, and <register_link state="AArch32" id="AArch32-hsctlr.xml">HSCTLR</register_link>.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>PL0 and PL1 execution of the <register_link state="AArch32" id="AArch32-cp15dmb.xml">CP15DMB</register_link>, <register_link state="AArch32" id="AArch32-cp15dsb.xml">CP15DSB</register_link>, and <register_link state="AArch32" id="AArch32-cp15isb.xml">CP15ISB</register_link> instructions is <arm-defined-word>UNDEFINED</arm-defined-word>.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>PL0 and PL1 execution of the <register_link state="AArch32" id="AArch32-cp15dmb.xml">CP15DMB</register_link>, <register_link state="AArch32" id="AArch32-cp15dsb.xml">CP15DSB</register_link>, and <register_link state="AArch32" id="AArch32-cp15isb.xml">CP15ISB</register_link> instructions is enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>1</field_reset_number>
      </field_reset>
    </field_resets>
    <field_access>
      <field_access_state>
        <field_access_level>When an implementation does not implement CP15BEN</field_access_level>
        <field_access_type>RAO/WI</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-4_4-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES1">
    <field_name>LSMAOE</field_name>
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Load Multiple and Store Multiple Atomicity and Ordering Enable.</para>
    </field_description>
    <field_description order="after">
      <para>This bit is permitted to be cached in a TLB.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>For all memory accesses at EL1 or EL0, A32 and T32 Load Multiple and Store Multiple can have an interrupt taken during the sequence memory accesses, and the memory accesses are not required to be ordered.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>The ordering and interrupt behavior of A32 and T32 Load Multiple and Store Multiple at EL1 or EL0 is as defined for Armv8.0.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>1</field_reset_number>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_LSMAOC is implemented</fields_condition>
  </field>
  <field id="fieldset_0-4_4-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES1" reserved_type="RES1">
    <field_msb>4</field_msb>
    <field_lsb>4</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-3_3-1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" reserved_type="RES1">
    <field_name>nTLSMD</field_name>
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>No Trap Load Multiple and Store Multiple to Device-nGRE/Device-nGnRE/Device-nGnRnE memory.</para>
    </field_description>
    <field_description order="after">
      <para>This bit is permitted to be cached in a TLB.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>All memory accesses by A32 and T32 Load Multiple and Store Multiple at EL1 or EL0 that are marked at stage 1 as Device-nGRE/Device-nGnRE/Device-nGnRnE memory are trapped and generate a stage 1 Alignment fault.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>All memory accesses by A32 and T32 Load Multiple and Store Multiple at EL1 or EL0 that are marked at stage 1 as Device-nGRE/Device-nGnRE/Device-nGnRnE memory are not trapped.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>1</field_reset_number>
      </field_reset>
    </field_resets>
    <fields_condition>When FEAT_LSMAOC is implemented</fields_condition>
  </field>
  <field id="fieldset_0-3_3-2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES1" reserved_type="RES1">
    <field_msb>3</field_msb>
    <field_lsb>3</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES1</arm-defined-word>.</para>
    </field_description>
    <fields_condition>Otherwise</fields_condition>
  </field>
  <field id="fieldset_0-2_2" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>C</field_name>
    <field_msb>2</field_msb>
    <field_lsb>2</field_lsb>
    <rel_range>2</rel_range>
    <field_description order="before">
      <para>Cacheability control, for data accesses at EL1 and EL0:</para>
    </field_description>
    <field_description order="after"><para>The PE ignores SCTLR.C, and data accesses to Normal memory from EL1 and EL0 are Cacheable, if either:</para>
<list type="unordered">
<listitem><content>EL2 is using AArch32 and the value of <register_link state="AArch32" id="AArch32-hcr.xml">HCR</register_link>.DC is 1.</content>
</listitem><listitem><content>EL2 is using AArch64 and the value of <register_link state="AArch64" id="AArch64-hcr_el2.xml">HCR_EL2</register_link>.DC is 1.</content>
</listitem></list></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para>All data access to Normal memory from PL1 and PL0, and all accesses to the PL1&amp;0 stage 1 translation tables, are Non-cacheable for all levels of data and unified cache.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>All data access to Normal memory from PL1 and PL0, and all accesses to the PL1&amp;0 stage 1 translation tables, can be cached at all levels of data and unified cache.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-1_1" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>A</field_name>
    <field_msb>1</field_msb>
    <field_lsb>1</field_lsb>
    <rel_range>1</rel_range>
    <field_description order="before">
      <para>Alignment check enable. This is the enable bit for Alignment fault checking at PL1 and PL0:</para>
    </field_description>
    <field_description order="after">
      <para>Load/store exclusive and load-acquire/store-release instructions have an alignment check regardless of the value of the A bit.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description><para>Alignment fault checking disabled when executing at PL1 or PL0.</para>
<para>Instructions that load or store one or more registers, other than load/store exclusive and load-acquire/store-release, do not check that the address being accessed is aligned to the size of the data element(s) being accessed.</para></field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description><para>Alignment fault checking enabled when executing at PL1 or PL0.</para>
<para>All instructions that load or store one or more registers have an alignment check that the address being accessed is aligned to the size of the data element(s) being accessed. If this check fails it causes an Alignment fault, which is taken as a Data Abort exception.</para></field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <field id="fieldset_0-0_0" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False">
    <field_name>M</field_name>
    <field_msb>0</field_msb>
    <field_lsb>0</field_lsb>
    <rel_range>0</rel_range>
    <field_description order="before">
      <para>MMU enable for EL1 and EL0 stage 1 address translation. Possible values of this bit are:</para>
    </field_description>
    <field_description order="after"><para>The PE behaves as if the value of the SCTLR.M field is 0 for all purposes other than returning the value of a direct read of the field if either:</para>
<list type="unordered">
<listitem><content>EL2 is using AArch32 and the value of <register_link state="AArch32" id="AArch32-hcr.xml">HCR</register_link>.{DC, TGE} is not {0, 0}.</content>
</listitem><listitem><content>EL2 is using AArch64 and the value of <register_link state="AArch64" id="AArch64-hcr_el2.xml">HCR_EL2</register_link>.{DC, TGE} is not {0, 0}.</content>
</listitem></list></field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description><para>EL1 and EL0 stage 1 address translation disabled.</para>
<para>See the SCTLR.I field for the behavior of instruction accesses to Normal memory.</para></field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para>EL1 and EL0 stage 1 address translation enabled.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_resets>
      <field_reset reset_type="Warm">
        <field_reset_number>0</field_reset_number>
      </field_reset>
    </field_resets>
  </field>
  <text_after_fields/>
</fields>




    
<reg_fieldset length="32">
  <fieldat id="fieldset_0-31_31-1" msb="31" lsb="31"/>
  <fieldat id="fieldset_0-30_30" msb="30" lsb="30"/>
  <fieldat id="fieldset_0-29_29" msb="29" lsb="29"/>
  <fieldat id="fieldset_0-28_28" msb="28" lsb="28"/>
  <fieldat id="fieldset_0-27_26" msb="27" lsb="26"/>
  <fieldat id="fieldset_0-25_25" msb="25" lsb="25"/>
  <fieldat id="fieldset_0-24_24" msb="24" lsb="24"/>
  <fieldat id="fieldset_0-23_23-1" msb="23" lsb="23"/>
  <fieldat id="fieldset_0-22_22" msb="22" lsb="22"/>
  <fieldat id="fieldset_0-21_21" msb="21" lsb="21"/>
  <fieldat id="fieldset_0-20_20" msb="20" lsb="20"/>
  <fieldat id="fieldset_0-19_19" msb="19" lsb="19"/>
  <fieldat id="fieldset_0-18_18" msb="18" lsb="18"/>
  <fieldat id="fieldset_0-17_17" msb="17" lsb="17"/>
  <fieldat id="fieldset_0-16_16" msb="16" lsb="16"/>
  <fieldat id="fieldset_0-15_14" msb="15" lsb="14"/>
  <fieldat id="fieldset_0-13_13" msb="13" lsb="13"/>
  <fieldat id="fieldset_0-12_12" msb="12" lsb="12"/>
  <fieldat id="fieldset_0-11_11" msb="11" lsb="11"/>
  <fieldat id="fieldset_0-10_10-1" msb="10" lsb="10"/>
  <fieldat id="fieldset_0-9_9" msb="9" lsb="9"/>
  <fieldat id="fieldset_0-8_8" msb="8" lsb="8"/>
  <fieldat id="fieldset_0-7_7" msb="7" lsb="7"/>
  <fieldat id="fieldset_0-6_6" msb="6" lsb="6"/>
  <fieldat id="fieldset_0-5_5" msb="5" lsb="5"/>
  <fieldat id="fieldset_0-4_4-1" msb="4" lsb="4"/>
  <fieldat id="fieldset_0-3_3-1" msb="3" lsb="3"/>
  <fieldat id="fieldset_0-2_2" msb="2" lsb="2"/>
  <fieldat id="fieldset_0-1_1" msb="1" lsb="1"/>
  <fieldat id="fieldset_0-0_0" msb="0" lsb="0"/>
</reg_fieldset>


      </reg_fieldsets>

      <access_mechanisms>
          






        
        <access_mechanism accessor="MRC SCTLR" type="SystemAccessor">
            <encoding>
            <access_instruction>MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</access_instruction>
                
                <enc n="coproc" v="0b1111"/>
                
                <enc n="opc1" v="0b000"/>
                
                <enc n="CRn" v="0b0001"/>
                
                <enc n="CRm" v="0b0000"/>
                
                <enc n="opc2" v="0b000"/>
            </encoding>
            <access_permission>
                <ps name="MRC" sections="1" secttype="access_permission">
                <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TRVM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        R[t] = SCTLR_NS;
    else
        R[t] = SCTLR;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        R[t] = SCTLR_NS;
    else
        R[t] = SCTLR;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        R[t] = SCTLR_S;
    else
        R[t] = SCTLR_NS;
                </pstext>
                </ps>
            </access_permission>
        </access_mechanism>
        
        <access_mechanism accessor="MCR SCTLR" type="SystemAccessor">
            <encoding>
            <access_instruction>MCR{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</access_instruction>
                
                <enc n="coproc" v="0b1111"/>
                
                <enc n="opc1" v="0b000"/>
                
                <enc n="CRn" v="0b0001"/>
                
                <enc n="CRm" v="0b0000"/>
                
                <enc n="opc2" v="0b000"/>
            </encoding>
            <access_permission>
                <ps name="MCR" sections="1" secttype="access_permission">
                <pstext>
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T1 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T1 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TVM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        SCTLR_NS = R[t];
    else
        SCTLR = R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        SCTLR_NS = R[t];
    else
        SCTLR = R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' &amp;&amp; CP15SDISABLE == Signal_High then
        UNDEFINED;
    elsif SCR.NS == '0' &amp;&amp; CP15SDISABLE2 == Signal_High then
        UNDEFINED;
    else
        if SCR.NS == '0' then
            SCTLR_S = R[t];
        else
            SCTLR_NS = R[t];
                </pstext>
                </ps>
            </access_permission>
        </access_mechanism>

      </access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>30/03/2023 19:07; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</timestamp>
</register_page>