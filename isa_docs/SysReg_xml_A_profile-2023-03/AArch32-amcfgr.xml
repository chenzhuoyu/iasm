<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE register_page SYSTEM "registers.dtd">
<!-- Copyright (c) 2010-2023 Arm Limited or its affiliates. All rights reserved. -->
<!-- This document is Non-Confidential. This document may only be used and distributed in accordance with the terms of the agreement entered into by Arm and the party that Arm delivered this document to. -->
<!--The data contained in this document is preliminary and subject to change or correction following further review. -->
<?xml-stylesheet href="one_register.xsl" type="text/xsl" ?>







<register_page>
  <registers>
  
    <register execution_state="AArch32" is_register="True" is_internal="True" is_banked="False" is_stub_entry="False">
      <reg_short_name>AMCFGR</reg_short_name>
        
        <reg_long_name>Activity Monitors Configuration Register</reg_long_name>



      
        <reg_condition otherwise="UNDEFINED">when FEAT_AMUv1 is implemented</reg_condition>
      



          <reg_reset_value></reg_reset_value>

      <reg_mappings>
        



      
      <reg_mapping>
        
  

    

    <mapped_name filename="AArch64-amcfgr_el0.xml">AMCFGR_EL0</mapped_name>
  <mapped_type>Architectural</mapped_type>
      <mapped_execution_state>AArch64</mapped_execution_state>
    <mapped_from_startbit>31</mapped_from_startbit>
    <mapped_from_endbit>0</mapped_from_endbit>
    <mapped_to_startbit>31</mapped_to_startbit>
    <mapped_to_endbit>0</mapped_to_endbit>
    <mapped_from_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_to_rangeset>

      </reg_mapping>
      
      <reg_mapping>
        
  

    

    <mapped_name filename="ext-amcfgr.xml">AMCFGR</mapped_name>
  <mapped_type>Architectural</mapped_type>
      <mapped_execution_state>External</mapped_execution_state>
    <mapped_from_startbit>31</mapped_from_startbit>
    <mapped_from_endbit>0</mapped_from_endbit>
    <mapped_to_startbit>31</mapped_to_startbit>
    <mapped_to_endbit>0</mapped_to_endbit>
    <mapped_from_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_from_rangeset>
    <mapped_to_rangeset output="31:0">
      <range>
        <msb>31</msb>
        <lsb>0</lsb>
      </range>
    </mapped_to_rangeset>

      </reg_mapping>

      </reg_mappings>

        <reg_purpose>
          
    
      <purpose_text>
        <para>Global configuration register for the activity monitors.</para>

      </purpose_text>
      <purpose_text>
        <para>Provides information on supported features, the number of counter groups implemented, the total number of activity monitor event counters implemented, and the size of the counters. AMCFGR is applicable to both the architected and the auxiliary counter groups.</para>
      </purpose_text>

        </reg_purpose>

      <reg_groups>
          <reg_group>Activity Monitors registers</reg_group>
      </reg_groups>
      
      
        
      <reg_attributes>
          
    
      <attributes_text>
        <para>AMCFGR is a 32-bit register.</para>
      </attributes_text>

      </reg_attributes>
      <reg_fieldsets>
        






<fields id="fieldset_0" length="32">
  <text_before_fields/>
  <field id="fieldset_0-31_28" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="True" is_partial_field="False" is_conditional_field_name="False">
    <field_name>NCG</field_name>
    <field_msb>31</field_msb>
    <field_lsb>28</field_lsb>
    <rel_range>31:28</rel_range>
    <field_description order="before"><para>Defines the number of counter groups.</para>
<para>The number of implemented counter groups is [AMCFGR.NCG + 1].</para>
<para>If the number of implemented auxiliary activity monitor event counters is zero, this field has a value of <binarynumber>0b0000</binarynumber>. Otherwise, this field has a value of <binarynumber>0b0001</binarynumber>.</para></field_description>
    <field_description order="after">
      <para>This field has an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> value.</para>
    </field_description>
    <field_access>
      <field_access_state>
        <field_access_type>RO</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-27_25" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RES0">
    <field_msb>27</field_msb>
    <field_lsb>25</field_lsb>
    <rel_range>27:25</rel_range>
    <field_description order="before">
      <para>Reserved, <arm-defined-word>RES0</arm-defined-word>.</para>
    </field_description>
  </field>
  <field id="fieldset_0-24_24" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="True" is_partial_field="False" is_conditional_field_name="False">
    <field_name>HDBG</field_name>
    <field_msb>24</field_msb>
    <field_lsb>24</field_lsb>
    <rel_range>24</rel_range>
    <field_description order="before"><para>Halt-on-debug supported.</para>
<para>This feature must be supported, and so this bit is <binarynumber>0b1</binarynumber>.</para></field_description>
    <field_description order="after">
      <para>This field has an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> value.</para>
    </field_description>
    <field_values>
      <field_value_instance>
        <field_value>0b0</field_value>
        <field_value_description>
          <para><register_link state="AArch32" id="AArch32-amcr.xml">AMCR</register_link>.HDBG is <arm-defined-word>RES0</arm-defined-word>.</para>
        </field_value_description>
      </field_value_instance>
      <field_value_instance>
        <field_value>0b1</field_value>
        <field_value_description>
          <para><register_link state="AArch32" id="AArch32-amcr.xml">AMCR</register_link>.HDBG is read/write.</para>
        </field_value_description>
      </field_value_instance>
    </field_values>
    <field_access>
      <field_access_state>
        <field_access_type>RO</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-23_14" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="False" is_partial_field="False" is_conditional_field_name="False" rwtype="RAZ">
    <field_msb>23</field_msb>
    <field_lsb>14</field_lsb>
    <rel_range>23:14</rel_range>
    <field_description order="before">
      <para>Reserved, RAZ.</para>
    </field_description>
  </field>
  <field id="fieldset_0-13_8" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="True" is_partial_field="False" is_conditional_field_name="False">
    <field_name>SIZE</field_name>
    <field_msb>13</field_msb>
    <field_lsb>8</field_lsb>
    <rel_range>13:8</rel_range>
    <field_description order="before"><para>Defines the size of activity monitor event counters.</para>
<para>The size of the activity monitor event counters implemented by the Activity Monitors Extension is [AMCFGR.SIZE + 1].</para>
<para>The counters are 64-bit.</para>
<note><para>Software also uses this field to determine the spacing of counters in the memory-map. The counters are at doubleword-aligned addresses.</para></note></field_description>
    <field_description order="after">
      <para>Reads as <binarynumber>0b111111</binarynumber>.</para>
    </field_description>
    <field_access>
      <field_access_state>
        <field_access_type>RO</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <field id="fieldset_0-7_0" has_partial_fieldset="False" is_linked_to_partial_fieldset="False" is_access_restriction_possible="False" is_variable_length="False" is_constant_value="True" is_partial_field="False" is_conditional_field_name="False">
    <field_name>N</field_name>
    <field_msb>7</field_msb>
    <field_lsb>0</field_lsb>
    <rel_range>7:0</rel_range>
    <field_description order="before"><para>Defines the number of activity monitor event counters.</para>
<para>The total number of counters implemented in all groups by the Activity Monitors Extension is [AMCFGR.N + 1].</para></field_description>
    <field_description order="after">
      <para>This field has an <arm-defined-word>IMPLEMENTATION DEFINED</arm-defined-word> value.</para>
    </field_description>
    <field_access>
      <field_access_state>
        <field_access_type>RO</field_access_type>
      </field_access_state>
    </field_access>
  </field>
  <text_after_fields/>
</fields>




    
<reg_fieldset length="32">
  <fieldat id="fieldset_0-31_28" msb="31" lsb="28"/>
  <fieldat id="fieldset_0-27_25" msb="27" lsb="25"/>
  <fieldat id="fieldset_0-24_24" msb="24" lsb="24"/>
  <fieldat id="fieldset_0-23_14" msb="23" lsb="14"/>
  <fieldat id="fieldset_0-13_8" msb="13" lsb="8"/>
  <fieldat id="fieldset_0-7_0" msb="7" lsb="0"/>
</reg_fieldset>


      </reg_fieldsets>

      <access_mechanisms>
          






        
        <access_mechanism accessor="MRC AMCFGR" type="SystemAccessor">
            <encoding>
            <access_instruction>MRC{&lt;c&gt;}{&lt;q&gt;} &lt;coproc&gt;, {#}&lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;{, {#}&lt;opc2&gt;}</access_instruction>
                
                <enc n="coproc" v="0b1111"/>
                
                <enc n="opc1" v="0b000"/>
                
                <enc n="CRn" v="0b1101"/>
                
                <enc n="CRm" v="0b0010"/>
                
                <enc n="opc2" v="0b001"/>
            </encoding>
            <access_permission>
                <ps name="MRC" sections="1" secttype="access_permission">
                <pstext>
if PSTATE.EL == EL0 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        UNDEFINED;
    elsif !ELUsingAArch32(EL1) &amp;&amp; AMUSERENR_EL0.EN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        else
            AArch64.AArch32SystemAccessTrap(EL1, 0x03);
    elsif ELUsingAArch32(EL1) &amp;&amp; AMUSERENR.EN == '0' then
        if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.AArch32SystemAccessTrap(EL2, 0x03);
        elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TGE == '1' then
            AArch32.TakeHypTrapException(0x00);
        else
            UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.&lt;E2H,TGE&gt; != '11' &amp;&amp; HSTR_EL2.T13 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T13 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        R[t] = AMCFGR;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T13 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T13 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; CPTR_EL2.TAM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCPTR.TAM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        R[t] = AMCFGR;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; !ELUsingAArch32(EL3) &amp;&amp; CPTR_EL3.TAM == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.AArch32SystemAccessTrap(EL3, 0x03);
    else
        R[t] = AMCFGR;
elsif PSTATE.EL == EL3 then
    R[t] = AMCFGR;
                </pstext>
                </ps>
            </access_permission>
        </access_mechanism>

      </access_mechanisms>

      <arch_variants>
      </arch_variants>
  </register>
</registers>

    <timestamp>30/03/2023 19:07; 997dd0cf3258cacf72aa7cf7a885f19a4758c3af</timestamp>
</register_page>