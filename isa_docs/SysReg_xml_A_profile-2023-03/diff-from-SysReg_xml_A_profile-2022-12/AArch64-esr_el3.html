<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ESR_EL3</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">ESR_EL3, Exception Syndrome Register (EL3)</h1><p>The ESR_EL3 characteristics are:</p><h2>Purpose</h2><p>Holds syndrome information for an exception taken to EL3.</p><h2>Configuration</h2><p>This register is present only when EL3 is implemented. Otherwise, direct accesses to ESR_EL3 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2><p>ESR_EL3 is a 64-bit register.</p><h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_0-63_56">RES0</a></td><td class="lr" colspan="24"><a href="#fieldset_0-55_32">ISS2</a></td></tr><tr class="firstrow"><td class="lr" colspan="6"><a href="#fieldset_0-31_26">EC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-25_25">IL</a></td><td class="lr" colspan="25"><a href="#fieldset_0-24_0">ISS</a></td></tr></tbody></table><div class="text_before_fields"><p>ESR_EL3 is made <span class="arm-defined-word">UNKNOWN</span> as a result of an exception return from EL3.</p><p>When an <span class="arm-defined-word">UNPREDICTABLE</span> instruction is treated as <span class="arm-defined-word">UNDEFINED</span>, and the exception is taken to EL3, the value of ESR_EL3 is <span class="arm-defined-word">UNKNOWN</span>. The value written to ESR_EL3 must be consistent with a value that could be created as a result of an exception from the same Exception level that generated the exception as a result of a situation that is not <span class="arm-defined-word">UNPREDICTABLE</span> at that Exception level, in order to avoid the possibility of a privilege violation.</p></div><h4 id="fieldset_0-63_56">Bits [63:56]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32">ISS2, bits [55:32]</h4><div class="field"><p>ISS2 encoding for an exception, the bit assignments are:</p><div class="partial_fieldset"><h3 id="fieldset_0-55_32_0">ISS2 encoding for an exception from a Data Abort (EC == 0b100100 or EC == 0b100101)</h3><table class="regdiagram"><thead><tr><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="13"><a href="#fieldset_0-55_32_0-23_11">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_0-10_10-1">TnD</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_0-9_9-1">TagAccess</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_0-8_8-1">GCS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_0-7_7">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_0-6_6-1">Overlay</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_0-5_5-1">DirtyBit</a></td><td class="lr" colspan="5"><a href="#fieldset_0-55_32_0-4_0-1">Xs</a></td></tr></tbody></table><h4 id="fieldset_0-55_32_0-23_11">Bits [23:11]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_0-10_10-1">TnD, bit [10]<span class="condition"><br/>When FEAT_MTE_CANONICAL_TAGS is implemented:
                        </span></h4><div class="field"><p>Tag not Data.</p><p>If a memory access generates a Data Abort for a stage 1 Permission fault, this field indicates whether the fault is due to an Allocation Tag access.</p><table class="valuetable"><tr><th>TnD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Permission fault is not due to an Allocation Tag access</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Permission fault is due to an Allocation Tag access.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_32_0-10_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_0-9_9-1">TagAccess, bit [9]<span class="condition"><br/>When FEAT_MTE_PERM is implemented:
                        </span></h4><div class="field"><p>NoTagAccess fault.</p><p>If a memory access generates a Data Abort for a Permission fault, this field indicates whether the fault is due to the NoTagAccess memory attribute.</p><table class="valuetable"><tr><th>TagAccess</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Permission fault is not due to the NoTagAccess memory attribute.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Permission fault is due to the NoTagAccess memory attribute.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_32_0-9_9-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_0-8_8-1">GCS, bit [8]<span class="condition"><br/>When FEAT_GCS is implemented:
                        </span></h4><div class="field"><p>Guarded control stack data access.</p><p>If a memory access generates a Data Abort, this field indicates whether the fault is due to a Guarded control stack data access.</p><table class="valuetable"><tr><th>GCS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort is not due to a Guarded control stack data access.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort is due to a Guarded control stack data access.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_32_0-8_8-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_0-7_7">Bit [7]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_0-6_6-1">Overlay, bit [6]<span class="condition"><br/>When FEAT_S1POE is implemented:
                        </span></h4><div class="field"><p>Overlay flag.</p><p>If a memory access generates a Data Abort for a Permission fault, then this field holds information about the fault.</p><table class="valuetable"><tr><th>Overlay</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Data Abort is not due to Overlay Permissions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Data Abort due to Overlay Permissions.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_32_0-6_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_0-5_5-1">DirtyBit, bit [5]<span class="condition"><br/>When FEAT_S1PIE is implemented:
                        </span></h4><div class="field"><p>DirtyBit flag.</p><p>If a write access to memory generates a Data Abort for a Permission fault using Indirect Permission, then this field holds information about the fault.</p><table class="valuetable"><tr><th>DirtyBit</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Permission Fault is not due to dirty state.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Permission Fault is due to dirty state.</p></td></tr></table><p>For any other fault or Access, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_32_0-5_5-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_0-4_0-1">Xs, bits [4:0]<span class="condition"><br/>When FEAT_LS64 is implemented:
                        </span></h4><div class="field"><p>When <span class="xref">FEAT_LS64_V</span> is implemented, if a memory access generated by an ST64BV instruction generates a Data Abort exception for a Translation fault, Access flag fault, or Permission fault, then this field holds register specifier, Xs.</p><p>When <span class="xref">FEAT_LS64_ACCDATA</span> is implemented, if a memory access generated by an ST64BV0 instruction generates a Data Abort exception for a Translation fault, Access flag fault, or Permission fault, then this field holds register specifier, Xs.</p><p>Otherwise, this field is <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_0-4_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-55_32_1">ISS2 encoding for an exception from an Instruction Abort (EC == 0b100000 or EC == 0b100001)</h3><table class="regdiagram"><thead><tr><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="17"><a href="#fieldset_0-55_32_1-23_7">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_1-6_6-1">Overlay</a></td><td class="lr" colspan="6"><a href="#fieldset_0-55_32_1-5_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-55_32_1-23_7">Bits [23:7]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_1-6_6-1">Overlay, bit [6]<span class="condition"><br/>When FEAT_S1POE is implemented<del> or FEAT_S2POE is implemented</del>:
                        </span></h4><div class="field"><p>Overlay flag.</p><p>If a memory access generates a Instruction Abort for a Permission fault, then this field holds information about the fault.</p><table class="valuetable"><tr><th>Overlay</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Instruction Abort is not due to Overlay Permissions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Instruction Abort due to Overlay Permissions.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_32_1-6_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_1-5_0">Bits [5:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-55_32_2">ISS2 encoding for an exception from a Watchpoint exception (EC == 0b110100 or EC == 0b110101)</h3><table class="regdiagram"><thead><tr><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="15"><a href="#fieldset_0-55_32_2-23_9">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_2-8_8-1">GCS</a></td><td class="lr" colspan="8"><a href="#fieldset_0-55_32_2-7_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-55_32_2-23_9">Bits [23:9]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_2-8_8-1">GCS, bit [8]<span class="condition"><br/>When FEAT_GCS is implemented:
                        </span></h4><div class="field"><p>Guarded control stack data access.</p><p>Indicates that the Watchpoint exception is due to a Guarded control stack data access.</p><table class="valuetable"><tr><th>GCS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Watchpoint exception is not due to a Guarded control stack data access.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Watchpoint exception is due to a Guarded control stack data access.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_32_2-8_8-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_2-7_0">Bits [7:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-55_32_3">ISS2 encoding for a Granule Protection Check exception (EC == 0b011110)</h3><table class="regdiagram"><thead><tr><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="15"><a href="#fieldset_0-55_32_3-23_9">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_32_3-8_8-1">GCS</a></td><td class="lr" colspan="8"><a href="#fieldset_0-55_32_3-7_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-55_32_3-23_9">Bits [23:9]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_3-8_8-1">GCS, bit [8]<span class="condition"><br/>When FEAT_GCS is implemented:
                        </span></h4><div class="field"><p>Guarded control stack data access.</p><p>Indicates that the Granule Protection Check Exception is generated by a Guarded control stack data access.</p><table class="valuetable"><tr><th>GCS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Granule Protection Check Exception was not generated by a Guarded control stack data access.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Granule Protection Check Exception was generated by a Guarded control stack data access.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_32_3-8_8-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_32_3-7_0">Bits [7:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div></div></div><h4 id="fieldset_0-31_26">EC, bits [31:26]</h4><div class="field"><p>Exception Class. Indicates the reason for the exception that this register holds information about.</p><p>For each EC value, the table references a subsection that gives information about:</p><ul><li>The cause of the exception, for example the configuration required to enable the trap.
</li><li>The encoding of the associated ISS.
</li></ul><p>Possible values of the EC field are:</p><table class="valuetable"><tr><th>EC</th><th>Meaning</th><th>ISS</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td><p>Unknown reason.</p></td><td><a href="#fieldset_0-24_0_0">ISS encoding for exceptions with an unknown reason</a></td></tr><tr><td class="bitfield">0b000001</td><td><p>Trapped WF* instruction execution.</p><p>Conditional WF* instructions that fail their condition code check do not cause an exception.</p></td><td><a href="#fieldset_0-24_0_1">ISS encoding for an exception from a WF* instruction</a></td></tr><tr><td class="bitfield">0b000011</td><td><p>Trapped MCR or MRC access with (coproc==<span class="binarynumber">0b1111</span>) that is not reported using EC <span class="binarynumber">0b000000</span>.</p></td><td><a href="#fieldset_0-24_0_2">ISS encoding for an exception from an MCR or MRC access</a></td><td>When AArch32 is supported</td></tr><tr><td class="bitfield">0b000100</td><td><p>Trapped MCRR or MRRC access with (coproc==<span class="binarynumber">0b1111</span>) that is not reported using EC <span class="binarynumber">0b000000</span>.</p></td><td><a href="#fieldset_0-24_0_4">ISS encoding for an exception from an MCRR or MRRC access</a></td><td>When AArch32 is supported</td></tr><tr><td class="bitfield">0b000101</td><td><p>Trapped MCR or MRC access with (coproc==<span class="binarynumber">0b1110</span>).</p></td><td><a href="#fieldset_0-24_0_2">ISS encoding for an exception from an MCR or MRC access</a></td><td>When AArch32 is supported</td></tr><tr><td class="bitfield">0b000110</td><td><p>Trapped LDC or STC access.</p><p>The only architected uses of these instruction are:</p><ul><li>An STC to write data to memory from <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a>.
</li><li>An LDC to read data from memory to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a>.
</li></ul></td><td><a href="#fieldset_0-24_0_5">ISS encoding for an exception from an LDC or STC instruction</a></td><td>When AArch32 is supported</td></tr><tr><td class="bitfield">0b000111</td><td><p>Access to SME, SVE, Advanced SIMD or floating-point functionality trapped by <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.FPEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.FPEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TFP, or <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TFP control.</p><p>Excludes exceptions resulting from <a href="AArch64-cpacr_el1.html">CPACR_EL1</a> when the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1, or because SVE or Advanced SIMD and floating-point are not implemented. These are reported with EC value <span class="binarynumber">0b000000</span>.</p></td><td><a href="#fieldset_0-24_0_6">ISS encoding for an exception from an access to SVE, Advanced SIMD or floating-point functionality, resulting from the FPEN and TFP traps</a></td></tr><tr><td class="bitfield">0b001001</td><td><p>Trapped use of a Pointer authentication instruction because <a href="AArch64-hcr_el2.html">HCR_EL2</a>.API == 0 || <a href="AArch64-scr_el3.html">SCR_EL3</a>.API == 0.</p></td><td><a href="#fieldset_0-24_0_27">ISS encoding for an exception from a Pointer Authentication instruction when HCR_EL2.API == 0 || SCR_EL3.API == 0</a></td><td>When FEAT_PAuth is implemented</td></tr><tr><td class="bitfield">0b001010</td><td><p>An exception from an LD64B or ST64B* instruction.</p></td><td><a href="#fieldset_0-24_0_3">ISS encoding for an exception from an LD64B or ST64B* instruction</a></td><td>When FEAT_LS64 is implemented</td></tr><tr><td class="bitfield">0b001100</td><td><p>Trapped MRRC access with (coproc==<span class="binarynumber">0b1110</span>).</p></td><td><a href="#fieldset_0-24_0_4">ISS encoding for an exception from an MCRR or MRRC access</a></td><td>When AArch32 is supported</td></tr><tr><td class="bitfield">0b001101</td><td><p>Branch Target Exception.</p></td><td><a href="#fieldset_0-24_0_26">ISS encoding for an exception from Branch Target Identification instruction</a></td><td>When FEAT_BTI is implemented</td></tr><tr><td class="bitfield">0b001110</td><td><p>Illegal Execution state.</p></td><td><a href="#fieldset_0-24_0_9">ISS encoding for an exception from an Illegal Execution state, or a PC or SP alignment fault</a></td></tr><tr><td class="bitfield">0b010011</td><td><p>SMC instruction execution in AArch32 state, when SMC is not disabled.</p></td><td><a href="#fieldset_0-24_0_12">ISS encoding for an exception from SMC instruction execution in AArch32 state</a></td><td>When AArch32 is supported</td></tr><tr><td class="bitfield"><ins>0b010100</ins></td><td><p><ins>Trapped MSRR, MRRS or System instruction execution in AArch64 state, that is not reported using EC </ins><span class="binarynumber"><ins>0b000000</ins></span><ins>.</ins></p></td><td><a href="#fieldset_0-24_0_15"><ins>ISS encoding for an exception from MSRR, MRRS, or 128-bit System instruction execution in AArch64 state</ins></a></td><td><ins>When FEAT_SYSREG128 is implemented or FEAT_SYSINSTR128 is implemented</ins></td></tr><tr><td class="bitfield">0b010101</td><td><p>SVC instruction execution in AArch64 state.</p></td><td><a href="#fieldset_0-24_0_11">ISS encoding for an exception from HVC or SVC instruction execution</a></td><td>When AArch64 is supported</td></tr><tr><td class="bitfield">0b010110</td><td><p>HVC instruction execution in AArch64 state, when HVC is not disabled.</p></td><td><a href="#fieldset_0-24_0_11">ISS encoding for an exception from HVC or SVC instruction execution</a></td><td>When AArch64 is supported</td></tr><tr><td class="bitfield">0b010111</td><td><p>SMC instruction execution in AArch64 state, when SMC is not disabled.</p></td><td><a href="#fieldset_0-24_0_13">ISS encoding for an exception from SMC instruction execution in AArch64 state</a></td><td>When AArch64 is supported</td></tr><tr><td class="bitfield">0b011000</td><td><p>Trapped MSR, MRS or System instruction execution in AArch64 state, that is not reported using EC <span class="binarynumber">0b000000</span>, <span class="binarynumber">0b000001</span> or <span class="binarynumber">0b000111</span>.</p><p>This includes all instructions that cause exceptions that are part of the encoding space defined in <span class="xref">'System instruction class encoding overview'</span>, except for those exceptions reported using EC values <span class="binarynumber">0b000000</span>, <span class="binarynumber">0b000001</span>, or <span class="binarynumber">0b000111</span>.</p></td><td><a href="#fieldset_0-24_0_14">ISS encoding for an exception from MSR, MRS, or System instruction execution in AArch64 state</a></td><td>When AArch64 is supported</td></tr><tr><td class="bitfield">0b011001</td><td><p>Access to SVE functionality trapped as a result of <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.ZEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.ZEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TZ, or <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.EZ, that is not reported using EC <span class="binarynumber">0b000000</span>.</p></td><td><a href="#fieldset_0-24_0_7">ISS encoding for an exception from an access to SVE functionality, resulting from CPACR_EL1.ZEN, CPTR_EL2.ZEN, CPTR_EL2.TZ, or CPTR_EL3.EZ</a></td><td>When FEAT_SVE is implemented</td></tr><tr><td class="bitfield">0b011011</td><td><p>Exception from an access to a TSTART instruction at EL0 when <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.TME0 == 0, EL0 when <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.TME0 == 0, at EL1 when <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.TME == 0, at EL2 when <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.TME == 0 or at EL3 when <a href="AArch64-sctlr_el3.html">SCTLR_EL3</a>.TME == 0.</p></td><td><a href="#fieldset_0-24_0_25">ISS encoding for an exception from a TSTART instruction</a></td><td>When FEAT_TME is implemented</td></tr><tr><td class="bitfield">0b011100</td><td><p>Exception from a Pointer Authentication instruction authentication failure</p></td><td><a href="#fieldset_0-24_0_28">ISS encoding for an exception from a Pointer Authentication instruction authentication failure</a></td><td>When FEAT_FPAC is implemented</td></tr><tr><td class="bitfield">0b011101</td><td><p>Access to SME functionality trapped as a result of <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.SMEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.SMEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TSM, <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.ESM, or an attempted execution of an instruction that is illegal because of the value of PSTATE.SM or PSTATE.ZA, that is not reported using EC <span class="binarynumber">0b000000</span>.</p></td><td><a href="#fieldset_0-24_0_18">ISS encoding for an exception due to SME functionality</a></td><td>When FEAT_SME is implemented</td></tr><tr><td class="bitfield">0b011110</td><td><p>Granule Protection Check exception</p></td><td><a href="#fieldset_0-24_0_19">ISS encoding for a Granule Protection Check exception</a></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b011111</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> exception to EL3.</p></td><td><a href="#fieldset_0-24_0_16">ISS encoding for an IMPLEMENTATION DEFINED exception to EL3</a></td></tr><tr><td class="bitfield">0b100000</td><td><p>Instruction Abort from a lower Exception level.</p><p>Used for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions.</p></td><td><a href="#fieldset_0-24_0_17">ISS encoding for an exception from an Instruction Abort</a></td></tr><tr><td class="bitfield">0b100001</td><td><p>Instruction Abort taken without a change in Exception level.</p><p>Used for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions.</p></td><td><a href="#fieldset_0-24_0_17">ISS encoding for an exception from an Instruction Abort</a></td></tr><tr><td class="bitfield">0b100010</td><td><p>PC alignment fault exception.</p></td><td><a href="#fieldset_0-24_0_9">ISS encoding for an exception from an Illegal Execution state, or a PC or SP alignment fault</a></td></tr><tr><td class="bitfield">0b100100</td><td><p>Data Abort exception from a lower Exception level.</p><p>Used for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions.</p></td><td><a href="#fieldset_0-24_0_20">ISS encoding for an exception from a Data Abort</a></td></tr><tr><td class="bitfield">0b100101</td><td><p>Data Abort exception taken without a change in Exception level.</p><p>Used for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions.</p></td><td><a href="#fieldset_0-24_0_20">ISS encoding for an exception from a Data Abort</a></td></tr><tr><td class="bitfield">0b100110</td><td><p>SP alignment fault exception.</p></td><td><a href="#fieldset_0-24_0_9">ISS encoding for an exception from an Illegal Execution state, or a PC or SP alignment fault</a></td></tr><tr><td class="bitfield">0b100111</td><td><p>Memory Operation Exception.</p></td><td><a href="#fieldset_0-24_0_10">ISS encoding for an exception from the Memory Copy and Memory Set instructions</a></td><td>When FEAT_MOPS is implemented</td></tr><tr><td class="bitfield">0b101100</td><td><p>Trapped floating-point exception taken from AArch64 state.</p><p>This EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p></td><td><a href="#fieldset_0-24_0_21">ISS encoding for an exception from a trapped floating-point exception</a></td><td>When AArch64 is supported</td></tr><tr><td class="bitfield">0b101101</td><td><p>GCS exception.</p></td><td><a href="#fieldset_0-24_0_22">ISS encoding for a GCS exception</a></td><td>When FEAT_GCS is implemented</td></tr><tr><td class="bitfield">0b101111</td><td><p>SError exception.</p></td><td><a href="#fieldset_0-24_0_23">ISS encoding for an SError exception</a></td></tr><tr><td class="bitfield">0b111100</td><td><p>BRK instruction execution in AArch64 state.</p><p>This is reported in <a href="AArch64-esr_el3.html">ESR_EL3</a> only if a BRK instruction is executed in EL3. This is the only debug exception that can be taken to EL3 when EL3 is using AArch64.</p></td><td><a href="#fieldset_0-24_0_24">ISS encoding for an exception from execution of a Breakpoint instruction</a></td><td>When AArch64 is supported</td></tr><tr><td class="bitfield">0b111101</td><td><p>PMU exception</p></td><td><a href="#fieldset_0-24_0_8">ISS encoding for a PMU exception</a></td><td>When FEAT_EBEP is implemented</td></tr></table><p>All other EC values are reserved by Arm, and:</p><ul><li>Unused values in the range <span class="binarynumber">0b000000</span> - <span class="binarynumber">0b101100</span> (<span class="hexnumber">0x00</span> - <span class="hexnumber">0x2C</span>) are reserved for future use for synchronous exceptions.
</li><li>Unused values in the range <span class="binarynumber">0b101101</span> - <span class="binarynumber">0b111111</span> (<span class="hexnumber">0x2D</span> - <span class="hexnumber">0x3F</span>) are reserved for future use, and might be used for synchronous or asynchronous exceptions.
</li></ul><p>The effect of programming this field to a reserved value is that behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_25">IL, bit [25]</h4><div class="field"><p>Instruction Length for synchronous exceptions. Possible values of this bit are:</p><table class="valuetable"><tr><th>IL</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>16-bit instruction trapped.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>32-bit instruction trapped. This value is also used when the exception is one of the following:</p><ul><li><p>An SError exception.</p></li><li><p>An Instruction Abort exception.</p></li><li><p>A PC alignment fault exception.</p></li><li><p>An SP alignment fault exception.</p></li><li><p>A Data Abort exception for which the value of the ISV bit is 0.</p></li><li><p>An Illegal Execution state exception.</p></li><li><p>Any debug exception except for Breakpoint instruction exceptions.</p></li><li><p>An exception reported using EC value <span class="binarynumber">0b000000</span>.</p></li></ul></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0">ISS, bits [24:0]</h4><div class="field"><p>Instruction Specific Syndrome. Architecturally, this field can be defined independently for each defined Exception class. However, in practice, some ISS encodings are used for more than one Exception class.</p><p>Typically, an ISS encoding has a number of subfields. When an ISS subfield holds a register number, the value returned in that field is the AArch64 view of the register number.</p><p>For an exception taken from AArch32 state, see <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p><p>If the AArch32 register descriptor is <span class="binarynumber">0b1111</span>, then:</p><ul><li>If the instruction that generated the exception was not <span class="arm-defined-word">UNPREDICTABLE</span>, the field takes the value <span class="binarynumber">0b11111</span>.
</li><li>If the instruction that generated the exception was <span class="arm-defined-word">UNPREDICTABLE</span>, the field takes an <span class="arm-defined-word">UNKNOWN</span> value that must be either:<ul><li>The AArch64 view of the register number of a register that might have been used at the Exception level from which the exception was taken.
</li><li>The value <span class="binarynumber">0b11111</span>.
</li></ul></li></ul><div class="partial_fieldset"><h3 id="fieldset_0-24_0_0">ISS encoding for exceptions with an unknown reason</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#fieldset_0-24_0_0-24_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_0-24_0">Bits [24:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="text_after_fields"><p>When an exception is reported using this EC code the IL field is set to 1.</p><p>This EC code is used for all exceptions that are not covered by any other EC value. This includes exceptions that are generated in the following situations:</p><ul><li>The attempted execution of an instruction bit pattern that has no allocated instruction or that is not accessible at the current Exception level and Security state, including:<ul><li>A read access using a System register pattern that is not allocated for reads or that does not permit reads at the current Exception level and Security state.
</li><li>A write access using a System register pattern that is not allocated for writes or that does not permit writes at the current Exception level and Security state.
</li><li>Instruction encodings that are unallocated.
</li><li>Instruction encodings for instructions or System registers that are not implemented in the implementation.
</li></ul></li><li>In Debug state, the attempted execution of an instruction bit pattern that is not accessible in Debug state.
</li><li>In Non-debug state, the attempted execution of an instruction bit pattern that is not accessible in Non-debug state.
</li><li>In AArch32 state, attempted execution of a short vector floating-point instruction.
</li><li>In an implementation that does not include Advanced SIMD and floating-point functionality, an attempted access to Advanced SIMD or floating-point functionality under conditions where that access would be permitted if that functionality was present. This includes the attempted execution of an Advanced SIMD or floating-point instruction, and attempted accesses to Advanced SIMD and floating-point System registers.
</li><li>An exception generated because of the value of one of the <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.{ITD, SED, CP15BEN} control bits.
</li><li>Attempted execution of:<ul><li>An HVC instruction when disabled by <a href="AArch64-hcr_el2.html">HCR_EL2</a>.HCD or <a href="AArch64-scr_el3.html">SCR_EL3</a>.HCE.
</li><li>An SMC instruction when disabled by <a href="AArch64-scr_el3.html">SCR_EL3</a>.SMD.
</li><li>An HLT instruction when disabled by <a href="ext-edscr.html">EDSCR</a>.HDE.
</li></ul></li><li>Attempted execution of an MSR or MRS instruction to access <a href="AArch64-sp_el0.html">SP_EL0</a> when the value of <a href="AArch64-spsel.html">SPSel</a>.SP is 0.
</li><li>Attempted execution of an MSR or MRS instruction using a _EL12 register name when <a href="AArch64-hcr_el2.html">HCR_EL2</a>.E2H == 0.
</li><li>Attempted execution, in Debug state, of:<ul><li>A DCPS1 instruction when the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1 and EL2 is disabled or not implemented in the current Security state.
</li><li>A DCPS2 instruction from EL1 or EL0 when EL2 is disabled or not implemented in the current Security state.
</li><li>A DCPS3 instruction when the value of <a href="ext-edscr.html">EDSCR</a>.SDD is 1, or when EL3 is not implemented.
</li></ul></li><li>When EL3 is using AArch64, attempted execution from Secure EL1 of an SRS instruction using R13_mon.
</li><li>In Debug state when the value of <a href="ext-edscr.html">EDSCR</a>.SDD is 1, the attempted execution at EL2, EL1, or EL0 of an instruction that is configured to trap to EL3.
</li><li>In AArch32 state, the attempted execution of an MRS (banked register) or an MSR (banked register) instruction to SPSR_mon, SP_mon, or LR_mon.
</li><li><p>An exception that is taken to EL2 because the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE is 1 that, if the value of <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TGE was 0 would have been reported with an ESR_ELx.EC value of <span class="binarynumber">0b000111</span>.</p></li><li><p>In Non-transactional state, attempted execution of a TCOMMIT instruction.</p></li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_1">ISS encoding for an exception from a WF* instruction</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_1-24_24">CV</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_1-23_20">COND</a></td><td class="lr" colspan="10"><a href="#fieldset_0-24_0_1-19_10">RES0</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_1-9_5-1">RN</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_1-4_3">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_1-2_2-1">RV</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_1-1_0">TI</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_1-24_24">CV, bit [24]</h4><div class="field"><p>Condition code valid.</p><table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The COND field is not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The COND field is valid.</p></td></tr></table><p>For exceptions taken from AArch64, CV is set to 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_1-23_20">COND, bits [23:20]</h4><div class="field"><p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p><p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1 and:<ul><li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul></li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul><li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul></li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul><li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul></li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_1-19_10">Bits [19:10]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_1-9_5-1">RN, bits [9:5]<span class="condition"><br/>When FEAT_WFxT is implemented:
                        </span></h4><div class="field"><p>Register Number. Indicates the register number supplied for a <span class="instruction">WFET</span> or <span class="instruction">WFIT</span> instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_1-9_5-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_1-4_3">Bits [4:3]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_1-2_2-1">RV, bit [2]<span class="condition"><br/>When FEAT_WFxT is implemented:
                        </span></h4><div class="field"><p>Register field Valid.</p><p>If TI[1] == 1, then this field indicates whether RN holds a valid register number for the register argument to the trapped <span class="instruction">WFET</span> or <span class="instruction">WFIT</span> instruction.</p><table class="valuetable"><tr><th>RV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Register field invalid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Register field valid.</p></td></tr></table><p>If TI[1] == 0, then this field is <span class="arm-defined-word">RES0</span>.</p><p>This field is set to 1 on a trap on <span class="instruction">WFET</span> or <span class="instruction">WFIT</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_1-2_2-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_1-1_0">TI, bits [1:0]</h4><div class="field"><p>Trapped instruction. Possible values of this bit are:</p><table class="valuetable"><tr><th>TI</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00</td><td><p>WFI trapped.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>WFE trapped.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>WFIT trapped.</p></td><td>When FEAT_WFxT is implemented</td></tr><tr><td class="bitfield">0b11</td><td><p>WFET trapped.</p></td><td>When FEAT_WFxT is implemented</td></tr></table><p>When <span class="xref">FEAT_WFxT</span> is implemented, this is a two bit field as shown. Otherwise, bit[1] is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>The following fields describe configuration settings for generating this exception:</p><ul><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.{nTWE, nTWI}.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TWE, TWI}.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.{TWE, TWI}.
</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_2">ISS encoding for an exception from an MCR or MRC access</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_2-24_24">CV</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_2-23_20">COND</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_2-19_17">Opc2</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_2-16_14">Opc1</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_2-13_10">CRn</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_2-9_5">Rt</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_2-4_1">CRm</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_2-0_0">Direction</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_2-24_24">CV, bit [24]</h4><div class="field"><p>Condition code valid.</p><table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The COND field is not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The COND field is valid.</p></td></tr></table><p>For exceptions taken from AArch64, CV is set to 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_2-23_20">COND, bits [23:20]</h4><div class="field"><p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p><p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1 and:<ul><li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul></li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul><li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul></li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul><li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul></li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_2-19_17">Opc2, bits [19:17]</h4><div class="field"><p>The Opc2 value from the issued instruction.</p><p>For a trapped VMRS access, holds the value <span class="binarynumber">0b000</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_2-16_14">Opc1, bits [16:14]</h4><div class="field"><p>The Opc1 value from the issued instruction.</p><p>For a trapped VMRS access, holds the value <span class="binarynumber">0b111</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_2-13_10">CRn, bits [13:10]</h4><div class="field"><p>The CRn value from the issued instruction.</p><p>For a trapped VMRS access, holds the reg field from the VMRS instruction encoding.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_2-9_5">Rt, bits [9:5]</h4><div class="field"><p>The Rt value from the issued instruction, the general-purpose register used for the transfer.</p><p>If the Rt value is not <span class="binarynumber">0b1111</span>, then the reported value gives the AArch64 view of the register. Otherwise, if the Rt value is <span class="binarynumber">0b1111</span>:</p><ul><li><p>If the instruction that generated the exception is not <span class="arm-defined-word">UNPREDICTABLE</span>, then the register specifier takes the value <span class="binarynumber">0b11111</span>.</p></li><li><p>If the instruction that generated the exception is <span class="arm-defined-word">UNPREDICTABLE</span>, then the register specifier takes an <span class="arm-defined-word">UNKNOWN</span> value, which is restricted to either:</p><ul><li><p>The AArch64 view of one of the registers that could have been used in AArch32 state at the Exception level that the instruction was executed at.</p></li><li><p>The value <span class="binarynumber">0b11111</span>.</p></li></ul></li></ul><p>See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_2-4_1">CRm, bits [4:1]</h4><div class="field"><p>The CRm value from the issued instruction.</p><p>For a trapped VMRS access, holds the value <span class="binarynumber">0b0000</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_2-0_0">Direction, bit [0]</h4><div class="field"><p>Indicates the direction of the trapped instruction.</p><table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Write to System register space. MCR instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Read from System register space. MRC or VMRS instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b000011</span>:</p><ul><li>If <span class="xref">FEAT_TIDCP1</span> is implemented, <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.TIDCP, for EL0 accesses to <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> functionality using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1.
</li><li><a href="AArch64-cntkctl_el1.html">CNTKCTL_EL1</a>.{EL0PTEN, EL0VTEN, EL0PCTEN, EL0VCTEN}, for accesses to the Generic Timer Registers from EL0 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{ER, CR, SW, EN}, for accesses to Performance Monitor registers from EL0 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-amuserenr_el0.html">AMUSERENR_EL0</a>.EN, for accesses to Activity Monitors registers from EL0 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TRVM, TVM}, for accesses to virtual memory control registers from EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TTLB, for execution of TLB maintenance instructions at EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TSW, TPC, TPU} for execution of cache maintenance instructions at EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TACR, for accesses to the Auxiliary Control Register at EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TIDCP, for accesses to lockdown, DMA, and TCM operations at EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li>If <span class="xref">FEAT_TIDCP1</span> is implemented, <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.TIDCP, for EL0 accesses to <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> functionality using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TID1, TID2, TID3}, for accesses to ID registers at EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TCPAC, for accesses to <a href="AArch64-cpacr_el1.html">CPACR_EL1</a> or <a href="AArch32-cpacr.html">CPACR</a> using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T&lt;n>, for accesses to System registers using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cnthctl_el2.html">CNTHCTL_EL2</a>.EL1PCEN, for accesses to the Generic Timer registers from EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.{TPM, TPMCR}, for accesses to Performance Monitor registers from EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TAM, for accesses to Activity Monitors registers from EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TCPAC, for accesses to <a href="AArch32-cpacr.html">CPACR</a> from EL1 and EL2, and accesses to <a href="AArch32-hcptr.html">HCPTR</a> from EL2 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TPM, for accesses to Performance Monitor registers from EL0, EL1 and EL2 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TAM, for accesses to Activity Monitors registers from EL0, EL1 and EL2 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li>If <span class="xref">FEAT_FGT</span> is implemented, MCR or MRC access to some registers at EL0, trapped to EL2.
</li></ul><p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b000101</span>:</p><ul><li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.TTA for accesses to trace registers, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, for accesses to the Debug Communications Channel (DCC) registers at EL0 and EL1 using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL1 or EL2.
</li><li>If <span class="xref">FEAT_FGT</span> is implemented, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDCC for accesses to the DCC registers at EL0 and EL1 trapped to EL2, and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDCC for accesses to the DCC registers at EL0, EL1, and EL2 trapped to EL3.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TID0, for accesses to the <a href="AArch32-jidr.html">JIDR</a> register in the ID group 0 at EL0 and EL1 using AArch32, MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TTA, for accesses to trace registers using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDRA, for accesses to Debug ROM registers <a href="AArch32-dbgdrar.html">DBGDRAR</a> and <a href="AArch32-dbgdsar.html">DBGDSAR</a> using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDOSA, for accesses to powerdown debug registers, using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDA, for accesses to other debug registers, using AArch32 state, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TTA, for accesses to trace registers using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDOSA, for accesses to powerdown debug registers using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDA, for accesses to other debug registers, using AArch32, MCR or MRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li></ul><p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b001000</span>:</p><ul><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TID0, for accesses to the <a href="AArch32-fpsid.html">FPSID</a> register in ID group 0 at EL1 using AArch32 state, VMRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TID3, for accesses to registers in ID group 3 including <a href="AArch32-mvfr0.html">MVFR0</a>, <a href="AArch32-mvfr1.html">MVFR1</a> and <a href="AArch32-mvfr2.html">MVFR2</a>, VMRS access trapped to EL2.
</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_3">ISS encoding for an exception from an LD64B or ST64B* instruction</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#fieldset_0-24_0_3-24_0">ISS</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_3-24_0">ISS, bits [24:0]</h4><div class="field"><table class="valuetable"><tr><th>ISS</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b0000000000000000000000000</td><td><p>ST64BV instruction trapped.</p></td><td>When FEAT_LS64_V is implemented</td></tr><tr><td class="bitfield">0b0000000000000000000000001</td><td><p>ST64BV0 instruction trapped.</p></td><td>When FEAT_LS64_ACCDATA is implemented</td></tr><tr><td class="bitfield">0b0000000000000000000000010</td><td><p>LD64B or ST64B instruction trapped.</p></td><td>When FEAT_LS64 is implemented</td></tr></table><p>All other values are reserved.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_4">ISS encoding for an exception from an MCRR or MRRC access</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_4-24_24">CV</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_4-23_20">COND</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_4-19_16">Opc1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_4-15_15">RES0</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_4-14_10">Rt2</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_4-9_5">Rt</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_4-4_1">CRm</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_4-0_0">Direction</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_4-24_24">CV, bit [24]</h4><div class="field"><p>Condition code valid.</p><table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The COND field is not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The COND field is valid.</p></td></tr></table><p>For exceptions taken from AArch64, CV is set to 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_4-23_20">COND, bits [23:20]</h4><div class="field"><p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p><p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1 and:<ul><li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul></li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul><li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul></li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul><li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul></li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_4-19_16">Opc1, bits [19:16]</h4><div class="field"><p>The Opc1 value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_4-15_15">Bit [15]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_4-14_10">Rt2, bits [14:10]</h4><div class="field"><p>The Rt2 value from the issued instruction, the second general-purpose register used for the transfer.</p><p>If the Rt2 value is not <span class="binarynumber">0b1111</span>, then the reported value gives the AArch64 view of the register. Otherwise, if the Rt2 value is <span class="binarynumber">0b1111</span>:</p><ul><li><p>If the instruction that generated the exception is not <span class="arm-defined-word">UNPREDICTABLE</span>, then the register specifier takes the value <span class="binarynumber">0b11111</span>.</p></li><li><p>If the instruction that generated the exception is <span class="arm-defined-word">UNPREDICTABLE</span>, then the register specifier takes an <span class="arm-defined-word">UNKNOWN</span> value, which is restricted to either:</p><ul><li><p>The AArch64 view of one of the registers that could have been used in AArch32 state at the Exception level that the instruction was executed at.</p></li><li><p>The value <span class="binarynumber">0b11111</span>.</p></li></ul></li></ul><p>See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_4-9_5">Rt, bits [9:5]</h4><div class="field"><p>The Rt value from the issued instruction, the first general-purpose register used for the transfer.</p><p>If the Rt value is not <span class="binarynumber">0b1111</span>, then the reported value gives the AArch64 view of the register. Otherwise, if the Rt value is <span class="binarynumber">0b1111</span>:</p><ul><li><p>If the instruction that generated the exception is not <span class="arm-defined-word">UNPREDICTABLE</span>, then the register specifier takes the value <span class="binarynumber">0b11111</span>.</p></li><li><p>If the instruction that generated the exception is <span class="arm-defined-word">UNPREDICTABLE</span>, then the register specifier takes an <span class="arm-defined-word">UNKNOWN</span> value, which is restricted to either:</p><ul><li><p>The AArch64 view of one of the registers that could have been used in AArch32 state at the Exception level that the instruction was executed at.</p></li><li><p>The value <span class="binarynumber">0b11111</span>.</p></li></ul></li></ul><p>See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_4-4_1">CRm, bits [4:1]</h4><div class="field"><p>The CRm value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_4-0_0">Direction, bit [0]</h4><div class="field"><p>Indicates the direction of the trapped instruction.</p><table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Write to System register space. MCRR instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Read from System register space. MRRC instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b000100</span>:</p><ul><li><a href="AArch64-cntkctl_el1.html">CNTKCTL_EL1</a>.{EL0PTEN, EL0VTEN, EL0PCTEN, EL0VCTEN}, for accesses to the Generic Timer Registers from EL0 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{CR, EN}, for accesses to Performance Monitor registers from EL0 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-amuserenr_el0.html">AMUSERENR_EL0</a>.{EN}, for accesses to Activity Monitors registers AMEVCNTR0&lt;n> and AMEVCNTR1&lt;n> from EL0 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TRVM, TVM}, for accesses to virtual memory control registers from EL1 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-hstr_el2.html">HSTR_EL2</a>.T&lt;n>, for accesses to System registers using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cnthctl_el2.html">CNTHCTL_EL2</a>.{EL1PCEN, EL1PCTEN}, for accesses to the Generic Timer registers from EL0 and EL1 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.{TPM, TPMCR}, for accesses to Performance Monitor registers from EL0 and EL1 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TAM, for accesses to Activity Monitors registers AMEVCNTR0&lt;n> and AMEVCNTR1&lt;n> from EL0 and EL1 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TPM, for accesses to Performance Monitor registers from EL0, EL1 and EL2 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TAM, for accesses to Activity Monitors registers from EL0, EL1 and EL2 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1111</span>) trapped to EL3.
</li><li>If <span class="xref">FEAT_FGT</span> is implemented, <a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a>.PMCCNTR_EL0 for MRRC access and <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a>.PMCCNTR_EL0 for MCRR access to <a href="AArch32-pmccntr.html">PMCCNTR</a> at EL0, trapped to EL2.
</li></ul><p>The following fields describe configuration settings for generating exceptions that are reported using EC value <span class="binarynumber">0b001100</span>:</p><ul><li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, for accesses to the Debug ROM registers <a href="AArch32-dbgdsar.html">DBGDSAR</a> and <a href="AArch32-dbgdrar.html">DBGDRAR</a> at EL0 using AArch32 state, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDRA, for accesses to Debug ROM registers <a href="AArch32-dbgdrar.html">DBGDRAR</a> and <a href="AArch32-dbgdsar.html">DBGDSAR</a> using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDA, for accesses to debug registers, using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li><li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.TTA for accesses to trace registers using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL1 or EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TTA, for accesses to trace registers using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TTA, for accesses to trace registers using AArch32, MCRR or MRRC access (coproc == <span class="binarynumber">0b1110</span>) trapped to EL3.
</li></ul><div class="note"><span class="note-header">Note</span><p>If the Armv8-A architecture is implemented with an ETMv4 implementation, MCRR and MRRC accesses to trace registers are <span class="arm-defined-word">UNDEFINED</span> and the resulting exception is higher priority than an exception due to these traps.</p></div></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_5">ISS encoding for an exception from an LDC or STC instruction</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_5-24_24">CV</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_5-23_20">COND</a></td><td class="lr" colspan="8"><a href="#fieldset_0-24_0_5-19_12">imm8</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_5-11_10">RES0</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_5-9_5">Rn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_5-4_4">Offset</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_5-3_1">AM</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_5-0_0">Direction</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_5-24_24">CV, bit [24]</h4><div class="field"><p>Condition code valid.</p><table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The COND field is not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The COND field is valid.</p></td></tr></table><p>For exceptions taken from AArch64, CV is set to 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_5-23_20">COND, bits [23:20]</h4><div class="field"><p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p><p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1 and:<ul><li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul></li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul><li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul></li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul><li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul></li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_5-19_12">imm8, bits [19:12]</h4><div class="field"><p>The immediate value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_5-11_10">Bits [11:10]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_5-9_5">Rn, bits [9:5]</h4><div class="field"><p>The Rn value from the issued instruction, the general-purpose register used for the transfer.</p><p>If the Rn value is not <span class="binarynumber">0b1111</span>, then the reported value gives the AArch64 view of the register. Otherwise, if the Rn value is <span class="binarynumber">0b1111</span>:</p><ul><li><p>If the instruction that generated the exception is not <span class="arm-defined-word">UNPREDICTABLE</span>, then the register specifier takes the value <span class="binarynumber">0b11111</span>.</p></li><li><p>If the instruction that generated the exception is <span class="arm-defined-word">UNPREDICTABLE</span>, then the register specifier takes an <span class="arm-defined-word">UNKNOWN</span> value, which is restricted to either:</p><ul><li><p>The AArch64 view of one of the registers that could have been used in AArch32 state at the Exception level that the instruction was executed at.</p></li><li><p>The value <span class="binarynumber">0b11111</span>.</p></li></ul></li></ul><p>See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p><p>This field is valid only when AM[2] is 0, indicating an immediate form of the LDC or STC instruction. When AM[2] is 1, indicating a literal form of the LDC or STC instruction, this field is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_5-4_4">Offset, bit [4]</h4><div class="field"><p>Indicates whether the offset is added or subtracted:</p><table class="valuetable"><tr><th>Offset</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Subtract offset.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Add offset.</p></td></tr></table><p>This bit corresponds to the U bit in the instruction encoding.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_5-3_1">AM, bits [3:1]</h4><div class="field"><p>Addressing mode. The permitted values of this field are:</p><table class="valuetable"><tr><th>AM</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td><p>Immediate unindexed.</p></td></tr><tr><td class="bitfield">0b001</td><td><p>Immediate post-indexed.</p></td></tr><tr><td class="bitfield">0b010</td><td><p>Immediate offset.</p></td></tr><tr><td class="bitfield">0b011</td><td><p>Immediate pre-indexed.</p></td></tr><tr><td class="bitfield">0b100</td><td><p>For a trapped STC instruction or a trapped T32 LDC instruction this encoding is reserved.</p></td></tr><tr><td class="bitfield">0b110</td><td><p>For a trapped STC instruction, this encoding is reserved.</p></td></tr></table><p>The values <span class="binarynumber">0b101</span> and <span class="binarynumber">0b111</span> are reserved. The effect of programming this field to a reserved value is that behavior is <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, as described in <span class="xref">'Reserved values in System and memory-mapped registers and translation table entries'</span>.</p><p>Bit [2] in this subfield indicates the instruction form, immediate or literal.</p><p>Bits [1:0] in this subfield correspond to the bits {P, W} in the instruction encoding.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_5-0_0">Direction, bit [0]</h4><div class="field"><p>Indicates the direction of the trapped instruction.</p><table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Write to memory. STC instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Read from memory. LDC instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>The following fields describe the configuration settings for the traps that are reported using EC value <span class="binarynumber">0b000110</span>:</p><ul><li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, for accesses using AArch32 state, LDC access to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> or STC access to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> trapped to EL1 or EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDA, for accesses using AArch32 state, LDC access to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> or STC access to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> MCR or MRC access trapped to EL2.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDA, for accesses using AArch32 state, LDC access to <a href="AArch32-dbgdtrtxint.html">DBGDTRTXint</a> or STC access to <a href="AArch32-dbgdtrrxint.html">DBGDTRRXint</a> MCR or MRC access trapped to EL3.
</li><li>If <span class="xref">FEAT_FGT</span> is implemented, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDCC for LDC and STC accesses to the DCC registers at EL0 and EL1 trapped to EL2, and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDCC for accesses to the DCC registers at EL0, EL1, and EL2 trapped to EL3.
</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_6">ISS encoding for an exception from an access to SVE, Advanced SIMD or floating-point functionality, resulting from the FPEN and TFP traps</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_6-24_24">CV</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_6-23_20">COND</a></td><td class="lr" colspan="20"><a href="#fieldset_0-24_0_6-19_0">RES0</a></td></tr></tbody></table><div class="text_before_fields"><p>The accesses covered by this trap include:</p><ul><li>Execution of SVE or Advanced SIMD and floating-point instructions.
</li><li>Accesses to the Advanced SIMD and floating-point System registers.
</li><li>Execution of SME instructions.
</li></ul><p>For an implementation that does not include either SVE or support for Advanced SIMD and floating-point, the exception is reported using the EC value <span class="binarynumber">0b000000</span>.</p></div><h4 id="fieldset_0-24_0_6-24_24">CV, bit [24]</h4><div class="field"><p>Condition code valid.</p><table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The COND field is not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The COND field is valid.</p></td></tr></table><p>For exceptions taken from AArch64, CV is set to 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_6-23_20">COND, bits [23:20]</h4><div class="field"><p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p><p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1 and:<ul><li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul></li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul><li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul></li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul><li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul></li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_6-19_0">Bits [19:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="text_after_fields"><p>The following fields describe the configuration settings for the traps that are reported using EC value <span class="binarynumber">0b000111</span>:</p><ul><li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.FPEN, for accesses to SIMD and floating-point registers trapped to EL1.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.FPEN and <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TFP, for accesses to SIMD and floating-point registers trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TFP, for accesses to SIMD and floating-point registers trapped to EL3.
</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_7">ISS encoding for an exception from an access to SVE functionality, resulting from CPACR_EL1.ZEN, CPTR_EL2.ZEN, CPTR_EL2.TZ, or CPTR_EL3.EZ</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#fieldset_0-24_0_7-24_0">RES0</a></td></tr></tbody></table><div class="text_before_fields"><p>The accesses covered by this trap include:</p><ul><li>Execution of SVE instructions when the PE is not in Streaming SVE mode.
</li><li>Accesses to the SVE System registers, ZCR_ELx.
</li></ul><p>For an implementation that does not include SVE, the exception is reported using the EC value <span class="binarynumber">0b000000</span>.</p></div><h4 id="fieldset_0-24_0_7-24_0">Bits [24:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="text_after_fields"><p>The following fields describe the configuration settings for the traps that are reported using EC value <span class="binarynumber">0b011001</span>:</p><ul><li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.ZEN, for execution of SVE instructions and accesses to SVE registers at EL0 or EL1, trapped to EL1.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.ZEN and <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TZ, for execution of SVE instructions and accesses to SVE registers at EL0, EL1, or EL2, trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.EZ, for execution of SVE instructions and accesses to SVE registers from all Exception levels, trapped to EL3.
</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_8">ISS encoding for a PMU exception</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="24"><a href="#fieldset_0-24_0_8-24_1">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_8-0_0">SYNC</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_8-24_1">Bits [24:1]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_8-0_0">SYNC, bit [0]</h4><div class="field"><p>Indicates whether the exception was taken synchronously or asynchronously.</p><table class="valuetable"><tr><th>SYNC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b0</td><td><p>The exception was taken asynchronously because an overflow status flag was set.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The exception was taken synchronously because PSTATE.PPEND was set.</p></td><td>When FEAT_SEBEP is implemented</td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_9">ISS encoding for an exception from an Illegal Execution state, or a PC or SP alignment fault</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#fieldset_0-24_0_9-24_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_9-24_0">Bits [24:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="text_after_fields"><p>There are no configuration settings for generating Illegal Execution state exceptions and PC alignment fault exceptions. For more information about PC alignment fault exceptions, see <span class="xref">'PC alignment checking'</span>.</p><p><span class="xref">'SP alignment checking'</span> describes the configuration settings for generating SP alignment fault exceptions.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_10">ISS encoding for an exception from the Memory Copy and Memory Set instructions</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_10-24_24">MemInst</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_10-23_23">isSETG</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_10-22_19">Options</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_10-18_18">FromEpilogue</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_10-17_17">WrongOption</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_10-16_16">OptionA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_10-15_15">RES0</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_10-14_10">destreg</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_10-9_5">srcreg</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_10-4_0">sizereg</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_10-24_24">MemInst, bit [24]</h4><div class="field"><p>Indicates the memory instruction class causing the exception.</p><table class="valuetable"><tr><th>MemInst</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>CPYFE*, CPYFM*, CPYE*, and CPYM* instructions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>SETE*, SETM*, SETGE*, and SETGM* instructions.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_10-23_23">isSETG, bit [23]</h4><div class="field"><p>Indicates whether the instruction belongs to SETGM* or SETGE* class of instruction.</p><table class="valuetable"><tr><th>isSETG</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Not a SETGM* or SETGE* instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>SETGM* or SETGE* instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_10-22_19">Options, bits [22:19]</h4><div class="field"><p>Options : the Options field of the instruction.</p><p>For Memory Copy instructions, bits[22:19] forms the Options field, which holds the bits[15:12] of the instruction.</p><p>For Memory Set instructions:</p><ul><li>Bits[22:21] are <span class="arm-defined-word">RES0</span>.
</li><li>Bits[20:19] form the Options field, which holds the bits[13:12] of the instruction.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_10-18_18">FromEpilogue, bit [18]</h4><div class="field"><p>Indicates whether the instruction belongs to the epilogue class of Memory Copy or Memory Set instructions.</p><table class="valuetable"><tr><th>FromEpilogue</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Not an epilogue instruction.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>CPYE*, CPYFE*, SETE*, or SETGE* instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_10-17_17">WrongOption, bit [17]</h4><div class="field"><p>Algorithm option.</p><table class="valuetable"><tr><th>WrongOption</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>WrongOption is false.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>WrongOption is true.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_10-16_16">OptionA, bit [16]</h4><div class="field"><p>Algorithm type indicated by the PSTATE.C bit.</p><table class="valuetable"><tr><th>OptionA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>OptionB indicated by PSTATE.C is 0.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>OptionA indicated by PSTATE.C is 1.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_10-15_15">Bit [15]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_10-14_10">destreg, bits [14:10]</h4><div class="field"><p>The destination register value from the issued instruction, containing the destination address.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_10-9_5">srcreg, bits [9:5]</h4><div class="field"><p>The source register value from the issued instruction, containing either the source address or the source data.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_10-4_0">sizereg, bits [4:0]</h4><div class="field"><p>The size register value from the issued instruction, containing the number of bytes to be transfered or set.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_11">ISS encoding for an exception from HVC or SVC instruction execution</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="9"><a href="#fieldset_0-24_0_11-24_16">RES0</a></td><td class="lr" colspan="16"><a href="#fieldset_0-24_0_11-15_0">imm16</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_11-24_16">Bits [24:16]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_11-15_0">imm16, bits [15:0]</h4><div class="field"><p>The value of the immediate field from the HVC or SVC instruction.</p><p>For an HVC instruction, and for an A64 SVC instruction, this is the value of the imm16 field of the issued instruction.</p><p>For an A32 or T32 SVC instruction:</p><ul><li>If the instruction is unconditional, then:<ul><li>For the T32 instruction, this field is zero-extended from the imm8 field of the instruction.
</li><li>For the A32 instruction, this field is the bottom 16 bits of the imm24 field of the instruction.
</li></ul></li><li>If the instruction is conditional, this field is <span class="arm-defined-word">UNKNOWN</span>.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>In AArch32 state, the HVC instruction is unconditional, and a conditional SVC instruction generates an exception only if it passes its condition code check. Therefore, the syndrome information for these exceptions does not require conditionality information.</p><p>For T32 and A32 instructions, see <span class="xref">'SVC'</span> and <span class="xref">'HVC'</span>.</p><p>For A64 instructions, see <span class="xref">'SVC'</span> and <span class="xref">'HVC'</span>.</p><p>If <span class="xref">FEAT_FGT</span> is implemented, <a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a>.{SVC_EL1, SVC_EL0} control fine-grained traps on SVC execution.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_12">ISS encoding for an exception from SMC instruction execution in AArch32 state</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_12-24_24">CV</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_12-23_20">COND</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_12-19_19">CCKNOWNPASS</a></td><td class="lr" colspan="19"><a href="#fieldset_0-24_0_12-18_0">RES0</a></td></tr></tbody></table><div class="text_before_fields"><p>For an SMC instruction that completes normally and generates an exception that is taken to EL3, the ISS encoding is <span class="arm-defined-word">RES0</span>.</p><p>For an SMC instruction that is trapped to EL2 from EL1 because <a href="AArch64-hcr_el2.html">HCR_EL2</a>.TSC is 1, the ISS encoding is as shown in the diagram.</p></div><h4 id="fieldset_0-24_0_12-24_24">CV, bit [24]</h4><div class="field"><p>Condition code valid.</p><table class="valuetable"><tr><th>CV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The COND field is not valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The COND field is valid.</p></td></tr></table><p>For exceptions taken from AArch64, CV is set to 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1.
</li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether CV is set to 1 or set to 0. See the description of the COND field for more information.
</li></ul><p>This field is valid only if CCKNOWNPASS is 1, otherwise it is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_12-23_20">COND, bits [23:20]</h4><div class="field"><p>For exceptions taken from AArch64, this field is set to <span class="binarynumber">0b1110</span>.</p><p>The condition code for the trapped instruction. This field is valid only for exceptions taken from AArch32, and only when the value of CV is 1.</p><p>For exceptions taken from AArch32:</p><ul><li>When an A32 instruction is trapped, CV is set to 1 and:<ul><li>If the instruction is conditional, COND is set to the condition code field value from the instruction.
</li><li>If the instruction is unconditional, COND is set to <span class="binarynumber">0b1110</span>.
</li></ul></li><li>A conditional A32 instruction that is known to pass its condition code check can be presented either:<ul><li>With COND set to <span class="binarynumber">0b1110</span>, the value for unconditional.
</li><li>With the COND value held in the instruction.
</li></ul></li><li>When a T32 instruction is trapped, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether:<ul><li>CV is set to 0 and COND is set to an <span class="arm-defined-word">UNKNOWN</span> value. Software must examine the SPSR.IT field to determine the condition, if any, of the T32 instruction.
</li><li>CV is set to 1 and COND is set to the condition code for the condition that applied to the instruction.
</li></ul></li><li>For an implementation that, for both A32 and T32 instructions, takes an exception on a trapped conditional instruction only if the instruction passes its condition code check, these definitions mean that when CV is set to 1 it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the COND field is set to <span class="binarynumber">0b1110</span>, or to the value of any condition that applied to the instruction.
</li></ul><p>This field is valid only if CCKNOWNPASS is 1, otherwise it is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_12-19_19">CCKNOWNPASS, bit [19]</h4><div class="field"><p>Indicates whether the instruction might have failed its condition code check.</p><table class="valuetable"><tr><th>CCKNOWNPASS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The instruction was unconditional, or was conditional and passed its condition code check.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The instruction was conditional, and might have failed its condition code check.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>In an implementation in which an SMC instruction that fails it code check is not trapped, this field can always return the value 0.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_12-18_0">Bits [18:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="text_after_fields"><p><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TSC describes the configuration settings for trapping SMC instructions to EL2.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_13">ISS encoding for an exception from SMC instruction execution in AArch64 state</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="9"><a href="#fieldset_0-24_0_13-24_16">RES0</a></td><td class="lr" colspan="16"><a href="#fieldset_0-24_0_13-15_0">imm16</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_13-24_16">Bits [24:16]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_13-15_0">imm16, bits [15:0]</h4><div class="field"><p>The value of the immediate field from the issued SMC instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>The value of ISS[24:0] described here is used both:</p><ul><li>When an SMC instruction is trapped from EL1 modes.
</li><li>When an SMC instruction is not trapped, so completes normally and generates an exception that is taken to EL3.
</li></ul><p><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TSC describes the configuration settings for trapping SMC from EL1 modes.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_14">ISS encoding for an exception from MSR, MRS, or System instruction execution in AArch64 state</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="3"><a href="#fieldset_0-24_0_14-24_22">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_14-21_20">Op0</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_14-19_17">Op2</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_14-16_14">Op1</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_14-13_10">CRn</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_14-9_5">Rt</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_14-4_1">CRm</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_14-0_0">Direction</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_14-24_22">Bits [24:22]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_14-21_20">Op0, bits [21:20]</h4><div class="field"><p>The Op0 value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_14-19_17">Op2, bits [19:17]</h4><div class="field"><p>The Op2 value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_14-16_14">Op1, bits [16:14]</h4><div class="field"><p>The Op1 value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_14-13_10">CRn, bits [13:10]</h4><div class="field"><p>The CRn value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_14-9_5">Rt, bits [9:5]</h4><div class="field"><p>The Rt value from the issued instruction, the general-purpose register used for the transfer.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_14-4_1">CRm, bits [4:1]</h4><div class="field"><p>The CRm value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_14-0_0">Direction, bit [0]</h4><div class="field"><p>Indicates the direction of the trapped instruction.</p><table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Write access, including MSR instructions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Read access, including MRS instructions.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>For exceptions caused by System instructions, see <span class="xref">'System instructions' subsection of 'Branches, exception generating and System instructions'</span> for the encoding values returned by an instruction.</p><p>The following fields describe configuration settings for generating the exception that is reported using EC value <span class="binarynumber">0b011000</span>:</p><ul><li>If <span class="xref">FEAT_TIDCP1</span> is implemented, <a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.TIDCP, for EL0 accesses to <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> functionality using AArch64 state, MSR or MRS access trapped to EL1.
</li><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.UCI, for execution of cache maintenance instructions using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.UCT, for accesses to <a href="AArch64-ctr_el0.html">CTR_EL0</a> using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.DZE, for execution of DC ZVA instructions using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.UMA, for accesses to the PSTATE interrupt masks using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.TTA, for accesses to the trace registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-mdscr_el1.html">MDSCR_EL1</a>.TDCC, for accesses to the Debug Communications Channel (DCC) registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li>If <span class="xref">FEAT_FGT</span> is implemented, <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDCC for accesses to the DCC registers at EL0 and EL1 trapped to EL2, and <a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDCC for accesses to the DCC registers at EL0, EL1, and EL2 trapped to EL3.
</li><li><a href="AArch64-cntkctl_el1.html">CNTKCTL_EL1</a>.{EL0PTEN, EL0VTEN, EL0PCTEN, EL0VCTEN} accesses to the Generic Timer registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a>.{ER, CR, SW, EN}, for accesses to the Performance Monitor registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-amuserenr_el0.html">AMUSERENR_EL0</a>.EN, for accesses to Activity Monitors registers using AArch64 state, MSR or MRS access trapped to EL1 or EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TRVM, TVM}, for accesses to virtual memory control registers using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TDZ, for execution of DC ZVA instructions using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TTLB, for execution of TLB maintenance instructions using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TSW, TPC, TPU}, for execution of cache maintenance instructions using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TACR, for accesses to the Auxiliary Control Register, <a href="AArch64-actlr_el1.html">ACTLR_EL1</a>, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.TIDCP, for accesses to lockdown, DMA, and TCM operations using AArch64 state, MSR or MRS access trapped to EL2.
</li><li>If <span class="xref">FEAT_TIDCP1</span> is implemented, <a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.TIDCP, for EL0 accesses to <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> functionality using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TID1, TID2, TID3}, for accesses to ID group 1, ID group 2 or ID group 3 registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TCPAC, for accesses to <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TTA, for accesses to the trace registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TTRF, for accesses to the trace filter control register, <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a>, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDRA, for accesses to Debug ROM registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDOSA, for accesses to powerdown debug registers using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-cnthctl_el2.html">CNTHCTL_EL2</a>.{EL1PCEN, EL1PCTEN}, for accesses to the Generic Timer registers using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.TDA, for accesses to debug registers using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.{TPM, TPMCR}, for accesses to Performance Monitor registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TAM, for accesses to Activity Monitors registers, using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.APK, for accesses to Pointer authentication key registers. using AArch64 state, MSR or MRS access trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{NV, NV1}, for Nested virtualization register access, using AArch64 state, MSR or MRS access, trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.AT, for execution of AT S1E* instructions, using AArch64 state, MSR or MRS access, trapped to EL2.
</li><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TERR, FIEN}, for accesses to RAS registers, using AArch64 state, MSR or MRS access, trapped to EL2.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.APK, for accesses to Pointer authentication key registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.ST, for accesses to the Counter-timer Physical Secure timer registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.{TERR, FIEN}, for accesses to RAS registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TCPAC, for accesses to <a href="AArch64-cptr_el2.html">CPTR_EL2</a> and <a href="AArch64-cpacr_el1.html">CPACR_EL1</a> using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TTA, for accesses to the trace registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TTRF, for accesses to the trace filter control registers, <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> and <a href="AArch64-trfcr_el2.html">TRFCR_EL2</a>, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDA, for accesses to debug registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TDOSA, for accesses to powerdown debug registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-mdcr_el3.html">MDCR_EL3</a>.TPM, for accesses to Performance Monitor registers, using AArch64 state, MSR or MRS access trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.TAM, for accesses to Activity Monitors registers, using AArch64 state, MSR or MRS access, trapped to EL3.
</li><li>If <span class="xref">FEAT_EVT</span> is implemented, the following registers control traps for EL1 and EL0 Cache controls that use this EC value:<ul><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.{TTLBOS, TTLBIS, TICAB, TOCU, TID4}.
</li><li><a href="AArch32-hcr2.html">HCR2</a>.{TTLBIS, TICAB, TOCU, TID4}.
</li></ul></li><li>If <span class="xref">FEAT_FGT</span> is implemented:<ul><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn, for accesses to the fine-grained trap registers, MSR or MRS access at EL2 trapped to EL3.
</li><li><a href="AArch64-hfgrtr_el2.html">HFGRTR_EL2</a> for reads and <a href="AArch64-hfgwtr_el2.html">HFGWTR_EL2</a> for writes of registers, using AArch64 state, MSR or MRS access at EL0 and EL1 trapped to EL2.
</li><li><a href="AArch64-hfgitr_el2.html">HFGITR_EL2</a> for execution of system instructions, MSR or MRS access trapped to EL2
</li><li><a href="AArch64-hdfgrtr_el2.html">HDFGRTR_EL2</a> for reads and <a href="AArch64-hdfgwtr_el2.html">HDFGWTR_EL2</a> for writes of registers, using AArch64 state, MSR or MRS access at EL0 and EL1 state trapped to EL2.
</li><li><a href="AArch64-hafgrtr_el2.html">HAFGRTR_EL2</a> for reads of Activity Monitor counters, using AArch64 state, MRS access at EL0 and EL1 trapped to EL2.
</li></ul></li><li>If FEAT_RNG_TRAP is implemented:<ul><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.TRNDR for reads of <a href="AArch64-rndr.html">RNDR</a> and <a href="AArch64-rndrrs.html">RNDRRS</a> using AArch64 state, MRS access trapped to EL3.
</li></ul></li><li>If FEAT_SME is implemented:<ul><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.ESM, for MSR or MRS accesses to <a href="AArch64-smpri_el1.html">SMPRI_EL1</a> at EL1, EL2, and EL3, trapped to EL3.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.ESM, for MSR or MRS accesses to <a href="AArch64-smprimap_el2.html">SMPRIMAP_EL2</a> at EL2 and EL3, trapped to EL3.
</li><li><a href="AArch64-sctlr_el1.html">SCTLR_EL1</a>.EnTP2, for MSR or MRS accesses to <a href="AArch64-tpidr2_el0.html">TPIDR2_EL0</a> at EL0, trapped to EL1 or EL2.
</li><li><a href="AArch64-sctlr_el2.html">SCTLR_EL2</a>.EnTP2, for MSR or MRS accesses to <a href="AArch64-tpidr2_el0.html">TPIDR2_EL0</a> at EL0, trapped to EL2.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.EnTP2, for MSR or MRS accesses to <a href="AArch64-tpidr2_el0.html">TPIDR2_EL0</a> at EL0, EL1, and EL2, trapped to EL3.
</li></ul></li><li>If FEAT_NMI is implemented, <a href="AArch64-hcrx_el2.html">HCRX_EL2</a>.TALLINT, for MSR writes of <a href="AArch64-allint.html">ALLINT</a> at EL1, trapped to EL2.
</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_15">ISS encoding for an exception from MSRR, MRRS, or 128-bit System instruction execution in AArch64 state</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="3"><a href="#fieldset_0-24_0_15-24_22">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_15-21_20">Op0</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_15-19_17">Op2</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_15-16_14">Op1</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_15-13_10">CRn</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_15-9_6">Rt</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_15-5_5">RES0</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_15-4_1">CRm</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_15-0_0">Direction</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_15-24_22">Bits [24:22]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_15-21_20">Op0, bits [21:20]</h4><div class="field"><p>The Op0 value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_15-19_17">Op2, bits [19:17]</h4><div class="field"><p>The Op2 value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_15-16_14">Op1, bits [16:14]</h4><div class="field"><p>The Op1 value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_15-13_10">CRn, bits [13:10]</h4><div class="field"><p>The CRn value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_15-9_6">Rt, bits [9:6]</h4><div class="field"><p>The Rt value from the issued instruction, the general-purpose register used for the transfer.</p><div class="note"><span class="note-header">Note</span><p>This value represents register pair of X[Rt:0], X[Rt:1].</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_15-5_5">Bit [5]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_15-4_1">CRm, bits [4:1]</h4><div class="field"><p>The CRm value from the issued instruction.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_15-0_0">Direction, bit [0]</h4><div class="field"><p>Indicates the direction of the trapped instruction.</p><table class="valuetable"><tr><th>Direction</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Write access, MSRR instructions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Read access, MRRS instructions.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_16">ISS encoding for an IMPLEMENTATION DEFINED exception to EL3</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#fieldset_0-24_0_16-24_0">IMPLEMENTATION DEFINED</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_16-24_0">IMPLEMENTATION DEFINED, bits [24:0]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_17">ISS encoding for an exception from an Instruction Abort</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="10"><a href="#fieldset_0-24_0_17-24_15">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_17-14_14-1">PFV</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_17-13_13">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_17-12_11-1">SET</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_17-10_10">FnV</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_17-9_9">EA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_17-8_8">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_17-7_7">S1PTW</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_17-6_6">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_0-24_0_17-5_0">IFSC</a></td></tr></tbody></table><div class="text_before_fields"><p>When <span class="xref">FEAT_S1POE<del> or FEAT_S2POE</del></span> is implemented, if a memory access generates a Instruction Abort due to a Permission fault, the ISS2 encoding for an exception from an Instruction Abort includes further information about the exception.</p></div><h4 id="fieldset_0-24_0_17-24_15">Bits [24:15]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_17-14_14-1">PFV, bit [14]<span class="condition"><br/>When FEAT_PFAR is implemented and (IFSC == 0b010000, or IFSC == 0b01001x or IFSC == 0b0101xx):
                        </span></h4><div class="field"><p>FAR Valid. Describes whether the MFAR_EL3 is valid.</p><table class="valuetable"><tr><th>PFV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>MFAR_EL3 is <span class="arm-defined-word">UNKNOWN</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>MFAR_EL3 is valid.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_17-14_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_17-13_13">Bit [13]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_17-12_11-1">SET, bits [12:11]<span class="condition"><br/>When FEAT_RAS is implemented and (IFSC == 0b010000, or IFSC == 0b01001x or IFSC == 0b0101xx):
                        </span></h4><div class="field"><p>Synchronous Error Type. Describes the PE error state after taking the Instruction Abort exception.</p><table class="valuetable"><tr><th>SET</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00</td><td><p>Recoverable state (UER).</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Uncontainable (UC).</p></td><td>When FEAT_RASv2 is not implemented</td></tr><tr><td class="bitfield">0b11</td><td><p>Restartable state (UEO).</p></td></tr></table><p>All other values are reserved.</p><div class="note"><span class="note-header">Note</span><p>Software can use this information to determine what recovery might be possible. Taking a synchronous External Abort exception might result in a PE state that is not recoverable.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_17-12_11-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_17-10_10">FnV, bit [10]</h4><div class="field"><p>FAR not Valid, for a synchronous External abort other than a synchronous External abort on a translation table walk.</p><table class="valuetable"><tr><th>FnV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>FAR is valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>FAR is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p></td></tr></table><p>This field is valid only if the IFSC code is <span class="binarynumber">0b010000</span>. It is <span class="arm-defined-word">RES0</span> for all other aborts.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_17-9_9">EA, bit [9]</h4><div class="field"><p>External abort type. This bit can provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of External aborts.</p><p>For any abort other than an External abort this bit returns a value of 0.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_17-8_8">Bit [8]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_17-7_7">S1PTW, bit [7]</h4><div class="field"><p>For a stage 2 fault, indicates whether the fault was a stage 2 fault on an access made for a stage 1 translation table walk:</p><table class="valuetable"><tr><th>S1PTW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault not on a stage 2 translation for a stage 1 translation table walk.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault on the stage 2 translation of an access for a stage 1 translation table walk.</p></td></tr></table><p>For any abort other than a stage 2 fault this bit is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_17-6_6">Bit [6]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_17-5_0">IFSC, bits [5:0]</h4><div class="field"><p>Instruction Fault Status Code.</p><table class="valuetable"><tr><th>IFSC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td><p>Address size fault, level 0 of translation or translation table base register.</p></td></tr><tr><td class="bitfield">0b000001</td><td><p>Address size fault, level 1.</p></td></tr><tr><td class="bitfield">0b000010</td><td><p>Address size fault, level 2.</p></td></tr><tr><td class="bitfield">0b000011</td><td><p>Address size fault, level 3.</p></td></tr><tr><td class="bitfield">0b000100</td><td><p>Translation fault, level 0.</p></td></tr><tr><td class="bitfield">0b000101</td><td><p>Translation fault, level 1.</p></td></tr><tr><td class="bitfield">0b000110</td><td><p>Translation fault, level 2.</p></td></tr><tr><td class="bitfield">0b000111</td><td><p>Translation fault, level 3.</p></td></tr><tr><td class="bitfield">0b001001</td><td><p>Access flag fault, level 1.</p></td></tr><tr><td class="bitfield">0b001010</td><td><p>Access flag fault, level 2.</p></td></tr><tr><td class="bitfield">0b001011</td><td><p>Access flag fault, level 3.</p></td></tr><tr><td class="bitfield">0b001000</td><td><p>Access flag fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001100</td><td><p>Permission fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001101</td><td><p>Permission fault, level 1.</p></td></tr><tr><td class="bitfield">0b001110</td><td><p>Permission fault, level 2.</p></td></tr><tr><td class="bitfield">0b001111</td><td><p>Permission fault, level 3.</p></td></tr><tr><td class="bitfield">0b010000</td><td><p>Synchronous External abort, not on translation table walk or hardware update of translation table.</p></td></tr><tr><td class="bitfield">0b010010</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b010011</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b010100</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 0.</p></td></tr><tr><td class="bitfield">0b010101</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 1.</p></td></tr><tr><td class="bitfield">0b010110</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 2.</p></td></tr><tr><td class="bitfield">0b010111</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 3.</p></td></tr><tr><td class="bitfield">0b011000</td><td><p>Synchronous parity or ECC error on memory access, not on translation table walk.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011011</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented and FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011100</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011101</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011110</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011111</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b100010</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented and FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100011</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_RME is implemented and FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b100100</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100101</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100110</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100111</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101000</td><td><p>Granule Protection Fault, not on translation table walk or hardware update of translation table.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101001</td><td><p>Address size fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101010</td><td><p>Translation fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b101011</td><td><p>Translation fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101100</td><td><p>Address Size fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b110000</td><td><p>TLB conflict abort.</p></td></tr><tr><td class="bitfield">0b110001</td><td><p>Unsupported atomic hardware update fault.</p></td><td>When FEAT_HAFDBS is implemented</td></tr></table><p>All other values are reserved.</p><p>For more information about the lookup level associated with a fault, see <span class="xref">'The lookup level associated with MMU faults'</span>.</p><p>If the S1PTW bit is set, then the level refers the level of the stage2 translation that is translating a stage 1 translation walk.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_18">ISS encoding for an exception due to SME functionality</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="22"><a href="#fieldset_0-24_0_18-24_3">RES0</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_18-2_0">SMTC</a></td></tr></tbody></table><div class="text_before_fields"><p>The accesses covered by this trap include:</p><ul><li>Execution of SME instructions.
</li><li>Execution of SVE and Advanced SIMD instructions, when the PE is in Streaming SVE mode.
</li><li>Direct accesses of <a href="AArch64-svcr.html">SVCR</a>, <a href="AArch64-smcr_el1.html">SMCR_EL1</a>, <a href="AArch64-smcr_el2.html">SMCR_EL2</a>, <a href="AArch64-smcr_el3.html">SMCR_EL3</a>.
</li></ul></div><h4 id="fieldset_0-24_0_18-24_3">Bits [24:3]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_18-2_0">SMTC, bits [2:0]</h4><div class="field"><p>SME Trap Code. Identifies the reason for instruction trapping.</p><table class="valuetable"><tr><th>SMTC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000</td><td><p>Access to SME functionality trapped as a result of <a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.SMEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.SMEN, <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TSM, or <a href="AArch64-cptr_el3.html">CPTR_EL3</a>.ESM, that is not reported using EC <span class="binarynumber">0b000000</span>.</p></td></tr><tr><td class="bitfield">0b001</td><td><p>Advanced SIMD, SVE, or SVE2 instruction trapped because PSTATE.SM is 1.</p></td></tr><tr><td class="bitfield">0b010</td><td><p>SME instruction trapped because PSTATE.SM is 0.</p></td></tr><tr><td class="bitfield">0b011</td><td><p>SME instruction trapped because PSTATE.ZA is 0.</p></td></tr><tr><td class="bitfield">0b100</td><td><p>Access to the SME2 ZT0 register trapped as a result of <a href="AArch64-smcr_el1.html">SMCR_EL1</a>.EZT0, <a href="AArch64-smcr_el2.html">SMCR_EL2</a>.EZT0, or <a href="AArch64-smcr_el3.html">SMCR_EL3</a>.EZT0.</p></td><td>When FEAT_SME2 is implemented</td></tr></table><p>All other values are reserved.</p></div><div class="text_after_fields"><p>The following fields describe the configuration settings for the traps that are reported using the EC value <span class="binarynumber">0b011101</span>:</p><ul><li><a href="AArch64-cpacr_el1.html">CPACR_EL1</a>.SMEN, for execution of SME instructions, SVE instructions when the PE is in Streaming SVE mode, and instructions that directly access <a href="AArch64-svcr.html">SVCR</a> and <a href="AArch64-smcr_el1.html">SMCR_EL1</a> System registers at EL1 and EL0, trapped to EL1 or EL2.
</li><li><a href="AArch64-cptr_el2.html">CPTR_EL2</a>.SMEN and <a href="AArch64-cptr_el2.html">CPTR_EL2</a>.TSM, for execution of SME instructions, SVE instructions when the PE is in Streaming SVE mode, and instructions that directly access <a href="AArch64-svcr.html">SVCR</a>, <a href="AArch64-smcr_el1.html">SMCR_EL1</a>, <a href="AArch64-smcr_el2.html">SMCR_EL2</a> at EL2, EL1, or EL0, trapped to EL2.
</li><li><a href="AArch64-cptr_el3.html">CPTR_EL3</a>.ESM, for execution of SME instructions, SVE instructions when the PE is in Streaming SVE mode, and instructions that directly access <a href="AArch64-svcr.html">SVCR</a>, <a href="AArch64-smcr_el1.html">SMCR_EL1</a>, <a href="AArch64-smcr_el2.html">SMCR_EL2</a>, <a href="AArch64-smcr_el3.html">SMCR_EL3</a> from all Exception levels and any Security state, trapped to EL3.
</li><li>If FEAT_SME2 is implemented:<ul><li><a href="AArch64-smcr_el1.html">SMCR_EL1</a>.EZT0, for accesses to ZT0 at EL1 and EL0, trapped to EL1 or EL2.
</li><li><a href="AArch64-smcr_el2.html">SMCR_EL2</a>.EZT0, for accesses to ZT0 at EL2, EL1, and EL0, trapped to EL2.
</li><li><a href="AArch64-smcr_el3.html">SMCR_EL3</a>.EZT0, for accesses to ZT0 at any Exception level, trapped to EL3.
</li></ul></li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_19">ISS encoding for a Granule Protection Check exception</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="3"><a href="#fieldset_0-24_0_19-24_22">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_19-21_21">S2PTW</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_19-20_20">InD</a></td><td class="lr" colspan="6"><a href="#fieldset_0-24_0_19-19_14">GPCSC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_19-13_13">VNCR</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_19-12_9">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_19-8_8">CM</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_19-7_7">S1PTW</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_19-6_6">WnR</a></td><td class="lr" colspan="6"><a href="#fieldset_0-24_0_19-5_0">xFSC</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_19-24_22">Bits [24:22]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_19-21_21">S2PTW, bit [21]</h4><div class="field"><p>Indicates whether the Granule Protection Check exception was on an access made for a stage 2 translation table walk.</p><table class="valuetable"><tr><th>S2PTW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault not on a stage 2 translation table walk.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault on a stage 2 translation table walk.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_19-20_20">InD, bit [20]</h4><div class="field"><p>Indicates whether the Granule Protection Check exception was on an instruction or data access.</p><table class="valuetable"><tr><th>InD</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Data access.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Instruction access.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_19-19_14">GPCSC, bits [19:14]</h4><div class="field"><p>Granule Protection Check Status Code.</p><table class="valuetable"><tr><th>GPCSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000000</td><td><p>GPT address size fault at level 0.</p></td></tr><tr><td class="bitfield">0b000100</td><td><p>GPT walk fault at level 0.</p></td></tr><tr><td class="bitfield">0b000101</td><td><p>GPT walk fault at level 1.</p></td></tr><tr><td class="bitfield">0b001100</td><td><p>Granule protection fault at level 0.</p></td></tr><tr><td class="bitfield">0b001101</td><td><p>Granule protection fault at level 1.</p></td></tr><tr><td class="bitfield">0b010100</td><td><p>Synchronous External abort on GPT fetch at level 0.</p></td></tr><tr><td class="bitfield">0b010101</td><td><p>Synchronous External abort on GPT fetch at level 1.</p></td></tr></table><p>All other values are reserved.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_19-13_13">VNCR, bit [13]</h4><div class="field"><p>Indicates that the fault came from use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> register by EL1 code.</p><table class="valuetable"><tr><th>VNCR</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b0</td><td><p>The <ins>fault</ins><del>watchpoint</del> was not generated by the use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> by EL1 code.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The <ins>fault</ins><del>watchpoint</del> was generated by the use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> by EL1 code.</p></td><td>When FEAT_NV2 is implemented</td></tr></table><p>This field is 0 in ESR_EL1.</p><p>When InD is '1', this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_19-12_9">Bits [12:9]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_19-8_8">CM, bit [8]</h4><div class="field"><p>Cache maintenance. Indicates whether the Data Abort came from a cache maintenance or address translation instruction:</p><table class="valuetable"><tr><th>CM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort was not generated by the execution of one of the System instructions identified in the description of value 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort was generated by either the execution of a cache maintenance instruction or by a synchronous fault on the execution of an address translation instruction. The <a href="AArch64-dc-zva.html">DC ZVA</a>, <a href="AArch64-dc-gva.html">DC GVA</a>, and <a href="AArch64-dc-gzva.html">DC GZVA</a> instructions are not classified as cache maintenance instructions, and therefore their execution cannot cause this field to be set to 1.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_19-7_7">S1PTW, bit [7]</h4><div class="field"><p>Indicates whether the Granule Protection Check exception was on an access for stage 2 translation for a stage 1 translation table walk:</p><table class="valuetable"><tr><th>S1PTW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault not on a stage 2 translation for a stage 1 translation table walk.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault on the stage 2 translation of an access for a stage 1 translation table walk.</p></td></tr></table><p>For any abort other than a stage 2 fault this bit is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_19-6_6">WnR, bit [6]</h4><div class="field"><p>Write not Read. Indicates whether a synchronous abort was caused by an instruction writing to a memory location, or by an instruction reading from a memory location.</p><table class="valuetable"><tr><th>WnR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Abort caused by an instruction reading from a memory location.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Abort caused by an instruction writing to a memory location.</p></td></tr></table><p>When InD is '1', this field is <span class="arm-defined-word">RES0</span>.</p><p>For faults on cache maintenance and address translation instructions, this bit always returns a value of 1.</p><p>For faults from an atomic instruction that both reads and writes from a memory location, this bit is set to 0 if a read of the address specified by the instruction would have generated the fault which is being reported, otherwise it is set to 1. The architecture permits, but does not require, a relaxation of this requirement such that for all stage 2 aborts on stage 1 translation table walks for atomic instructions, the WnR bit is always 0.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> for:</p><ul><li>An External abort on an Atomic access.
</li><li>A fault reported using a DFSC value of <span class="binarynumber">0b110101</span> or <span class="binarynumber">0b110001</span>, indicating an unsupported Exclusive or atomic access.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_19-5_0">xFSC, bits [5:0]</h4><div class="field"><p>Instruction or Data Fault Status Code.</p><table class="valuetable"><tr><th>xFSC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b100011</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_RME is implemented and FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b100100</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100101</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100110</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100111</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101000</td><td><p>Granule Protection Fault, not on translation table walk or hardware update of translation table.</p></td><td>When FEAT_RME is implemented</td></tr></table><p>All other values are reserved.</p><p>For more information about the lookup level associated with a fault, see <span class="xref">'The lookup level associated with MMU faults'</span>.</p><p>If the S1PTW bit is set, then the level refers the level of the stage2 translation that is translating a stage 1 translation walk.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_20">ISS encoding for an exception from a Data Abort</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-24_24">ISV</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_20-23_22-1">SAS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-21_21-1">SSE</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_20-20_16-1">Bits[20:16]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-15_15-1">Bit[15]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-14_14-1">Bit[14]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-13_13">VNCR</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_20-12_11-1">Bits[12:11]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-10_10">FnV</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-9_9">EA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-8_8">CM</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-7_7">S1PTW</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_20-6_6">WnR</a></td><td class="lr" colspan="6"><a href="#fieldset_0-24_0_20-5_0">DFSC</a></td></tr></tbody></table><div class="text_before_fields"><p>When <span class="xref">FEAT_LS64_V</span> is implemented, if a memory access generated by an ST64BV instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, this ISS encoding includes ISS2, bits[36:32].</p><p>When <span class="xref">FEAT_LS64_ACCDATA</span> is implemented, if a memory access generated by an ST64BV0 instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, this ISS encoding includes ISS2, bits[36:32].</p><p>When <span class="xref">FEAT_S1POE</span> is implemented, if a memory access generates a Data Abort due to a Permission fault, the ISS2 encoding for an exception from a Data Abort includes further information about the exception.</p><p>When <span class="xref">FEAT_S1PIE</span> is implemented, if a memory write access generates a Data Abort due to a Permission fault, the ISS2 encoding for an exception from a Data Abort includes further information about the exception.</p></div><h4 id="fieldset_0-24_0_20-24_24">ISV, bit [24]</h4><div class="field"><p>Instruction Syndrome Valid. Indicates whether the syndrome information in ISS[23:14] is valid.</p><table class="valuetable"><tr><th>ISV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>No valid instruction syndrome. ISS[23:14] are <span class="arm-defined-word">RES0</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>ISS[23:14] hold a valid instruction syndrome.</p></td></tr></table><p>In ESR_EL2, ISV is 1 when <span class="xref">FEAT_LS64</span> is implemented and a memory access generated by an LD64B or ST64B instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault.</p><p>In ESR_EL2, ISV is 1 when <span class="xref">FEAT_LS64_V</span> is implemented and a memory access generated by an ST64BV instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault.</p><p>In ESR_EL2, ISV is 1 when <span class="xref">FEAT_LS64_ACCDATA</span> is implemented and a memory access generated by an ST64BV0 instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault.</p><p>For other faults reported in ESR_EL2, ISV is 0 except for the following stage 2 aborts:</p><ul><li>AArch64 loads and stores of a single general-purpose register (including the register specified with <span class="binarynumber">0b11111</span>, including those with Acquire/Release semantics, but excluding Load Exclusive or Store Exclusive and excluding those with writeback).
</li><li>AArch32 instructions where the instruction:<ul><li>Is an LDR, LDA, LDRT, LDRSH, LDRSHT, LDRH, LDAH, LDRHT, LDRSB, LDRSBT, LDRB, LDAB, LDRBT, STR, STL, STRT, STRH, STLH, STRHT, STRB, STLB, or STRBT instruction.
</li><li>Is not performing register writeback.
</li><li>Is not using R15 as a source or destination register.
</li></ul></li></ul><p>For these stage 2 aborts, ISV is <span class="arm-defined-word">UNKNOWN</span> if the exception was generated in Debug state in memory access mode, and otherwise indicates whether ISS[23:14] hold a valid syndrome.</p><p>For faults reported in ESR_EL1 or ESR_EL3, ISV is 1 when <span class="xref">FEAT_LS64</span> is implemented and a memory access generated by an LD64B or ST64B instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault.</p><p>For faults reported in ESR_EL1 or ESR_EL3, ISV is 1 when <span class="xref">FEAT_LS64_V</span> is implemented and a memory access generated by an ST64BV instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault.</p><p>For faults reported in ESR_EL1 or ESR_EL3, ISV is 1 when <span class="xref">FEAT_LS64_ACCDATA</span> is implemented and a memory access generated by an ST64BV0 instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault.</p><p>When FEAT_RAS is implemented, ISV is 0 for any synchronous External abort.</p><p>When FEAT_RAS is not implemented, it is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether ISV is set to 1 or 0 on a synchronous External abort on a stage 2 translation table walk.</p><p>For ISS reporting, a stage 2 abort on a stage 1 translation table walk does not return a valid instruction syndrome, and therefore ISV is 0 for these aborts.</p><p>When <span class="xref">FEAT_MTE2</span> is implemented, for a synchronous Tag Check Fault abort taken to ELx, ESR_ELx.FnV is 0 and <span class="xref">FAR_ELx</span> is valid.</p><p>When <span class="xref">FEAT_MOPS</span> is implemented, for a synchronous Data Abort on a Memory Copy and Memory Set instruction, ISV is 0.</p><p><ins>When </ins><span class="xref"><ins>FEAT_MTE</ins></span><ins> is implemented, for a synchronous Data Abort on an instruction that directly accesses Allocation Tags, ISV is 0.</ins></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-23_22-1">SAS, bits [23:22]<span class="condition"><br/>When ISV == 1:
                        </span></h4><div class="field"><p>Syndrome Access Size. Indicates the size of the access attempted by the faulting operation.</p><table class="valuetable"><tr><th>SAS</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Byte</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Halfword</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Word</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Doubleword</p></td></tr></table><p>When <span class="xref">FEAT_LS64</span> is implemented, if a memory access generated by an LD64B or ST64B instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is <span class="binarynumber">0b11</span>.</p><p>When <span class="xref">FEAT_LS64_V</span> is implemented, if a memory access generated by an ST64BV instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is <span class="binarynumber">0b11</span>.</p><p>When <span class="xref">FEAT_LS64_ACCDATA</span> is implemented, if a memory access generated by an ST64BV0 instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is <span class="binarynumber">0b11</span>.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-23_22-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_20-21_21-1">SSE, bit [21]<span class="condition"><br/>When ISV == 1:
                        </span></h4><div class="field"><p>Syndrome Sign Extend. For a byte, halfword, or word load operation, indicates whether the data item must be sign extended.</p><table class="valuetable"><tr><th>SSE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Sign-extension not required.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Data item must be sign-extended.</p></td></tr></table><p>When <span class="xref">FEAT_LS64</span> is implemented, if a memory access generated by an LD64B or ST64B instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 0.</p><p>When <span class="xref">FEAT_LS64_V</span> is implemented, if a memory access generated by an ST64BV instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 0.</p><p>When <span class="xref">FEAT_LS64_ACCDATA</span> is implemented, if a memory access generated by an ST64BV0 instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 0.</p><p>For all other operations, this field is 0.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-21_21-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_20-20_16-1">Bits[20:16]<span class="condition"><br/>When ISV == 1:
                        </span></h4><h5>SRT, bits [4:0]
                 of bits 
                        [20:16]</h5><div class="field"><p>Syndrome Register Transfer. The register number of the Wt/Xt/Rt operand of the faulting instruction.</p><p>If the exception was taken from an Exception level that is using AArch32, then this is the AArch64 view of the register. See <span class="xref">'Mapping of the general-purpose registers between the Execution states'</span>.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-20_18-2"><span class="condition"><br/>When ISV == 0, FEAT_RASv2 is implemented and (DFSC == 0b010000, or DFSC == 0b01001x or DFSC == 0b0101xx):
                        </span></h4><h5>Bits [4:2]
                 of bits 
                        [20:16]</h5><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_20-17_16-2"> </h4><h5>WU, bits [1:0]
                 of bits 
                        [20:16]</h5><div class="field"><p>Write Update. Describes whether a store instruction that generated an External abort updated the location.</p><table class="valuetable"><tr><th>WU</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Not a store instruction or translation table update, or the location might have been updated.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Store instruction or translation table update that did not update the location.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Store instruction or translation table update that updated the location.</p></td></tr></table><p>In the description of this field, a store instruction is any memory-writing instruction that explicitly performs a store. This includes instructions that both read and write memory.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-20_16-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_20-15_15-1">Bit[15]<span class="condition"><br/>When ISV == 1:
                        </span></h4><h5>SF, bit 
                        [15]</h5><div class="field"><p>Sixty Four bit general-purpose register transfer. Width of the register accessed by the instruction is 64-bit.</p><table class="valuetable"><tr><th>SF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Instruction loads/stores a 32-bit general-purpose register.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Instruction loads/stores a 64-bit general-purpose register.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>This field specifies the register width identified by the instruction, not the Execution state.</p></div><p>When <span class="xref">FEAT_LS64</span> is implemented, if a memory access generated by an LD64B or ST64B instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 1.</p><p>When <span class="xref">FEAT_LS64_V</span> is implemented, if a memory access generated by an ST64BV instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 1.</p><p>When <span class="xref">FEAT_LS64_ACCDATA</span> is implemented, if a memory access generated by an ST64BV0 instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 1.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-15_15-2"><span class="condition"><br/>When ISV == 0:
                        </span></h4><h5>FnP, bit 
                        [15]</h5><div class="field"><p>FAR not Precise.</p><table class="valuetable"><tr><th>FnP</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b0</td><td><p>The FAR holds the faulting virtual address that generated the Data Abort.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The FAR holds any virtual address within the naturally-aligned granule that contains the faulting virtual address that generated a Data Abort due to an SVE contiguous vector load/store
instruction, or an SME load/store instruction.</p><p>For more information about the naturally-aligned fault granule, see FAR_ELx (for example, <a href="AArch64-far_el1.html">FAR_EL1</a>).</p></td><td>When FEAT_SME is implemented or FEAT_SVE is implemented</td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-15_15-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_20-14_14-1">Bit[14]<span class="condition"><br/>When ISV == 1:
                        </span></h4><h5>AR, bit 
                        [14]</h5><div class="field"><p>Acquire/Release.</p><table class="valuetable"><tr><th>AR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Instruction did not have acquire/release semantics.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Instruction did have acquire/release semantics.</p></td></tr></table><p>When <span class="xref">FEAT_LS64</span> is implemented, if a memory access generated by an LD64B or ST64B instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 0.</p><p>When <span class="xref">FEAT_LS64_V</span> is implemented, if a memory access generated by an ST64BV instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 0.</p><p>When <span class="xref">FEAT_LS64_ACCDATA</span> is implemented, if a memory access generated by an ST64BV0 instruction generates a Data Abort for a Translation fault, Access flag fault, or Permission fault, then this field is 0.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> when the value of ISV is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-14_14-2"><span class="condition"><br/>When FEAT_PFAR is implemented and (DFSC == 0b010000, or DFSC == 0b01001x or DFSC == 0b0101xx):
                        </span></h4><h5>PFV, bit 
                        [14]</h5><div class="field"><p>FAR Valid. Describes whether the MFAR_EL3 is valid.</p><table class="valuetable"><tr><th>PFV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>MFAR_EL3 is <span class="arm-defined-word">UNKNOWN</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>MFAR_EL3 is valid.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-14_14-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_20-13_13">VNCR, bit [13]</h4><div class="field"><p>Indicates that the fault came from use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> register by EL1 code.</p><table class="valuetable"><tr><th>VNCR</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b0</td><td><p>The <ins>fault</ins><del>watchpoint</del> was not generated by the use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> by EL1 code.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The <ins>fault</ins><del>watchpoint</del> was generated by the use of <a href="AArch64-vncr_el2.html">VNCR_EL2</a> by EL1 code.</p></td><td>When FEAT_NV2 is implemented</td></tr></table><p>This field is 0 in ESR_EL1.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-12_11-1">Bits[12:11]<span class="condition"><br/>When (DFSC == 0b00xxxx || DFSC == <ins>0b10101x</ins><del>0b101011</del>) &amp;&amp; DFSC != 0b0000xx:
                        </span></h4><h5>LST, bits [1:0]
                 of bits 
                        [12:11]</h5><div class="field"><p>Load/Store Type. Used when a Translation fault, Access flag fault, or Permission fault generates a Data Abort.</p><table class="valuetable"><tr><th>LST</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00</td><td><p>The instruction that generated the Data Abort is not specified.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>An ST64BV instruction generated the Data Abort.</p></td><td>When FEAT_LS64_V is implemented</td></tr><tr><td class="bitfield">0b10</td><td><p>An LD64B or ST64B instruction generated the Data Abort.</p></td><td>When FEAT_LS64 is implemented</td></tr><tr><td class="bitfield">0b11</td><td><p>An ST64BV0 instruction generated the Data Abort.</p></td><td>When FEAT_LS64_ACCDATA is implemented</td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-12_11-2"><span class="condition"><br/>When FEAT_RAS is implemented and (DFSC == 0b010000, or DFSC == 0b01001x or DFSC == 0b0101xx):
                        </span></h4><h5>SET, bits [1:0]
                 of bits 
                        [12:11]</h5><div class="field"><p>Synchronous Error Type. Used when a Syncronous External abort, not on a Translation table walk or hardware update of the Translation table, generated the Data Abort. Describes the PE error state after taking the Data Abort exception.</p><table class="valuetable"><tr><th>SET</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b00</td><td><p>Recoverable state (UER).</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Uncontainable (UC).</p></td><td>When FEAT_RASv2 is not implemented</td></tr><tr><td class="bitfield">0b11</td><td><p>Restartable state (UEO).</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>Software can use this information to determine what recovery might be possible. Taking a synchronous External Abort exception might result in a PE state that is not recoverable.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-12_11-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_20-10_10">FnV, bit [10]</h4><div class="field"><p>FAR not Valid, for a synchronous External abort other than a synchronous External abort on a translation table walk.</p><table class="valuetable"><tr><th>FnV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>FAR is valid.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>FAR is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p></td></tr></table><p>This field is valid only if the DFSC code is <span class="binarynumber">0b010000</span>. It is <span class="arm-defined-word">RES0</span> for all other aborts.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-9_9">EA, bit [9]</h4><div class="field"><p>External abort type. This bit can provide an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of External aborts.</p><p>For any abort other than an External abort this bit returns a value of 0.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-8_8">CM, bit [8]</h4><div class="field"><p>Cache maintenance. Indicates whether the Data Abort came from a cache maintenance or address translation instruction:</p><table class="valuetable"><tr><th>CM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort was not generated by the execution of one of the System instructions identified in the description of value 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort was generated by either the execution of a cache maintenance instruction or by a synchronous fault on the execution of an address translation instruction. The <a href="AArch64-dc-zva.html">DC ZVA</a>, <a href="AArch64-dc-gva.html">DC GVA</a>, and <a href="AArch64-dc-gzva.html">DC GZVA</a> instructions are not classified as cache maintenance instructions, and therefore their execution cannot cause this field to be set to 1.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-7_7">S1PTW, bit [7]</h4><div class="field"><p>For a stage 2 fault, indicates whether the fault was a stage 2 fault on an access made for a stage 1 translation table walk:</p><table class="valuetable"><tr><th>S1PTW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault not on a stage 2 translation for a stage 1 translation table walk.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault on the stage 2 translation of an access for a stage 1 translation table walk.</p></td></tr></table><p>For any abort other than a stage 2 fault this bit is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-6_6">WnR, bit [6]</h4><div class="field"><p>Write not Read. Indicates whether a synchronous abort was caused by an instruction writing to a memory location, or by an instruction reading from a memory location.</p><table class="valuetable"><tr><th>WnR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Abort caused by an instruction reading from a memory location.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Abort caused by an instruction writing to a memory location.</p></td></tr></table><p>For faults on cache maintenance and address translation instructions, this bit always returns a value of 1.</p><p>For faults from an atomic instruction that both reads and writes from a memory location, this bit is set to 0 if a read of the address specified by the instruction would have generated the fault which is being reported, otherwise it is set to 1. The architecture permits, but does not require, a relaxation of this requirement such that for all stage 2 aborts on stage 1 translation table walks for atomic instructions, the WnR bit is always 0.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> for:</p><ul><li>If FEAT_RASv2 is implemented, an External abort on an Atomic access, reported with ESR_ELx.WU set to <span class="binarynumber">0b00</span>.
</li><li>A fault reported using a DFSC value of <span class="binarynumber">0b110101</span> or <span class="binarynumber">0b110001</span>, indicating an unsupported Exclusive or atomic access.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_20-5_0">DFSC, bits [5:0]</h4><div class="field"><p>Data Fault Status Code.</p><table class="valuetable"><tr><th>DFSC</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td><p>Address size fault, level 0 of translation or translation table base register.</p></td></tr><tr><td class="bitfield">0b000001</td><td><p>Address size fault, level 1.</p></td></tr><tr><td class="bitfield">0b000010</td><td><p>Address size fault, level 2.</p></td></tr><tr><td class="bitfield">0b000011</td><td><p>Address size fault, level 3.</p></td></tr><tr><td class="bitfield">0b000100</td><td><p>Translation fault, level 0.</p></td></tr><tr><td class="bitfield">0b000101</td><td><p>Translation fault, level 1.</p></td></tr><tr><td class="bitfield">0b000110</td><td><p>Translation fault, level 2.</p></td></tr><tr><td class="bitfield">0b000111</td><td><p>Translation fault, level 3.</p></td></tr><tr><td class="bitfield">0b001001</td><td><p>Access flag fault, level 1.</p></td></tr><tr><td class="bitfield">0b001010</td><td><p>Access flag fault, level 2.</p></td></tr><tr><td class="bitfield">0b001011</td><td><p>Access flag fault, level 3.</p></td></tr><tr><td class="bitfield">0b001000</td><td><p>Access flag fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001100</td><td><p>Permission fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001101</td><td><p>Permission fault, level 1.</p></td></tr><tr><td class="bitfield">0b001110</td><td><p>Permission fault, level 2.</p></td></tr><tr><td class="bitfield">0b001111</td><td><p>Permission fault, level 3.</p></td></tr><tr><td class="bitfield">0b010000</td><td><p>Synchronous External abort, not on translation table walk or hardware update of translation table.</p></td></tr><tr><td class="bitfield">0b010001</td><td><p>Synchronous Tag Check Fault.</p></td><td>When FEAT_MTE2 is implemented</td></tr><tr><td class="bitfield">0b010010</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b010011</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b010100</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 0.</p></td></tr><tr><td class="bitfield">0b010101</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 1.</p></td></tr><tr><td class="bitfield">0b010110</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 2.</p></td></tr><tr><td class="bitfield">0b010111</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 3.</p></td></tr><tr><td class="bitfield">0b011000</td><td><p>Synchronous parity or ECC error on memory access, not on translation table walk.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011011</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented and FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011100</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011101</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011110</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011111</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b100001</td><td><p>Alignment fault.</p></td></tr><tr><td class="bitfield">0b100010</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented and FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100011</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_RME is implemented and FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b100100</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100101</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100110</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100111</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101000</td><td><p>Granule Protection Fault, not on translation table walk or hardware update of translation table.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101001</td><td><p>Address size fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101010</td><td><p>Translation fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b101011</td><td><p>Translation fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101100</td><td><p>Address Size fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b110000</td><td><p>TLB conflict abort.</p></td></tr><tr><td class="bitfield">0b110001</td><td><p>Unsupported atomic hardware update fault.</p></td><td>When FEAT_HAFDBS is implemented</td></tr><tr><td class="bitfield">0b110100</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Lockdown).</p></td></tr><tr><td class="bitfield">0b110101</td><td><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> fault (Unsupported Exclusive or Atomic access).</p></td></tr></table><p>All other values are reserved.</p><p>For more information about the lookup level associated with a fault, see <span class="xref">'The lookup level associated with MMU faults'</span>.</p><p>If the S1PTW bit is set, then the level refers the level of the stage2 translation that is translating a stage 1 translation walk.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_21">ISS encoding for an exception from a trapped floating-point exception</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_21-24_24">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_21-23_23">TFV</a></td><td class="lr" colspan="12"><a href="#fieldset_0-24_0_21-22_11">RES0</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_21-10_8">VECITR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_21-7_7">IDF</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_21-6_5">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_21-4_4">IXF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_21-3_3">UFF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_21-2_2">OFF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_21-1_1">DZF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_21-0_0">IOF</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_21-24_24">Bit [24]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_21-23_23">TFV, bit [23]</h4><div class="field"><p>Trapped Fault Valid bit. Indicates whether the IDF, IXF, UFF, OFF, DZF, and IOF bits hold valid information about trapped floating-point exceptions.</p><table class="valuetable"><tr><th>TFV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The IDF, IXF, UFF, OFF, DZF, and IOF bits do not hold valid information about trapped floating-point exceptions and are <span class="arm-defined-word">UNKNOWN</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>One or more floating-point exceptions occurred during an operation performed while executing the reported instruction. The IDF, IXF, UFF, OFF, DZF, and IOF bits indicate trapped floating-point exceptions that occurred. For more information, see <span class="xref">'Floating-point exceptions and exception traps'</span>.</p></td></tr></table><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether this field is set to 0 on an exception generated by a trapped floating-point exception from an instruction that is performing floating-point operations on more than one lane of a vector.</p><div class="note"><span class="note-header">Note</span><p>This is not a requirement. Implementations can set this field to 1 on a trapped floating-point exception from an instruction and return valid information in the {IDF, IXF, UFF, OFF, DZF, IOF} fields.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_21-22_11">Bits [22:11]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_21-10_8">VECITR, bits [10:8]</h4><div class="field"><p>For a trapped floating-point exception from an instruction executed in AArch32 state this field is <span class="arm-defined-word">RES1</span>.</p><p>For a trapped floating-point exception from an instruction executed in AArch64 state this field is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_21-7_7">IDF, bit [7]</h4><div class="field"><p>Input Denormal floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p><table class="valuetable"><tr><th>IDF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Input denormal floating-point exception has not occurred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Input denormal floating-point exception occurred during execution of the reported instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_21-6_5">Bits [6:5]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_21-4_4">IXF, bit [4]</h4><div class="field"><p>Inexact floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p><table class="valuetable"><tr><th>IXF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Inexact floating-point exception has not occurred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Inexact floating-point exception occurred during execution of the reported instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_21-3_3">UFF, bit [3]</h4><div class="field"><p>Underflow floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p><table class="valuetable"><tr><th>UFF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Underflow floating-point exception has not occurred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Underflow floating-point exception occurred during execution of the reported instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_21-2_2">OFF, bit [2]</h4><div class="field"><p>Overflow floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p><table class="valuetable"><tr><th>OFF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Overflow floating-point exception has not occurred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Overflow floating-point exception occurred during execution of the reported instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_21-1_1">DZF, bit [1]</h4><div class="field"><p>Divide by Zero floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p><table class="valuetable"><tr><th>DZF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Divide by Zero floating-point exception has not occurred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Divide by Zero floating-point exception occurred during execution of the reported instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_21-0_0">IOF, bit [0]</h4><div class="field"><p>Invalid Operation floating-point exception trapped bit. If the TFV field is 0, this bit is <span class="arm-defined-word">UNKNOWN</span>. Otherwise, the possible values of this bit are:</p><table class="valuetable"><tr><th>IOF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Invalid Operation floating-point exception has not occurred.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Invalid Operation floating-point exception occurred during execution of the reported instruction.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>In an implementation that supports the trapping of floating-point exceptions:</p><ul><li>From an Exception level using AArch64, the <a href="AArch64-fpcr.html">FPCR</a>.{IDE, IXE, UFE, OFE, DZE, IOE} bits enable each of the floating-point exception traps.
</li><li>From an Exception level using AArch32, the <a href="AArch32-fpscr.html">FPSCR</a>.{IDE, IXE, UFE, OFE, DZE, IOE} bits enable each of the floating-point exception traps.
</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_22">ISS encoding for a GCS exception</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_22-24_24">RES0</a></td><td class="lr" colspan="4"><a href="#fieldset_0-24_0_22-23_20">ExType</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_22-19_15">RES0</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_22-14_10-1">Raddr</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_22-9_5-1">Bits[9:5]</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_22-4_0-1">IT</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_22-24_24">Bit [24]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_22-23_20">ExType, bits [23:20]</h4><div class="field"><p>The first level classification of GCS exceptions.</p><table class="valuetable"><tr><th>ExType</th><th>Meaning</th></tr><tr><td class="bitfield">0b0000</td><td><p>The exception reported is a Guarded control stack Data Check Exception.</p></td></tr><tr><td class="bitfield">0b0001</td><td><p>The exception reported is an EXLOCK Exception.</p></td></tr><tr><td class="bitfield">0b0010</td><td><p>The exception reported is a trap exception on GCSSTR or GCSSTTR instruction execution.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_22-19_15">Bits [19:15]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_22-14_10-1">Raddr, bits [14:10]<span class="condition"><br/>When ExType == 0b0010 :
                        </span></h4><div class="field"><p>Indicates the data address register number supplied in the instruction that has been trapped.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_22-14_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_22-9_5-1">Bits[9:5]<span class="condition"><br/>When ExType == 0b0000 :
                        </span></h4><h5>Rn, bits [4:0]
                 of bits 
                        [9:5]</h5><div class="field"><p>Indicates the register number supplied in the instruction that caused the Guarded control stack Data Check Exception.</p><p>This field is <span class="arm-defined-word">UNKNOWN</span> if ESR_ELx.ISS.IT is reported as <span class="binarynumber">0b00101</span> or <span class="binarynumber">0b01000</span></p><p>This field is <span class="binarynumber">0b11111</span> if ESR_ELx.ISS.IT is reported as <span class="binarynumber">0b01001</span></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_22-9_5-2"><span class="condition"><br/>When ExType == 0b0010 :
                        </span></h4><h5>Rvalue, bits [4:0]
                 of bits 
                        [9:5]</h5><div class="field"><p>Indicates the data value register number supplied in the instruction that has been trapped.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_22-9_5-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_22-4_0-1">IT, bits [4:0]<span class="condition"><br/>When ExType == 0b0000 :
                        </span></h4><div class="field"><p>Type of the instruction that caused the Guarded control stack Data Check Exception.</p><table class="valuetable"><tr><th>IT</th><th>Meaning</th></tr><tr><td class="bitfield">0b00000</td><td><p>Guarded control stack Data Check Exception is from a procedure return instruction without Pointer authentication.</p></td></tr><tr><td class="bitfield">0b00001</td><td><p>Guarded control stack Data Check Exception is from a GCSPOPM instruction.</p></td></tr><tr><td class="bitfield">0b00010</td><td><p>Guarded control stack Data Check Exception is from a procedure return instruction with Pointer authentication that uses key A.</p></td></tr><tr><td class="bitfield">0b00011</td><td><p>Guarded control stack Data Check Exception is from a procedure return instruction with Pointer authentication that uses key B.</p></td></tr><tr><td class="bitfield">0b00100</td><td><p>Guarded control stack Data Check Exception is from a GCSSS1 instruction.</p></td></tr><tr><td class="bitfield">0b00101</td><td><p>Guarded control stack Data Check Exception is from a GCSSS2 instruction.</p></td></tr><tr><td class="bitfield">0b01000</td><td><p>Guarded control stack Data Check Exception is from a GCSPOPCX instruction.</p></td></tr><tr><td class="bitfield">0b01001</td><td><p>Guarded control stack Data Check Exception is from a GCSPOPX instruction.</p></td></tr></table><p>All other values are reserved</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_22-4_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_23">ISS encoding for an SError exception</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-24_24">IDS</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_23-23_19">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-18_18-1">ELS</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_23-17_16-1">WU</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-15_15-1">VFV</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-14_14-1">PFV</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-13_13-1">IESB</a></td><td class="lr" colspan="3"><a href="#fieldset_0-24_0_23-12_10-1">AET</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-9_9-1">EA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-8_8">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-7_7-1">WnRV</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_23-6_6-1">WnR</a></td><td class="lr" colspan="6"><a href="#fieldset_0-24_0_23-5_0-1">DFSC</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_23-24_24">IDS, bit [24]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span> syndrome.</p><table class="valuetable"><tr><th>IDS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Bits [23:0] of the ISS field holds the fields described in this encoding.</p><div class="note"><span class="note-header">Note</span><p>If FEAT_RAS is not implemented, bits [23:0] of the ISS field are <span class="arm-defined-word">RES0</span>.</p></div></td></tr><tr><td class="bitfield">0b1</td><td><p>Bits [23:0] of the ISS field holds <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> syndrome information that can be used to provide additional information about the SError exception.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>This field was previously called ISV.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-23_19">Bits [23:19]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-18_18-1">ELS, bit [18]<span class="condition"><br/>When FEAT_RASv2 is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>Meaning of ELR_ELx.</p><table class="valuetable"><tr><th>ELS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Asynchronous. Does not indicate the trigger for the exception.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Synchronous. The exception was triggered by the instruction at ELR_ELx.</p></td></tr></table><p>SError exceptions that report this field is 1 are not required to be precise.</p><p>The ESR_EL3.AET field describes whether the exception is precise or imprecise.</p><p>Corrected, Recoverable or Restartable exceptions are precise. Unrecoverable or Uncontainable exceptions are imprecise.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-18_18-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-17_16-1">WU, bits [17:16]<span class="condition"><br/>When FEAT_RASv2 is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>Write Update. Describes whether a store instruction that generated an External abort updated the location.</p><table class="valuetable"><tr><th>WU</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Not a store instruction or translation table update, or the location might have been updated.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Store instruction or translation table update that did not update the location.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Store instruction or translation table update that updated the location.</p></td></tr></table><p>In the description of this field, a store instruction is any memory-writing instruction that explicitly performs a store. This includes instructions that both read and write memory.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-17_16-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-15_15-1">VFV, bit [15]<span class="condition"><br/>When FEAT_RASv2 is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>FAR Valid. Indicates the FAR_ELx register contains a valid virtual address.</p><table class="valuetable"><tr><th>VFV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>FAR_ELx is not valid, and holds an <span class="arm-defined-word">UNKNOWN</span> value.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>FAR_ELx contains a valid virtual address associated with the error.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-15_15-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-14_14-1">PFV, bit [14]<span class="condition"><br/>When FEAT_PFAR is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>FAR Valid. Describes whether the MFAR_EL3 is valid.</p><table class="valuetable"><tr><th>PFV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>MFAR_EL3 is <span class="arm-defined-word">UNKNOWN</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>MFAR_EL3 is valid.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-14_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-13_13-1">IESB, bit [13]<span class="condition"><br/>When FEAT_IESB is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>Implicit error synchronization event.</p><table class="valuetable"><tr><th>IESB</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The SError exception was either not synchronized by the implicit error synchronization event or not taken immediately.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The SError exception was synchronized by the implicit error synchronization event and taken immediately.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-13_13-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-12_10-1">AET, bits [12:10]<span class="condition"><br/>When FEAT_RAS is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>Asynchronous Error Type.</p><p>Describes the PE error state after taking the SError interrupt exception.</p><table class="valuetable"><tr><th>AET</th><th>Meaning</th></tr><tr><td class="bitfield">0b000</td><td><p>Uncontainable (UC).</p></td></tr><tr><td class="bitfield">0b001</td><td><p>Unrecoverable state (UEU).</p></td></tr><tr><td class="bitfield">0b010</td><td><p>Restartable state (UEO).</p></td></tr><tr><td class="bitfield">0b011</td><td><p>Recoverable state (UER).</p></td></tr><tr><td class="bitfield">0b110</td><td><p>Corrected (CE).</p></td></tr></table><p>All other values are reserved.</p><p>If multiple errors are taken as a single SError interrupt exception, the overall PE error state is reported.</p><div class="note"><span class="note-header">Note</span><p>Software can use this information to determine what recovery might be possible. The recovery software must also examine any implemented fault records to determine the location and extent of the error.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-12_10-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-9_9-1">EA, bit [9]<span class="condition"><br/>When FEAT_RAS is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>External abort type. Provides an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> classification of External aborts.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-9_9-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-8_8">Bit [8]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-7_7-1">WnRV, bit [7]<span class="condition"><br/>When FEAT_RASv2 is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>ESR_ELx.WnR valid.</p><table class="valuetable"><tr><th>WnRV</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>ESR_ELx.WnR is not valid and has been set to <span class="binarynumber">0b0</span>.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>ESR_ELx.WnR is valid.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-7_7-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-6_6-1">WnR, bit [6]<span class="condition"><br/>When FEAT_RASv2 is implemented and DFSC == 0b010001:
                        </span></h4><div class="field"><p>Write-not-Read. When the WnRV field is <span class="binarynumber">0b1</span>, indicates whether an exception was caused by an instruction writing to a memory location, or by an instruction reading from a memory location.</p><table class="valuetable"><tr><th>WnR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Exception was caused by an instruction reading from a memory location.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Exception was caused by an instruction writing to a memory location.</p></td></tr></table><p>Accessing this bit has the following behavior:</p><ul><li>This bit is <span class="arm-defined-word">RES0</span> if ESR_ELx.WnRV==<span class="binarynumber">0b0</span>.
</li><li>This bit is not valid and reads <span class="arm-defined-word">UNKNOWN</span> if an External abort on a Atomic access, reported with ESR_ELx.WU == <span class="binarynumber">0b00</span>.
</li><li>Otherwise RW.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-6_6-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_23-5_0-1">DFSC, bits [5:0]<span class="condition"><br/>When FEAT_RAS is implemented:
                        </span></h4><div class="field"><p>Data Fault Status Code.</p><table class="valuetable"><tr><th>DFSC</th><th>Meaning</th></tr><tr><td class="bitfield">0b000000</td><td><p>Uncategorized error.</p></td></tr><tr><td class="bitfield">0b010001</td><td><p>Asynchronous SError interrupt.</p></td></tr></table><p>All other values are reserved.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_23-5_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_24">ISS encoding for an exception from execution of a Breakpoint instruction</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="9"><a href="#fieldset_0-24_0_24-24_16">RES0</a></td><td class="lr" colspan="16"><a href="#fieldset_0-24_0_24-15_0">Comment</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_24-24_16">Bits [24:16]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_24-15_0">Comment, bits [15:0]</h4><div class="field"><p>Set to the instruction comment field value, zero extended as necessary.</p><p>For the AArch32 BKPT instructions, the comment field is described as the immediate field.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>For more information about generating these exceptions, see <span class="xref">'Breakpoint instruction exceptions'</span>.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_25">ISS encoding for an exception from a TSTART instruction</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="15"><a href="#fieldset_0-24_0_25-24_10">RES0</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_25-9_5">Rd</a></td><td class="lr" colspan="5"><a href="#fieldset_0-24_0_25-4_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_25-24_10">Bits [24:10]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_25-9_5">Rd, bits [9:5]</h4><div class="field"><p>The Rd value from the issued instruction, the general purpose register used for the destination.</p></div><h4 id="fieldset_0-24_0_25-4_0">Bits [4:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_26">ISS encoding for an exception from Branch Target Identification instruction</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="23"><a href="#fieldset_0-24_0_26-24_2">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-24_0_26-1_0">BTYPE</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_26-24_2">Bits [24:2]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_26-1_0">BTYPE, bits [1:0]</h4><div class="field"><p>This field is set to the PSTATE.BTYPE value that generated the Branch Target Exception.</p></div><div class="text_after_fields"><p>For more information about generating these exceptions, see <span class="xref">'The AArch64 application level programmers model'</span>.</p></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_27">ISS encoding for an exception from a Pointer Authentication instruction when HCR_EL2.API == 0 || SCR_EL3.API == 0</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="25"><a href="#fieldset_0-24_0_27-24_0">RES0</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_27-24_0">Bits [24:0]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="text_after_fields"><p>For more information about generating these exceptions, see:</p><ul><li><a href="AArch64-hcr_el2.html">HCR_EL2</a>.API, for exceptions from Pointer authentication instructions, using AArch64 state, trapped to EL2.
</li><li><a href="AArch64-scr_el3.html">SCR_EL3</a>.API, for exceptions from Pointer authentication instructions, using AArch64 state, trapped to EL3.
</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-24_0_28">ISS encoding for an exception from a Pointer Authentication instruction authentication failure</h3><table class="regdiagram"><thead><tr><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="23"><a href="#fieldset_0-24_0_28-24_2">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_28-1_1">Exception as a result of an Instruction key or a Data key</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_0_28-0_0">Exception as a result of an A key or a B key</a></td></tr></tbody></table><h4 id="fieldset_0-24_0_28-24_2">Bits [24:2]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_0_28-1_1">Bit [1]</h4><div class="field"><p>This field indicates whether the exception is as a result of an Instruction key or a Data key.</p><table class="valuetable"><tr><th/><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Instruction Key.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Data Key.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_0_28-0_0">Bit [0]</h4><div class="field"><p>This field indicates whether the exception is as a result of an A key or a B key.</p><table class="valuetable"><tr><th/><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>A key.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>B key.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="text_after_fields"><p>The following instructions generate an exception when the Pointer Authentication Code (PAC) is incorrect:</p><ul><li><span class="instruction">AUTIASP</span>, <span class="instruction">AUTIAZ</span>, <span class="instruction">AUTIA1716</span>.
</li><li><span class="instruction">AUTIBSP</span>, <span class="instruction">AUTIBZ</span>, <span class="instruction">AUTIB1716</span>.
</li><li><span class="instruction">AUTIA</span>, <span class="instruction">AUTDA</span>, <span class="instruction">AUTIB</span>, <span class="instruction">AUTDB</span>.
</li><li><span class="instruction">AUTIZA</span>, <span class="instruction">AUTIZB</span>, <span class="instruction">AUTDZA</span>, <span class="instruction">AUTDZB</span>.
</li></ul><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the following instructions generate an exception directly from the authorization failure, rather than changing the address in a way that will generate a Translation fault when the address is accessed:</p><ul><li><span class="instruction">RETAA</span>, <span class="instruction">RETAB</span>.
</li><li><span class="instruction">BRAA</span>, <span class="instruction">BRAB</span>, <span class="instruction">BLRAA</span>, <span class="instruction">BLRAB</span>.
</li><li><span class="instruction">BRAAZ</span>, <span class="instruction">BRABZ</span>, <span class="instruction">BLRAAZ</span>, <span class="instruction">BLRABZ</span>.
</li><li><span class="instruction">ERETAA</span>, <span class="instruction">ERETAB</span>.
</li><li><span class="instruction">LDRAA</span>, <span class="instruction">LDRAB</span>, whether the authenticated address is written back to the base register or not.
</li></ul></div></div></div><div class="access_mechanisms"><h2>Accessing ESR_EL3</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt>, ESR_EL3</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0101</td><td>0b0010</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    X[t, 64] = ESR_EL3;
                </p><h4 class="assembler">MSR ESR_EL3, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b110</td><td>0b0101</td><td>0b0010</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    UNDEFINED;
elsif PSTATE.EL == EL2 then
    UNDEFINED;
elsif PSTATE.EL == EL3 then
    ESR_EL3 = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>30</ins><del>28</del>/03/2023 <ins>19</ins><del>16</del>:<ins>07</ins><del>02</del>; <ins>997dd0cf3258cacf72aa7cf7a885f19a4758c3af</ins><del>72747e43966d6b97dcbd230a1b3f0421d1ea3d94</del></p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>