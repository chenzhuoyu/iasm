<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>VTTBR_EL2</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">VTTBR_EL2, Virtualization Translation Table Base Register</h1><p>The VTTBR_EL2 characteristics are:</p><h2>Purpose</h2><p>Holds the base address of the translation table for the initial lookup for stage 2 of an address translation in the EL1&amp;0 translation regime, and other information for this translation regime.</p><h2>Configuration</h2><p>AArch64 System register VTTBR_EL2 bits [63:0] are architecturally mapped to AArch32 System register <a href="AArch32-vttbr.html">VTTBR[63:0]</a>.</p><p>If EL2 is not implemented, this register is <span class="arm-defined-word">RES0</span> from EL3.</p><p>This register has no effect if EL2 is not enabled in the current Security state.</p><p>VTTBR_EL2 is a 128-bit register that can also be accessed as a 64-bit value. If it is accessed as a 64-bit register, accesses read and write bits [63:0] and do not modify bits [127:64].</p><h2>Attributes</h2><p>VTTBR_EL2 is a:</p><ul><li>128-bit register when FEAT_D128 is implemented and VTCR_EL2.D128 == 1
</li><li>64-bit register when FEAT_D128 is not implemented or VTCR_EL2.D128 == 0
</li></ul><h2>Field descriptions</h2><h3>When FEAT_D128 is implemented and VTCR_EL2.D128 == 1:</h3><table class="regdiagram"><thead><tr><td>127</td><td>126</td><td>125</td><td>124</td><td>123</td><td>122</td><td>121</td><td>120</td><td>119</td><td>118</td><td>117</td><td>116</td><td>115</td><td>114</td><td>113</td><td>112</td><td>111</td><td>110</td><td>109</td><td>108</td><td>107</td><td>106</td><td>105</td><td>104</td><td>103</td><td>102</td><td>101</td><td>100</td><td>99</td><td>98</td><td>97</td><td>96</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-127_88">RES0</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>95</td><td>94</td><td>93</td><td>92</td><td>91</td><td>90</td><td>89</td><td>88</td><td>87</td><td>86</td><td>85</td><td>84</td><td>83</td><td>82</td><td>81</td><td>80</td><td>79</td><td>78</td><td>77</td><td>76</td><td>75</td><td>74</td><td>73</td><td>72</td><td>71</td><td>70</td><td>69</td><td>68</td><td>67</td><td>66</td><td>65</td><td>64</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_0-127_88">RES0</a></td><td class="lr" colspan="8"><a href="#fieldset_0-87_80">BADDR[50:43]</a></td><td class="lr" colspan="16"><a href="#fieldset_0-79_64">RES0</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_0-63_48">VMID</a></td><td class="lr" colspan="16"><a href="#fieldset_0-47_5">BADDR[42:0]</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="27"><a href="#fieldset_0-47_5">BADDR[42:0]</a></td><td class="lr" colspan="2"><a href="#fieldset_0-4_3">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-2_1">SKL</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0-1">CnP</a></td></tr></tbody><tr class="blank_row"/></table><h4 id="fieldset_0-127_88">Bits [127:88]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-87_80">BADDR, bits [87:80, 47:5]</h4><div class="field"><p>Translation table base address:</p><ul><li>Bits A[55:x] of the stage 2 translation table base address bits are in register bits[87:80, 47:x].
</li><li>Bits A[(x-1):0] of the stage 2 translation table base address are zero.
</li></ul><p>Address bit x is the minimum address bit required to align the translation table to the size of the table. x is calculated based on LOG2(StartTableSize), as described in VMSAv9-128. The smallest permitted value of x is 5.</p><p>The BADDR field is split as follows:</p><ul><li>BADDR[50:43] is VTTBR_EL2[87:80].
</li><li>BADDR[42:0] is VTTBR_EL2[47:5].
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-79_64">Bits [79:64]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-63_48">VMID, bits [63:48]</h4><div class="field"><div class="partial_fieldset"><h3 id="fieldset_0-63_48_0">VMID encoding when FEAT_VMID16 is implemented and VTCR_EL2.VS == 1</h3><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_0-63_48_0-15_0">VMID</a></td></tr></tbody></table><h4 id="fieldset_0-63_48_0-15_0">VMID, bits [15:0]</h4><div class="field"><p>The VMID for the translation table.</p><p>If the implementation has an 8-bit VMID, bits [15:8] of this field are <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_0-63_48_1">VMID encoding when FEAT_VMID16 is not implemented or VTCR_EL2.VS == 0</h3><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_0-63_48_1-15_8">RES0</a></td><td class="lr" colspan="8"><a href="#fieldset_0-63_48_1-7_0">VMID</a></td></tr></tbody></table><h4 id="fieldset_0-63_48_1-15_8">Bits [15:8]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-63_48_1-7_0">VMID, bits [7:0]</h4><div class="field"><p>The VMID for the translation table.</p><p>The VMID is 8 bits when any of the following are true:</p><ul><li>EL2 is using AArch32.
</li><li><a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.VS is 0.
</li><li><span class="xref">FEAT_VMID16</span> is not implemented.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div></div><h4 id="fieldset_0-4_3">Bits [4:3]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-2_1">SKL, bits [2:1]</h4><div class="field"><p>Skip Level. Skip Level determines the number of levels to be skipped from the regular start level of the Non-Secure <ins>stage</ins><del>Stage</del> 2 translation table walk.</p><table class="valuetable"><tr><th>SKL</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Skip 0 level from the regular start level.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Skip 1 level from the regular start level.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Skip 2 levels from the regular start level.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Skip 3 levels from the regular start level.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-0_0-1">CnP, bit [0]<span class="condition"><br/>When FEAT_TTCNP is implemented:
                        </span></h4><div class="field"><p>Common not Private. This bit indicates whether each entry that is pointed to by VTTBR_EL2 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of VTTBR_EL2.CnP is 1.</p><table class="valuetable"><tr><th>CnP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The translation table entries pointed to by VTTBR_EL2 are permitted to differ from the entries for VTTBR_EL2 for other PEs in the Inner Shareable domain. This is not affected by the value of the current VMID.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The translation table entries pointed to by VTTBR_EL2 are the same as the translation table entries for every other PE in the Inner Shareable domain for which the value of VTTBR_EL2.CnP is 1 and the VMID is the same as the current VMID.</p></td></tr></table><p>This bit is permitted to be cached in a TLB.</p><div class="note"><span class="note-header">Note</span><p>If the value of VTTBR_EL2.CnP bit is 1 on multiple PEs in the same Inner Shareable domain and those VTTBR_EL2s do not point to the same translation table entries when using the current VMID then the results of translations using VTTBR_EL2 are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, see <span class="xref">'CONSTRAINED UNPREDICTABLE behaviors due to caching of control or data values'</span>.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-0_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h3>When FEAT_D128 is not implemented or VTCR_EL2.D128 == 0:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_1-63_48">VMID</a></td><td class="lr" colspan="16"><a href="#fieldset_1-47_1">BADDR</a></td></tr><tr class="firstrow"><td class="lr" colspan="31"><a href="#fieldset_1-47_1">BADDR</a></td><td class="lr" colspan="1"><a href="#fieldset_1-0_0-1">CnP</a></td></tr></tbody></table><h4 id="fieldset_1-63_48">VMID, bits [63:48]</h4><div class="field"><div class="partial_fieldset"><h3 id="fieldset_1-63_48_0">VMID encoding when FEAT_VMID16 is implemented and VTCR_EL2.VS == 1</h3><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_1-63_48_0-15_0">VMID</a></td></tr></tbody></table><h4 id="fieldset_1-63_48_0-15_0">VMID, bits [15:0]</h4><div class="field"><p>The VMID for the translation table.</p><p>If the implementation has an 8-bit VMID, bits [15:8] of this field are <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div><div class="partial_fieldset"><h3 id="fieldset_1-63_48_1">VMID encoding when FEAT_VMID16 is not implemented or VTCR_EL2.VS == 0</h3><table class="regdiagram"><thead><tr><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_1-63_48_1-15_8">RES0</a></td><td class="lr" colspan="8"><a href="#fieldset_1-63_48_1-7_0">VMID</a></td></tr></tbody></table><h4 id="fieldset_1-63_48_1-15_8">Bits [15:8]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-63_48_1-7_0">VMID, bits [7:0]</h4><div class="field"><p>The VMID for the translation table.</p><p>The VMID is 8 bits when any of the following are true:</p><ul><li>EL2 is using AArch32.
</li><li><a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.VS is 0.
</li><li><span class="xref">FEAT_VMID16</span> is not implemented.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div></div></div><h4 id="fieldset_1-47_1">BADDR, bits [47:1]</h4><div class="field"><p>Translation table base address, A[47:x] or A[51:x], bits[47:1].</p><div class="note"><span class="note-header">Note</span><p>If an OA size of more than 48 bits is in use, and the translation table has fewer than eight entries, the table must be aligned to 64 bytes. Otherwise the translation table must be aligned to the size of the table.</p></div><p>In an implementation that includes <span class="xref">FEAT_LPA</span>, if the value of <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.PS is <span class="binarynumber">0b110</span>, then:</p><ul><li>Register bits[47:z] hold bits[47:z] of the stage 2 translation table base address, where z is determined as follows:<ul><li>If x >= 6 then z=x.
</li><li>Otherwise, z=6.
</li></ul></li><li>Register bits[5:2] hold bits[51:48] of the stage 2 translation table base address.
</li><li>When z>x register bits[(z-1):x] are <span class="arm-defined-word">RES0</span>, and bits[(z-1):x] of the translation table base address are zero.
</li><li>When x>6 register bits[(x-1):6] are <span class="arm-defined-word">RES0</span>.
</li><li>Register bit[1] is <span class="arm-defined-word">RES0</span>.
</li><li>Bits[5:2] of the stage 2 translation table base address are zero.
</li><li>In an implementation that includes <span class="xref">FEAT_TTCNP</span>, bit[0] of the stage 2 translation table base address is zero.
</li></ul><div class="note"><span class="note-header">Note</span><p>When the value of <a href="AArch64-id_aa64mmfr0_el1.html">ID_AA64MMFR0_EL1</a>.PARange indicates that the implementation does not support a 52 bit PA size, if a translation table lookup uses this register when the <span class="xref">Effective value</span> of <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.PS is <span class="binarynumber">0b110</span> and the value of register bits[5:2] is nonzero, an Address size fault is generated.
When the value of <a href="AArch64-id_aa64mmfr0_el1.html">ID_AA64MMFR0_EL1</a>.PARange indicates that the implementation supports a 56 bit PA size, bits [55:52] of the stage 2 translation table base address are zero.</p><p>If the Effective value of <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.PS is not <span class="binarynumber">0b110</span> then:</p><ul><li>Register bits[47:x] hold bits[47:x] of the stage 2 translation table base address.</li><li>Register bits[(x-1):1] are <span class="arm-defined-word">RES0</span>.</li><li>If the implementation supports 52-bit PAs and IPAs then bits[51:48] of the translation table base addresses used in this stage of translation are <span class="binarynumber">0b0000</span>.</li></ul><p>If any VTTBR_EL2[47:0] bit that is defined as <span class="arm-defined-word">RES0</span> has the value 1 when a translation table walk is performed using VTTBR_EL2, then the translation table base address might be misaligned, with effects that are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and must be one of the following:</p><ul><li>Bits[x-1:0] of the translation table base address are treated as if all the bits are zero. The value read back from the corresponding register bits is either the value written to the register or zero.</li><li>The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.</li></ul><p>The AArch64 Virtual Memory System Architecture chapter describes how x is calculated based on the value of <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.T0SZ, the stage of translation, and the translation granule size.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-0_0-1">CnP, bit [0]<span class="condition"><br/>When FEAT_TTCNP is implemented:
                        </span></h4><div class="field"><p>Common not Private. This bit indicates whether each entry that is pointed to by VTTBR_EL2 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of VTTBR_EL2.CnP is 1.</p><table class="valuetable"><tr><th>CnP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The translation table entries pointed to by VTTBR_EL2 are permitted to differ from the entries for VTTBR_EL2 for other PEs in the Inner Shareable domain. This is not affected by the value of the current VMID.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The translation table entries pointed to by VTTBR_EL2 are the same as the translation table entries for every other PE in the Inner Shareable domain for which the value of VTTBR_EL2.CnP is 1 and the VMID is the same as the current VMID.</p></td></tr></table><p>This bit is permitted to be cached in a TLB.</p><div class="note"><span class="note-header">Note</span><p>If the value of VTTBR_EL2.CnP bit is 1 on multiple PEs in the same Inner Shareable domain and those VTTBR_EL2s do not point to the same translation table entries when using the current VMID then the results of translations using VTTBR_EL2 are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, see <span class="xref">'CONSTRAINED UNPREDICTABLE behaviors due to caching of control or data values'</span>.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-0_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="access_mechanisms"><h2>Accessing VTTBR_EL2</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt>, VTTBR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0010</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV> == '11' then
        X[t, 64] = NVMem[0x020];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    X[t, 64] = VTTBR_EL2&lt;63:0>;
elsif PSTATE.EL == EL3 then
    X[t, 64] = VTTBR_EL2&lt;63:0>;
                </p><h4 class="assembler">MSR VTTBR_EL2, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0010</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV> == '11' then
        NVMem[0x020] = X[t, 64];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    VTTBR_EL2&lt;63:0> = X[t, 64];
elsif PSTATE.EL == EL3 then
    VTTBR_EL2&lt;63:0> = X[t, 64];
                </p><h4 class="assembler"><span class="condition">
When FEAT_D128 is implemented
            </span><br/>MRRS &lt;Xt+1>, &lt;Xt>, VTTBR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0010</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV> == '11' then
        (X[t + 1, 64], X[t, 64]) = <ins>Split</ins>(NVMem[<ins>0x020, 128</ins><del>0x028</del>], <ins>64);</ins><del>NVMem[0x020]);</del>
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x14);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SCR_EL3.D128En == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; SCR_EL3.D128En == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x14);
    else
        (X[t + 1, 64], X[t, 64]) = <ins>Split</ins>(VTTBR_EL2<ins>,</ins><del>&lt;127:64>,</del> <ins>64);</ins><del>VTTBR_EL2&lt;63:0>);</del>
elsif PSTATE.EL == EL3 then
    (X[t + 1, 64], X[t, 64]) = <ins>Split</ins>(VTTBR_EL2<ins>,</ins><del>&lt;127:64>,</del> <ins>64);</ins><del>VTTBR_EL2&lt;63:0>);</del>
                </p><h4 class="assembler"><span class="condition">
When FEAT_D128 is implemented
            </span><br/>MSRR VTTBR_EL2, &lt;Xt+1>, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0010</td><td>0b0001</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV> == '11' then
        <del>(</del>NVMem[<del>0x028], NVMem[</del>0x020<ins>,</ins><del>])</del> <ins>128] </ins>= <del>(</del>X[t + 1, 64<ins>]:</ins><del>], </del>X[t, 64<ins>];</ins><del>]);</del>
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x14);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SCR_EL3.D128En == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; SCR_EL3.D128En == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x14);
    else
        <del>(</del>VTTBR_EL2&lt;127:<del>64>, VTTBR_EL2&lt;63:</del>0<ins>></ins><del>>)</del> = <del>(</del>X[t + 1, 64<ins>]:</ins><del>], </del>X[t, 64<ins>];</ins><del>]);</del>
elsif PSTATE.EL == EL3 then
    <del>(</del>VTTBR_EL2&lt;127:<del>64>, VTTBR_EL2&lt;63:</del>0<ins>></ins><del>>)</del> = <del>(</del>X[t + 1, 64<ins>]:</ins><del>], </del>X[t, 64<ins>];</ins><del>]);</del>
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>30</ins><del>28</del>/03/2023 <ins>19</ins><del>16</del>:<ins>07</ins><del>02</del>; <ins>997dd0cf3258cacf72aa7cf7a885f19a4758c3af</ins><del>72747e43966d6b97dcbd230a1b3f0421d1ea3d94</del></p><p class="copyconf">Copyright Â© 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>