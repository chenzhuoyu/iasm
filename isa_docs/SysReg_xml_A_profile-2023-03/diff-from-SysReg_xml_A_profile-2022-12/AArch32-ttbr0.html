<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>TTBR0</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">TTBR0, Translation Table Base Register 0</h1><p>The TTBR0 characteristics are:</p><h2>Purpose</h2><p>Holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the lower VA range in the PL1&amp;0 translation regime, and other information for this translation regime.</p><h2>Configuration</h2><p>AArch32 System register TTBR0 bits [63:0] are architecturally mapped to AArch64 System register <a href="AArch64-ttbr0_el1.html">TTBR0_EL1[63:0]</a>.</p><p>This register is present only when EL1 is capable of using AArch32. Otherwise, direct accesses to TTBR0 are <span class="arm-defined-word">UNDEFINED</span>.</p><p>TTBR0 is a 64-bit register that can also be accessed as a 32-bit value. If it is accessed as a 32-bit register, accesses read and write bits [31:0] and do not modify bits [63:32].</p><p><a href="AArch32-ttbcr.html">TTBCR</a>.EAE determines which TTBR0 format is used:</p><ul><li><a href="AArch32-ttbcr.html">TTBCR</a>.EAE == <span class="binarynumber">0b0</span>: 32-bit format is used. TTBR0[63:32] are ignored.
</li><li><a href="AArch32-ttbcr.html">TTBCR</a>.EAE == <span class="binarynumber">0b1</span>: 64-bit format is used.
</li></ul><p>When EL3 is using AArch32, write access to TTBR0(S) is disabled when the CP15SDISABLE signal is asserted HIGH.</p><p>Used in conjunction with the <a href="AArch32-ttbcr.html">TTBCR</a>. When the 64-bit TTBR0 format is used, cacheability and shareability information is held in the <a href="AArch32-ttbcr.html">TTBCR</a>, not in TTBR0.</p><h2>Attributes</h2><p>TTBR0 is a 64-bit register.</p><h2>Field descriptions</h2><h3>When TTBCR.EAE == 0:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-63_32">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="25"><a href="#fieldset_0-31_7">TTB0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6">IRGN[0]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5">NOS</a></td><td class="lr" colspan="2"><a href="#fieldset_0-4_3">RGN</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2">IMP</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">S</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">IRGN[1]</a></td></tr></tbody></table><h4 id="fieldset_0-63_32">Bits [63:32]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-31_7">TTB0, bits [31:7]</h4><div class="field"><p>Translation table base address, bits[31:x], where x is 14-(TTBCR.N). Register bits [x-1:7] are <span class="arm-defined-word">RES0</span>, with the additional requirement that if these bits are not all zero, this is a misaligned translation table base address, with effects that are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and must be one of the following:</p><ul><li>Register bits [x-1:7] are treated as if all the bits are zero. The value read back from these bits is either the value written or zero.
</li><li>The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_6">IRGN, bits [0, 6]</h4><div class="field"><p>Inner region bits. Bits [0,6] of this register together indicate the Inner Cacheability attributes for the memory associated with the translation table walks. The possible values of IRGN[1:0] are:</p><table class="valuetable"><tr><th>IRGN</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Normal memory, Inner Non-cacheable.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Normal memory, Inner Write-Back Write-Allocate Cacheable.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Normal memory, Inner Write-Through Cacheable.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Normal memory, Inner Write-Back no Write-Allocate Cacheable.</p></td></tr></table><div class="note"><span class="note-header">Note</span><p>The encoding of the IRGN bits is counter-intuitive, with register bit[6] being IRGN[0] and register bit[0] being IRGN[1]. This encoding is chosen to give a consistent encoding of memory region types and to ensure that software written for ARMv7 without the Multiprocessing Extensions can run unmodified on an implementation that includes the functionality introduced by the ARMv7 Multiprocessing Extensions.</p></div><p>The IRGN field is split as follows:</p><ul><li>IRGN[0] is TTBR0[6].
</li><li>IRGN[1] is TTBR0[0].
</li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-5_5">NOS, bit [5]</h4><div class="field"><p>Not Outer Shareable. When the value of TTBR0.S is 1, indicates whether the memory associated with a translation table walk is Inner Shareable or Outer Shareable:</p><table class="valuetable"><tr><th>NOS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Memory is Outer Shareable.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Memory is Inner Shareable.</p></td></tr></table><p>This bit is ignored when the value of TTBR0.S is 0.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-4_3">RGN, bits [4:3]</h4><div class="field"><p>Region bits. Indicates the Outer cacheability attributes for the memory associated with the translation table walks:</p><table class="valuetable"><tr><th>RGN</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Normal memory, Outer Non-cacheable.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Normal memory, Outer Write-Back Write-Allocate Cacheable.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Normal memory, Outer Write-Through Cacheable.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Normal memory, Outer Write-Back no Write-Allocate Cacheable.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-2_2">IMP, bit [2]</h4><div class="field"><p>The effect of this bit is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span>. If the translation table implementation does not include any <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> features this bit is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-1_1">S, bit [1]</h4><div class="field"><p>Shareable. Indicates whether the memory associated with the translation table walks is Shareable:</p><table class="valuetable"><tr><th>S</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Memory is Non-shareable.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Memory is Shareable. The TTBR0.NOS field indicates whether the memory is Inner Shareable or Outer Shareable.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When TTBCR.EAE == 1:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_1-63_56">RES0</a></td><td class="lr" colspan="8"><a href="#fieldset_1-55_48">ASID</a></td><td class="lr" colspan="16"><a href="#fieldset_1-47_1">BADDR</a></td></tr><tr class="firstrow"><td class="lr" colspan="31"><a href="#fieldset_1-47_1">BADDR</a></td><td class="lr" colspan="1"><a href="#fieldset_1-0_0-1">CnP</a></td></tr></tbody></table><h4 id="fieldset_1-63_56">Bits [63:56]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-55_48">ASID, bits [55:48]</h4><div class="field"><p>An ASID for the translation table base address. The <a href="AArch32-ttbcr.html">TTBCR</a>.A1 field selects either TTBR0.ASID or <a href="AArch32-ttbr1.html">TTBR1</a>.ASID.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-47_1">BADDR, bits [47:1]</h4><div class="field"><p>Translation table base address, bits[47:x], Bits [x-1:1] are <span class="arm-defined-word">RES0</span>, with the additional requirement that if bits[x-1:3] are not all zero, this is a misaligned translation table base address, with effects that are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, and must be one of the following:</p><ul><li>Register bits [x-1:3] are treated as if all the bits are zero. The value read back from these bits is either the value written or zero.
</li><li>The result of the calculation of an address for a translation table walk using this register can be corrupted in those bits that are nonzero.
</li></ul><p>x is determined from the value of <a href="AArch32-ttbcr.html">TTBCR</a>.T0SZ as follows:</p><ul><li>If <a href="AArch32-ttbcr.html">TTBCR</a>.T0SZ is 0 or 1, x = 5 - <a href="AArch32-ttbcr.html">TTBCR</a>.T0SZ.
</li><li>If <a href="AArch32-ttbcr.html">TTBCR</a>.T0SZ is greater than 1, x = 14 - <a href="AArch32-ttbcr.html">TTBCR</a>.T0SZ.
</li></ul><p>If bits[47:40] of the translation table base address are not zero, an Address size fault is generated.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-0_0-1">CnP, bit [0]<span class="condition"><br/>When FEAT_TTCNP is implemented:
                        </span></h4><div class="field"><p>Common not Private. When <a href="AArch32-ttbcr.html">TTBCR</a>.EAE ==1, this bit indicates whether each entry that is pointed to by TTBR0 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of TTBR0.CnP is 1.</p><table class="valuetable"><tr><th>CnP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The translation table entries pointed to by this instance of TTBR0, for the current ASID, are permitted to differ from corresponding entries for this instance of TTBR0 for other PEs in the Inner Shareable domain. This is not affected by:</p><ul><li>The value of TTBR0.CnP on those other PEs.
</li><li>The value of <a href="AArch32-ttbcr.html">TTBCR</a>.EAE on those other PEs.
</li><li>The value of the current ASID or, for the Non-secure instance of TTBR0, the value of the current VMID.
</li></ul></td></tr><tr><td class="bitfield">0b1</td><td><p>The translation table entries pointed to by this instance of TTBR0 are the same as the translation table entries for every other PE in the Inner Shareable domain for which the value of TTBR0.CnP is 1 for this instance of TTBR0 and all of the following apply:</p><ul><li>The translation table entries are pointed to by this instance of TTBR0.
</li><li>The value of the applicable <a href="AArch32-ttbcr.html">TTBCR</a>.EAE field is 1.
</li><li>The ASID is the same as the current ASID.
</li><li>For the Non-secure instance of TTBR0, the VMID is the same as the current VMID.
</li></ul></td></tr></table><p>When a TLB combines entries from stage 1 translation and stage 2 translation into a single entry, that entry can only be shared between different PEs if the value of the CnP bit is 1 for both stage 1 and stage 2.</p><div class="note"><span class="note-header">Note</span><p>If the value of the TTBR0.CnP bit is 1 on multiple PEs in the same Inner Shareable domain and those TTBR0s do not point to the same translation table entries when the other conditions specified for the case when the value of CnP is 1 apply, then the results of translations are <span class="arm-defined-word">CONSTRAINED UNPREDICTABLE</span>, see <span class="xref">'CONSTRAINED UNPREDICTABLE behaviors due to caching of control or data values'</span>.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-0_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="access_mechanisms"><h2>Accessing TTBR0</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0010</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T2 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T2 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TRVM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        R[t] = TTBR0_NS&lt;31:0>;
    else
        R[t] = TTBR0&lt;31:0>;
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        R[t] = TTBR0_NS&lt;31:0>;
    else
        R[t] = TTBR0&lt;31:0>;
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        R[t] = TTBR0_S&lt;31:0>;
    else
        R[t] = TTBR0_NS&lt;31:0>;
                </p><h4 class="assembler">MCR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;CRn>, &lt;CRm>{, {#}&lt;opc2>}</h4><table class="access_instructions"><tr><th>coproc</th><th>opc1</th><th>CRn</th><th>CRm</th><th>opc2</th></tr><tr><td>0b1111</td><td>0b000</td><td>0b0010</td><td>0b0000</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T2 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T2 == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x03);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TVM == '1' then
        AArch32.TakeHypTrapException(0x03);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        TTBR0_NS<ins>&lt;31:0></ins> = <del>ZeroExtend(</del>R[t<ins>];</ins><del>]);</del>
    else
        TTBR0<ins>&lt;31:0></ins> = <del>ZeroExtend(</del>R[t<ins>];</ins><del>]);</del>
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        TTBR0_NS<ins>&lt;31:0></ins> = <del>ZeroExtend(</del>R[t<ins>];</ins><del>]);</del>
    else
        TTBR0<ins>&lt;31:0></ins> = <del>ZeroExtend(</del>R[t<ins>];</ins><del>]);</del>
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' &amp;&amp; CP15SDISABLE == <ins>Signal_High</ins><del>HIGH</del> then
        UNDEFINED;
    else
        if SCR.NS == '0' then
            TTBR0_S<ins>&lt;31:0></ins> = <del>ZeroExtend(</del>R[t<ins>];</ins><del>]);</del>
        else
            TTBR0_NS<ins>&lt;31:0></ins> = <del>ZeroExtend(</del>R[t<ins>];</ins><del>]);</del>
                </p><h4 class="assembler">MRRC{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;Rt2>, &lt;CRm></h4><table class="access_instructions"><tr><th>coproc</th><th>CRm</th><th>opc1</th></tr><tr><td>0b1111</td><td>0b0010</td><td>0b0000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T2 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T2 == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TRVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TRVM == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        (R[t2], R[t]) = (TTBR0_NS&lt;63:32>, TTBR0_NS&lt;31:0>);
    else
        (R[t2], R[t]) = (TTBR0&lt;63:32>, TTBR0&lt;31:0>);
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        (R[t2], R[t]) = (TTBR0_NS&lt;63:32>, TTBR0_NS&lt;31:0>);
    else
        (R[t2], R[t]) = (TTBR0&lt;63:32>, TTBR0&lt;31:0>);
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' then
        (R[t2], R[t]) = (TTBR0_S&lt;63:32>, TTBR0_S&lt;31:0>);
    else
        (R[t2], R[t]) = (TTBR0_NS&lt;63:32>, TTBR0_NS&lt;31:0>);
                </p><h4 class="assembler">MCRR{&lt;c>}{&lt;q>} &lt;coproc>, {#}&lt;opc1>, &lt;Rt>, &lt;Rt2>, &lt;CRm></h4><table class="access_instructions"><tr><th>coproc</th><th>CRm</th><th>opc1</th></tr><tr><td>0b1111</td><td>0b0010</td><td>0b0000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HSTR_EL2.T2 == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HSTR.T2 == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif EL2Enabled() &amp;&amp; !ELUsingAArch32(EL2) &amp;&amp; HCR_EL2.TVM == '1' then
        AArch64.AArch32SystemAccessTrap(EL2, 0x04);
    elsif EL2Enabled() &amp;&amp; ELUsingAArch32(EL2) &amp;&amp; HCR.TVM == '1' then
        AArch32.TakeHypTrapException(0x04);
    elsif HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        TTBR0_NS = R[t2]:R[t];
    else
        TTBR0 = R[t2]:R[t];
elsif PSTATE.EL == EL2 then
    if HaveEL(EL3) &amp;&amp; ELUsingAArch32(EL3) then
        TTBR0_NS = R[t2]:R[t];
    else
        TTBR0 = R[t2]:R[t];
elsif PSTATE.EL == EL3 then
    if SCR.NS == '0' &amp;&amp; CP15SDISABLE == <ins>Signal_High</ins><del>HIGH</del> then
        UNDEFINED;
    else
        if SCR.NS == '0' then
            TTBR0_S = R[t2]:R[t];
        else
            TTBR0_NS = R[t2]:R[t];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>30</ins><del>28</del>/03/2023 <ins>19</ins><del>16</del>:<ins>06</ins><del>02</del>; <ins>997dd0cf3258cacf72aa7cf7a885f19a4758c3af</ins><del>72747e43966d6b97dcbd230a1b3f0421d1ea3d94</del></p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>