<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>FPCR</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">FPCR, Floating-point Control Register</h1><p>The FPCR characteristics are:</p><h2>Purpose</h2><p>Controls floating-point behavior.</p><h2>Configuration</h2><p>AArch64 System register FPCR bits [26:15] are architecturally mapped to AArch32 System register <a href="AArch32-fpscr.html">FPSCR[26:15]</a>.</p><p>AArch64 System register FPCR bits [12:8] are architecturally mapped to AArch32 System register <a href="AArch32-fpscr.html">FPSCR[12:8]</a>.</p><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the Len and Stride fields can be programmed to nonzero values, which will cause some AArch32 floating-point instruction encodings to be <span class="arm-defined-word">UNDEFINED</span>, or whether these fields are RAZ.</p><h2>Attributes</h2><p>FPCR is a 64-bit register.</p><h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-63_27">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="5"><a href="#fieldset_0-63_27">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-26_26">AHP</a></td><td class="lr" colspan="1"><a href="#fieldset_0-25_25">DN</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_24">FZ</a></td><td class="lr" colspan="2"><a href="#fieldset_0-23_22">RMode</a></td><td class="lr" colspan="2"><a href="#fieldset_0-21_20">Stride</a></td><td class="lr" colspan="1"><a href="#fieldset_0-19_19-1">FZ16</a></td><td class="lr" colspan="3"><a href="#fieldset_0-18_16">Len</a></td><td class="lr" colspan="1"><a href="#fieldset_0-15_15">IDE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-14_14">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-13_13-1">EBF</a></td><td class="lr" colspan="1"><a href="#fieldset_0-12_12">IXE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-11_11">UFE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10">OFE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9">DZE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8">IOE</a></td><td class="lr" colspan="5"><a href="#fieldset_0-7_3">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2-1">NEP</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1-1">AH</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0-1">FIZ</a></td></tr></tbody></table><h4 id="fieldset_0-63_27">Bits [63:27]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-26_26">AHP, bit [26]</h4><div class="field"><p>Alternative half-precision control bit.</p><table class="valuetable"><tr><th>AHP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>IEEE half-precision format selected.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Alternative half-precision format selected.</p></td></tr></table><p>This bit is used only for conversions between half-precision floating-point and other floating-point formats.</p><p>The data-processing instructions added as part of the <span class="xref">FEAT_FP16</span> extension always use the IEEE half-precision format, and ignore the value of this bit.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-25_25">DN, bit [25]</h4><div class="field"><p>Default NaN use for NaN propagation.</p><table class="valuetable"><tr><th>DN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>NaN operands propagate through to the output of a floating-point operation.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Any operation involving one or more NaNs returns the Default NaN.</p><p>This bit has no effect on the output of FABS, FMAX*, FMIN*, and FNEG instructions, and a default NaN is never returned as a result of these instructions.</p></td></tr></table><p>The value of this bit controls both scalar and Advanced SIMD floating-point arithmetic.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-24_24">FZ, bit [24]</h4><div class="field"><p>Flushing denormalized numbers to zero control bit.</p><table class="valuetable"><tr><th>FZ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If FPCR.AH is 0, the flushing to zero of single-precision and double-precision denormalized inputs to, and outputs of, floating-point instructions not enabled by this control, but other factors might cause the input denormalized numbers to be flushed to zero.</p><p>If FPCR.AH is 1, the flushing to zero of single-precision and double-precision denormalized outputs of floating-point instructions not enabled by this control, but other factors might cause the input denormalized numbers to be flushed to zero.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If FPCR.AH is 0, denormalized single-precision and double-precision inputs to, and outputs from, floating-point instructions are flushed to zero.</p><p>If FPCR.AH is 1, denormalized single-precision and double-precision outputs from floating-point instructions are flushed to zero.</p></td></tr></table><p>For more information, see <span class="xref">'Flushing denormalized numbers to zero'</span> and the pseudocode of the floating-point instructions.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-23_22">RMode, bits [23:22]</h4><div class="field"><p>Rounding Mode control field.</p><table class="valuetable"><tr><th>RMode</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Round to Nearest (RN) mode.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Round towards Plus Infinity (RP) mode.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Round towards Minus Infinity (RM) mode.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Round towards Zero (RZ) mode.</p></td></tr></table><p>The specified rounding mode is used by both scalar and Advanced SIMD floating-point instructions.</p><p>If FPCR.AH is 1, then the following instructions use Round to Nearest mode regardless of the value of this bit:</p><ul><li><p>The FRECPE, FRECPS, FRECPX, FRSQRTE, and FRSQRTS instructions.</p></li><li><p>The BFCVT, BFCVTN, BFCVTN2, BFCVTNT, BFMLALB, and BFMLALT instructions.</p></li></ul><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-21_20">Stride, bits [21:20]</h4><div class="field"><p>This field has no function in AArch64 state, and nonzero values are ignored during execution in AArch64 state.</p><p>This field is included only for context saving and restoration of the AArch32 <a href="AArch32-fpscr.html">FPSCR</a>.Stride field.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p><ins>When an implementation implements FPSCR.LEN,STRIDE as RAZ, access to this field is </ins><span class="access_level"><ins>RAZ/WI</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-19_19-1">FZ16, bit [19]<span class="condition"><br/>When FEAT_FP16 is implemented:
                        </span></h4><div class="field"><p>Flushing denormalized numbers to zero control bit on half-precision data-processing instructions.</p><table class="valuetable"><tr><th>FZ16</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>For some instructions, this bit disables flushing to zero of inputs and outputs that are half-precision denormalized numbers.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Flushing denormalized numbers to zero enabled.</p><p>For some instructions that do not convert a half-precision input to a higher precision output, this bit enables flushing to zero of inputs and outputs that are half-precision denormalized numbers.</p></td></tr></table><p>The value of this bit applies to both scalar and Advanced SIMD floating-point half-precision calculations.</p><p>For more information, see <span class="xref">'Flushing denormalized numbers to zero'</span> and the pseudocode of the floating-point instructions.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-19_19-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-18_16">Len, bits [18:16]</h4><div class="field"><p>This field has no function in AArch64 state, and nonzero values are ignored during execution in AArch64 state.</p><p>This field is included only for context saving and restoration of the AArch32 <a href="AArch32-fpscr.html">FPSCR</a>.Len field.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p><ins>When an implementation implements FPSCR.LEN,STRIDE as RAZ, access to this field is </ins><span class="access_level"><ins>RAZ/WI</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-15_15">IDE, bit [15]</h4><div class="field"><p>Input Denormal floating-point exception trap enable.</p><table class="valuetable"><tr><th>IDE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Untrapped exception handling selected. If the floating-point exception occurs, the <a href="AArch64-fpsr.html">FPSR</a>.IDC bit is set to 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Trapped exception handling selected. If the floating-point exception occurs, the PE does not update the <a href="AArch64-fpsr.html">FPSR</a>.IDC bit.</p></td></tr></table><p>When the PE is in Streaming SVE mode, and FEAT_SME_FA64 is not implemented or not enabled, the value of FPCR.IDE is treated as 0 for all purposes other than a direct read or write of the FPCR.</p><p>The Effective value of this bit controls both scalar and vector floating-point arithmetic.</p><p><del>If the implementation does not support this exception, this bit is RAZ/WI.</del></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p><ins>When an implementation does not implement trapping of Input Denormal floating-point exceptions, access to this field is </ins><span class="access_level"><ins>RAZ/WI</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-14_14">Bit [14]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-13_13-1">EBF, bit [13]<span class="condition"><br/>When FEAT_EBF16 is implemented:
                        </span></h4><div class="field"><p>The value of this bit controls the numeric behaviors of BFloat16 dot product calculations performed by the BFDOT, BFMMLA, BFMOPA, and BFMOPS instructions.
If FEAT_SME2 is implemented, this also controls BFVDOT instruction.</p><p>When <a href="AArch64-id_aa64isar1_el1.html">ID_AA64ISAR1_EL1</a>.BF16 and <a href="AArch64-id_aa64zfr0_el1.html">ID_AA64ZFR0_EL1</a>.BF16 are <span class="binarynumber">0b0010</span>, the PE supports the FPCR.EBF field. Otherwise, FPCR.EBF is <span class="arm-defined-word">RES0</span>.</p><table class="valuetable"><tr><th>EBF</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>These instructions use the standard BFloat16 behaviors:</p><ul><li>Ignoring the FPCR.RMode control and using the rounding mode defined for BFloat16. For more information, see <span class="xref">'Round to Odd mode'</span>.
</li><li>Flushing denormalized inputs and outputs to zero, as if the FPCR.FZ and FPCR.FIZ controls had the value '1'.
</li><li>Performing unfused multiplies and additions with intermediate rounding of all products and sums.
</li></ul></td></tr><tr><td class="bitfield">0b1</td><td><p>These instructions use the extended BFloat16 behaviors:</p><ul><li>Supporting all four IEEE 754 rounding modes selected by the FPCR.RMode control.
</li><li>Optionally, flushing denormalized inputs and outputs to zero, as governed by the FPCR.FZ and FPCR.FIZ controls.
</li><li>Performing a fused two-way sum-of-products for each pair of adjacent BFloat16 elements, without intermediate rounding of the products, but rounding the single-precision sum before addition to the accumulator.
</li><li>Generating the default NaN as intermediate sum-of-products when any multiplier input is a NaN, or any product is infinity × 0.0, or there are infinite products with differing signs.
</li><li>Generating an intermediate sum-of-products of the same infinity when there are infinite products all with the same sign.
</li></ul></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-13_13-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-12_12">IXE, bit [12]</h4><div class="field"><p>Inexact floating-point exception trap enable.</p><table class="valuetable"><tr><th>IXE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Untrapped exception handling selected. If the floating-point exception occurs, the <a href="AArch64-fpsr.html">FPSR</a>.IXC bit is set to 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Trapped exception handling selected. If the floating-point exception occurs, the PE does not update the <a href="AArch64-fpsr.html">FPSR</a>.IXC bit.</p></td></tr></table><p>When the PE is in Streaming SVE mode, and FEAT_SME_FA64 is not implemented or not enabled, the value of FPCR.IXE is treated as 0 for all purposes other than a direct read or write of the FPCR.</p><p>The Effective value of this bit controls both scalar and vector floating-point arithmetic.</p><p><del>If the implementation does not support this exception, this bit is RAZ/WI.</del></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p><ins>When an implementation does not implement trapping of Inexact floating-point exceptions, access to this field is </ins><span class="access_level"><ins>RAZ/WI</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-11_11">UFE, bit [11]</h4><div class="field"><p>Underflow floating-point exception trap enable.</p><table class="valuetable"><tr><th>UFE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Untrapped exception handling selected. If the floating-point exception occurs, the <a href="AArch64-fpsr.html">FPSR</a>.UFC bit is set to 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Trapped exception handling selected. If the floating-point exception occurs and Flush-to-zero is not enabled, the PE does not update the <a href="AArch64-fpsr.html">FPSR</a>.UFC bit.</p></td></tr></table><p>When the PE is in Streaming SVE mode, and FEAT_SME_FA64 is not implemented or not enabled, the value of FPCR.UFE is treated as 0 for all purposes other than a direct read or write of the FPCR.</p><p>The Effective value of this bit controls both scalar and vector floating-point arithmetic.</p><p><del>If the implementation does not support this exception, this bit is RAZ/WI.</del></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p><ins>When an implementation does not implement trapping of Underflow floating-point exceptions, access to this field is </ins><span class="access_level"><ins>RAZ/WI</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-10_10">OFE, bit [10]</h4><div class="field"><p>Overflow floating-point exception trap enable.</p><table class="valuetable"><tr><th>OFE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Untrapped exception handling selected. If the floating-point exception occurs, the <a href="AArch64-fpsr.html">FPSR</a>.OFC bit is set to 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Trapped exception handling selected. If the floating-point exception occurs, the PE does not update the <a href="AArch64-fpsr.html">FPSR</a>.OFC bit.</p></td></tr></table><p>When the PE is in Streaming SVE mode, and FEAT_SME_FA64 is not implemented or not enabled, the value of FPCR.OFE is treated as 0 for all purposes other than a direct read or write of the FPCR.</p><p>The Effective value of this bit controls both scalar and vector floating-point arithmetic.</p><p><del>If the implementation does not support this exception, this bit is RAZ/WI.</del></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p><ins>When an implementation does not implement trapping of Overflow floating-point exceptions, access to this field is </ins><span class="access_level"><ins>RAZ/WI</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-9_9">DZE, bit [9]</h4><div class="field"><p>Divide by Zero floating-point exception trap enable.</p><table class="valuetable"><tr><th>DZE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Untrapped exception handling selected. If the floating-point exception occurs, the <a href="AArch64-fpsr.html">FPSR</a>.DZC bit is set to 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Trapped exception handling selected. If the floating-point exception occurs, the PE does not update the <a href="AArch64-fpsr.html">FPSR</a>.DZC bit.</p></td></tr></table><p>When the PE is in Streaming SVE mode, and FEAT_SME_FA64 is not implemented or not enabled, the value of FPCR.DZE is treated as 0 for all purposes other than a direct read or write of the FPCR.</p><p>The Effective value of this bit controls both scalar and vector floating-point arithmetic.</p><p><del>If the implementation does not support this exception, this bit is RAZ/WI.</del></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p><ins>When an implementation does not implement trapping of Divide by Zero floating-point exceptions, access to this field is </ins><span class="access_level"><ins>RAZ/WI</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-8_8">IOE, bit [8]</h4><div class="field"><p>Invalid Operation floating-point exception trap enable.</p><table class="valuetable"><tr><th>IOE</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Untrapped exception handling selected. If the floating-point exception occurs, the <a href="AArch64-fpsr.html">FPSR</a>.IOC bit is set to 1.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Trapped exception handling selected. If the floating-point exception occurs, the PE does not update the <a href="AArch64-fpsr.html">FPSR</a>.IOC bit.</p></td></tr></table><p>When the PE is in Streaming SVE mode, and FEAT_SME_FA64 is not implemented or not enabled, the value of FPCR.IOE is treated as 0 for all purposes other than a direct read or write of the FPCR.</p><p>The Effective value of this bit controls both scalar and vector floating-point arithmetic.</p><p><del>If the implementation does not support this exception, this bit is RAZ/WI.</del></p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul><p><ins>When an implementation does not implement trapping of Invalid Operation floating-point exceptions, access to this field is </ins><span class="access_level"><ins>RAZ/WI</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-7_3">Bits [7:3]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-2_2-1">NEP, bit [2]<span class="condition"><br/>When FEAT_AFP is implemented:
                        </span></h4><div class="field"><p>Controls how the output elements other than the lowest element of the vector are determined for Advanced SIMD scalar instructions.</p><table class="valuetable"><tr><th>NEP</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Does not affect how the output elements other than the lowest are determined for Advanced SIMD scalar instructions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The output elements other than the lowest are taken from the following registers:</p><ul><li><p>For 3-input scalar versions of the FMLA (by element) and FMLS (by element) instructions, the &lt;Hd>, &lt;Sd>, or &lt;Dd> register.</p></li><li><p>For 3-input versions of the FMADD, FMSUB, FNMADD, and FNMSUB instructions, the &lt;Ha>, &lt;Sa>, or &lt;Da> register.</p></li><li><p>For 2-input scalar versions of the FACGE, FACGT, FCMEQ (register), FCMGE (register), and FCMGT (register) instructions, the &lt;Hm>, &lt;Sm>, or &lt;Dm> register.</p></li><li><p>For 2-input scalar versions of the FABD, FADD (scalar), FDIV (scalar), FMAX (scalar), FMAXNM (scalar), FMIN (scalar), FMINNM (scalar), FMUL (by element), FMUL (scalar), FMULX (by element), FMULX, FNMUL (scalar), FRECPS, FRSQRTS, and FSUB (scalar) instructions, the &lt;Hn>, &lt;Sn>, or &lt;Dn> register.</p></li><li><p>For 1-input scalar versions of the following instructions, the &lt;Hd>, &lt;Sd>, or &lt;Dd> register:</p><ul><li><p>The (vector) versions of the FCVTAS, FCVTAU, FCVTMS, FCVTMU, FCVTNS, FCVTNU, FCVTPS, and FCVTPU instructions.</p></li><li><p>The (vector, fixed-point) and (vector, integer) versions of the FCVTZS, FCVTZU, SCVTF, and UCVTF instructions.</p></li><li><p>The (scalar) versions of the FABS, FNEG, FRINT32X, FRINT32Z, FRINT64X, FRINT64Z, FRINTA, FRINTI, FRINTM, FRINTN, FRINTP, FRINTX, FRINTZ, and FSQRT instructions.</p></li><li><p>The (scalar, fixed-point) and (scalar, integer) versions of the SCVTF and UCVTF instructions.</p></li><li><p>The BFCVT, FCVT, FCVTXN, FRECPE, FRECPX, and FRSQRTE instructions.</p></li></ul></li></ul></td></tr></table><p>When the PE is in Streaming SVE mode, and FEAT_SME_FA64 is not implemented or not enabled, the value of FPCR.NEP is treated as 0 for all purposes other than a direct read or write of the FPCR.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-2_2-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-1_1-1">AH, bit [1]<span class="condition"><br/>When FEAT_AFP is implemented:
                        </span></h4><div class="field"><p>Alternate Handling. Controls alternate handling of floating-point numbers.</p><p>The Arm architecture supports two models for handling some of the corner cases of the floating-point behaviors, such as the nature of flushing of denormalized numbers, the detection of tininess and other exceptions and a range of other behaviors. The value of the FPCR.AH bit selects between these models.</p><p>For more information on the FPCR.AH bit, see <span class="xref">'Flushing denormalized numbers to zero'</span>, <span class="xref">'Floating-point exceptions and exception traps'</span> and the pseudocode of the floating-point instructions.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-1_1-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-0_0-1">FIZ, bit [0]<span class="condition"><br/>When FEAT_AFP is implemented:
                        </span></h4><div class="field"><p>Flush Inputs to Zero. Controls whether single-precision, double-precision and BFloat16 input operands that are denormalized numbers are flushed to zero.</p><table class="valuetable"><tr><th>FIZ</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The flushing to zero of single-precision and double-precision denormalized inputs to floating-point instructions not enabled by this control, but other factors might cause the input denormalized numbers to be flushed to zero.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Denormalized single-precision and double-precision inputs to most floating-point instructions flushed to zero.</p></td></tr></table><p>For more information, see <span class="xref">'Flushing denormalized numbers to zero'</span> and the pseudocode of the floating-point instructions.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-0_0-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="access_mechanisms"><h2>Accessing FPCR</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt>, FPCR</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b0100</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; CPTR_EL3.TFP == '1' then
        UNDEFINED;
    elsif !(EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11') &amp;&amp; CPACR_EL1.FPEN != '11' then
        if EL2Enabled() &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.SystemAccessTrap(EL2, 0x00);
        else
            AArch64.SystemAccessTrap(EL1, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' &amp;&amp; CPTR_EL2.FPEN != '11' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.E2H != '1' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif HaveEL(EL3) &amp;&amp; CPTR_EL3.TFP == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x07);
    else
        X[t, 64] = FPCR;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; CPTR_EL3.TFP == '1' then
        UNDEFINED;
    elsif CPACR_EL1.FPEN == 'x0' then
        AArch64.SystemAccessTrap(EL1, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.E2H != '1' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif HaveEL(EL3) &amp;&amp; CPTR_EL3.TFP == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x07);
    else
        X[t, 64] = FPCR;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; CPTR_EL3.TFP == '1' then
        UNDEFINED;
    elsif HCR_EL2.E2H == '0' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif HaveEL(EL3) &amp;&amp; CPTR_EL3.TFP == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x07);
    else
        X[t, 64] = FPCR;
elsif PSTATE.EL == EL3 then
    if CPTR_EL3.TFP == '1' then
        AArch64.SystemAccessTrap(EL3, 0x07);
    else
        X[t, 64] = FPCR;
                </p><h4 class="assembler">MSR FPCR, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b011</td><td>0b0100</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; CPTR_EL3.TFP == '1' then
        UNDEFINED;
    elsif !(EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11') &amp;&amp; CPACR_EL1.FPEN != '11' then
        if EL2Enabled() &amp;&amp; HCR_EL2.TGE == '1' then
            AArch64.SystemAccessTrap(EL2, 0x00);
        else
            AArch64.SystemAccessTrap(EL1, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.&lt;E2H,TGE> == '11' &amp;&amp; CPTR_EL2.FPEN != '11' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.E2H != '1' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif HaveEL(EL3) &amp;&amp; CPTR_EL3.TFP == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x07);
    else
        FPCR = X[t, 64];
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; CPTR_EL3.TFP == '1' then
        UNDEFINED;
    elsif CPACR_EL1.FPEN == 'x0' then
        AArch64.SystemAccessTrap(EL1, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.E2H != '1' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif EL2Enabled() &amp;&amp; HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif HaveEL(EL3) &amp;&amp; CPTR_EL3.TFP == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x07);
    else
        FPCR = X[t, 64];
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; CPTR_EL3.TFP == '1' then
        UNDEFINED;
    elsif HCR_EL2.E2H == '0' &amp;&amp; CPTR_EL2.TFP == '1' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif HCR_EL2.E2H == '1' &amp;&amp; CPTR_EL2.FPEN == 'x0' then
        AArch64.SystemAccessTrap(EL2, 0x07);
    elsif HaveEL(EL3) &amp;&amp; CPTR_EL3.TFP == '1' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x07);
    else
        FPCR = X[t, 64];
elsif PSTATE.EL == EL3 then
    if CPTR_EL3.TFP == '1' then
        AArch64.SystemAccessTrap(EL3, 0x07);
    else
        FPCR = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>30</ins><del>28</del>/03/2023 <ins>19</ins><del>16</del>:<ins>06</ins><del>01</del>; <ins>997dd0cf3258cacf72aa7cf7a885f19a4758c3af</ins><del>72747e43966d6b97dcbd230a1b3f0421d1ea3d94</del></p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>