<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>HDFGWTR_EL2</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">HDFGWTR_EL2, Hypervisor Debug Fine-Grained Write Trap Register</h1><p>The HDFGWTR_EL2 characteristics are:</p><h2>Purpose</h2><p>Provides controls for traps of <span class="instruction">MSR</span> and <span class="instruction">MCR</span> writes of debug, trace, PMU, and Statistical Profiling System registers.</p><h2>Configuration</h2><p>This register is present only when FEAT_FGT is implemented. Otherwise, direct accesses to HDFGWTR_EL2 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2><p>HDFGWTR_EL2 is a 64-bit register.</p><h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-63_63">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-62_62-1">nPMSNEVFR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-61_61-1">nBRBDATA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-60_60-1">nBRBCTL</a></td><td class="lr" colspan="2"><a href="#fieldset_0-59_58">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-57_57-1">PMUSERENR_EL0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-56_56-1">TRBTRG_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-55_55-1">TRBSR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-54_54-1">TRBPTR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-53_53-1">TRBMAR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-52_52-1">TRBLIMITR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-51_51">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-50_50-1">TRBBASER_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-49_49-1">TRFCR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-48_48-1">TRCVICTLR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-47_47">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-46_46-1">TRCSSCSRn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-45_45-1">TRCSEQSTR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-44_44-1">TRCPRGCTLR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-43_43">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-42_42-1">TRCOSLAR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-41_41-1">TRCIMSPECn</a></td><td class="lr" colspan="3"><a href="#fieldset_0-40_38">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-37_37-1">TRCCNTVRn</a></td><td class="lr" colspan="1"><a href="#fieldset_0-36_36-1">TRCCLAIM</a></td><td class="lr" colspan="1"><a href="#fieldset_0-35_35-1">TRCAUXCTLR</a></td><td class="lr" colspan="1"><a href="#fieldset_0-34_34">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-33_33-1">TRC</a></td><td class="lr" colspan="1"><a href="#fieldset_0-32_32-1">PMSLATFR_EL1</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-31_31-1">PMSIRR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-30_30">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29-1">PMSICR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-28_28-1">PMSFCR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-27_27-1">PMSEVFR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-26_26-1">PMSCR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-25_25-1">PMBSR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-24_24-1">PMBPTR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-23_23-1">PMBLIMITR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-22_22">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-21_21-1">PMCR_EL0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-20_20-1">PMSWINC_EL0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-19_19-1">PMSELR_EL0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-18_18-1">PMOVS</a></td><td class="lr" colspan="1"><a href="#fieldset_0-17_17-1">PMINTEN</a></td><td class="lr" colspan="1"><a href="#fieldset_0-16_16-1">PMCNTEN</a></td><td class="lr" colspan="1"><a href="#fieldset_0-15_15-1">PMCCNTR_EL0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-14_14-1">PMCCFILTR_EL0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-13_13-1">PMEVTYPERn_EL0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-12_12-1">PMEVCNTRn_EL0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-11_11-1">OSDLR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10">OSECCR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-8_8">OSLAR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7">DBGPRCR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-6_6">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-5_5">DBGCLAIM</a></td><td class="lr" colspan="1"><a href="#fieldset_0-4_4">MDSCR_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-3_3">DBGWVRn_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-2_2">DBGWCRn_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-1_1">DBGBVRn_EL1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">DBGBCRn_EL1</a></td></tr></tbody></table><h4 id="fieldset_0-63_63">Bit [63]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-62_62-1">nPMSNEVFR_EL1, bit [62]<span class="condition"><br/>When FEAT_SPEv1p2 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>nPMSNEVFR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmsnevfr_el1.html">PMSNEVFR_EL1</a> are not trapped by this mechanism.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-62_62-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-61_61-1">nBRBDATA, bit [61]<span class="condition"><br/>When FEAT_BRBE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of multiple System registers. Enables a trap on <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the following AArch64 System registers to EL2:</p><ul><li><a href="AArch64-brbinfinj_el1.html">BRBINFINJ_EL1</a>.
</li><li><a href="AArch64-brbsrcinj_el1.html">BRBSRCINJ_EL1</a>.
</li><li><a href="AArch64-brbtgtinj_el1.html">BRBTGTINJ_EL1</a>.
</li><li><a href="AArch64-brbts_el1.html">BRBTS_EL1</a>.
</li></ul><table class="valuetable"><tr><th>nBRBDATA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the System registers listed above are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><span class="instruction">MSR</span> writes of the System registers listed above are not trapped by this mechanism.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-61_61-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-60_60-1">nBRBCTL, bit [60]<span class="condition"><br/>When FEAT_BRBE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of multiple System registers. Enables a trap on <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the following AArch64 System registers to EL2:</p><ul><li><a href="AArch64-brbcr_el1.html">BRBCR_EL1</a>.
</li><li><a href="AArch64-brbfcr_el1.html">BRBFCR_EL1</a>.
</li></ul><table class="valuetable"><tr><th>nBRBCTL</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the System registers listed above are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr><tr><td class="bitfield">0b1</td><td><p><span class="instruction">MSR</span> writes of the System registers listed above are not trapped by this mechanism.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-60_60-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-59_58">Bits [59:58]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-57_57-1">PMUSERENR_EL0, bit [57]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMUSERENR_EL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmuserenr_el0.html">PMUSERENR_EL0</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-57_57-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-56_56-1">TRBTRG_EL1, bit [56]<span class="condition"><br/>When FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-trbtrg_el1.html">TRBTRG_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRBTRG_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trbtrg_el1.html">TRBTRG_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trbtrg_el1.html">TRBTRG_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-56_56-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-55_55-1">TRBSR_EL1, bit [55]<span class="condition"><br/>When FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-trbsr_el1.html">TRBSR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRBSR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trbsr_el1.html">TRBSR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trbsr_el1.html">TRBSR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-55_55-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-54_54-1">TRBPTR_EL1, bit [54]<span class="condition"><br/>When FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-trbptr_el1.html">TRBPTR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRBPTR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trbptr_el1.html">TRBPTR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trbptr_el1.html">TRBPTR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-54_54-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-53_53-1">TRBMAR_EL1, bit [53]<span class="condition"><br/>When FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-trbmar_el1.html">TRBMAR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRBMAR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trbmar_el1.html">TRBMAR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trbmar_el1.html">TRBMAR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-53_53-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-52_52-1">TRBLIMITR_EL1, bit [52]<span class="condition"><br/>When FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-trblimitr_el1.html">TRBLIMITR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRBLIMITR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trblimitr_el1.html">TRBLIMITR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trblimitr_el1.html">TRBLIMITR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-52_52-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-51_51">Bit [51]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-50_50-1">TRBBASER_EL1, bit [50]<span class="condition"><br/>When FEAT_TRBE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-trbbaser_el1.html">TRBBASER_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRBBASER_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trbbaser_el1.html">TRBBASER_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trbbaser_el1.html">TRBBASER_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-50_50-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-49_49-1">TRFCR_EL1, bit [49]<span class="condition"><br/>When FEAT_TRF is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRFCR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trfcr_el1.html">TRFCR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-49_49-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-48_48-1">TRCVICTLR, bit [48]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of <a href="AArch64-trcvictlr.html">TRCVICTLR</a> at EL1 using AArch64 to EL2.</p><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of ETM TRCVICTLR at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCVICTLR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trcvictlr.html">TRCVICTLR</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trcvictlr.html">TRCVICTLR</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-48_48-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-47_47">Bit [47]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-46_46-1">TRCSSCSRn, bit [46]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented, TRCSSCSR&lt;n> are implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of <a href="AArch64-trcsscsrn.html">TRCSSCSR&lt;n></a> at EL1 using AArch64 to EL2.</p><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of ETM TRCSSCSR&lt;n> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCSSCSRn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trcsscsrn.html">TRCSSCSR&lt;n></a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trcsscsrn.html">TRCSSCSR&lt;n></a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>If Single-shot Comparator n is not implementented, a write of <a href="AArch64-trcsscsrn.html">TRCSSCSR&lt;n></a> is <span class="arm-defined-word">UNDEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-46_46-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-45_45-1">TRCSEQSTR, bit [45]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented, TRCSEQSTR is implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of <a href="AArch64-trcseqstr.html">TRCSEQSTR</a> at EL1 using AArch64 to EL2.</p><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of ETM TRCSEQSTR at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCSEQSTR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trcseqstr.html">TRCSEQSTR</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trcseqstr.html">TRCSEQSTR</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-45_45-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-44_44-1">TRCPRGCTLR, bit [44]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of <a href="AArch64-trcprgctlr.html">TRCPRGCTLR</a> at EL1 using AArch64 to EL2.</p><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of ETM TRCPRGCTLR at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCPRGCTLR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trcprgctlr.html">TRCPRGCTLR</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trcprgctlr.html">TRCPRGCTLR</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-44_44-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-43_43">Bit [43]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-42_42-1">TRCOSLAR, bit [42]<span class="condition"><br/>When System register access to the trace unit registers is implemented and FEAT_ETMv4 is implemented:
                        </span></h4><div class="field"><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of ETM TRCOSLAR at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCOSLAR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of TRCOSLAR are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of TRCOSLAR at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-42_42-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-41_41-1">TRCIMSPECn, bit [41]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of <a href="AArch64-trcimspecn.html">TRCIMSPEC&lt;n></a> at EL1 using AArch64 to EL2.</p><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of ETM TRCIMSPEC&lt;n> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCIMSPECn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trcimspecn.html">TRCIMSPEC&lt;n></a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trcimspecn.html">TRCIMSPEC&lt;n></a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>TRCIMSPEC&lt;1-7> are optional. If <a href="AArch64-trcimspecn.html">TRCIMSPEC&lt;n></a> is not implemented, a write of <a href="AArch64-trcimspecn.html">TRCIMSPEC&lt;n></a> is <span class="arm-defined-word">UNDEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-41_41-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-40_38">Bits [40:38]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-37_37-1">TRCCNTVRn, bit [37]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented, TRCCNTVR&lt;n> are implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of <a href="AArch64-trccntvrn.html">TRCCNTVR&lt;n></a> at EL1 using AArch64 to EL2.</p><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of ETM TRCCNTVR&lt;n> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCCNTVRn</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trccntvrn.html">TRCCNTVR&lt;n></a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trccntvrn.html">TRCCNTVR&lt;n></a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>If Counter n is not implemented, a write of <a href="AArch64-trccntvrn.html">TRCCNTVR&lt;n></a> is <span class="arm-defined-word">UNDEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-37_37-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-36_36-1">TRCCLAIM, bit [36]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of <a href="AArch64-trcclaimclr.html">TRCCLAIMCLR</a> and <a href="AArch64-trcclaimset.html">TRCCLAIMSET</a> at EL1 using AArch64 to EL2.</p><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of ETM TRCCLAIMCLR and ETM TRCCLAIMSET at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCCLAIM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of the System registers listed above are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the System registers listed above are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-36_36-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-35_35-1">TRCAUXCTLR, bit [35]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of <a href="AArch64-trcauxctlr.html">TRCAUXCTLR</a> at EL1 using AArch64 to EL2.</p><p>In an Armv8 implemenation, trap <span class="instruction">MSR</span> writes of ETM TRCAUXCTLR at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>TRCAUXCTLR</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-trcauxctlr.html">TRCAUXCTLR</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-trcauxctlr.html">TRCAUXCTLR</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-35_35-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-34_34">Bit [34]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-33_33-1">TRC, bit [33]<span class="condition"><br/>When FEAT_ETE is implemented or (FEAT_ETMv4 is implemented and System register access to the trace unit registers is implemented):
                        </span></h4><div class="field"><p>In an Armv9 implementation, trap <span class="instruction">MSR</span> writes of the following registers at EL1 using AArch64 to EL2:</p><ul><li><a href="AArch64-trcacatrn.html">TRCACATR&lt;n></a>.
</li><li><a href="AArch64-trcacvrn.html">TRCACVR&lt;n></a>.
</li><li><a href="AArch64-trcbbctlr.html">TRCBBCTLR</a>.
</li><li><a href="AArch64-trcccctlr.html">TRCCCCTLR</a>.
</li><li><a href="AArch64-trccidcctlr0.html">TRCCIDCCTLR0</a>.
</li><li><a href="AArch64-trccidcctlr1.html">TRCCIDCCTLR1</a>.
</li><li><a href="AArch64-trccidcvrn.html">TRCCIDCVR&lt;n></a>.
</li><li><a href="AArch64-trccntctlrn.html">TRCCNTCTLR&lt;n></a>.
</li><li><a href="AArch64-trccntrldvrn.html">TRCCNTRLDVR&lt;n></a>.
</li><li><a href="AArch64-trcconfigr.html">TRCCONFIGR</a>.
</li><li><a href="AArch64-trceventctl0r.html">TRCEVENTCTL0R</a>.
</li><li><a href="AArch64-trceventctl1r.html">TRCEVENTCTL1R</a>.
</li><li><a href="AArch64-trcextinselrn.html">TRCEXTINSELR&lt;n></a>.
</li><li><a href="AArch64-trcqctlr.html">TRCQCTLR</a>.
</li><li><a href="AArch64-trcrsctlrn.html">TRCRSCTLR&lt;n></a>.
</li><li><a href="AArch64-trcrsr.html">TRCRSR</a>.
</li><li><a href="AArch64-trcseqevrn.html">TRCSEQEVR&lt;n></a>.
</li><li><a href="AArch64-trcseqrstevr.html">TRCSEQRSTEVR</a>.
</li><li><a href="AArch64-trcssccrn.html">TRCSSCCR&lt;n></a>.
</li><li><a href="AArch64-trcsspcicrn.html">TRCSSPCICR&lt;n></a>.
</li><li><a href="AArch64-trcstallctlr.html">TRCSTALLCTLR</a>.
</li><li><a href="AArch64-trcsyncpr.html">TRCSYNCPR</a>.
</li><li><a href="AArch64-trctraceidr.html">TRCTRACEIDR</a>.
</li><li><a href="AArch64-trctsctlr.html">TRCTSCTLR</a>.
</li><li><a href="AArch64-trcviiectlr.html">TRCVIIECTLR</a>.
</li><li><a href="AArch64-trcvipcssctlr.html">TRCVIPCSSCTLR</a>.
</li><li><a href="AArch64-trcvissctlr.html">TRCVISSCTLR</a>.
</li><li><a href="AArch64-trcvmidcctlr0.html">TRCVMIDCCTLR0</a>.
</li><li><a href="AArch64-trcvmidcctlr1.html">TRCVMIDCCTLR1</a>.
</li><li><a href="AArch64-trcvmidcvrn.html">TRCVMIDCVR&lt;n></a>.
</li></ul><p>In an Armv8 implementation, trap <span class="instruction">MSR</span> writes of the following registers at EL1 using AArch64 to EL2:</p><ul><li>ETM TRCACATR&lt;n>.
</li><li>ETM TRCACVR&lt;n>.
</li><li>ETM TRCBBCTLR.
</li><li>ETM TRCCCCTLR.
</li><li>ETM TRCCIDCCTLR0.
</li><li>ETM TRCCIDCCTLR1.
</li><li>ETM TRCCIDCVR&lt;n>.
</li><li>ETM TRCCNTCTLR&lt;n>.
</li><li>ETM TRCCNTRLDVR&lt;n>.
</li><li>ETM TRCCONFIGR.
</li><li>ETM TRCEVENTCTL0R.
</li><li>ETM TRCEVENTCTL1R.
</li><li>ETM TRCEXTINSELR.
</li><li>ETM TRCQCTLR.
</li><li>ETM TRCRSCTLR&lt;n>.
</li><li>ETM TRCSEQEVR&lt;n>.
</li><li>ETM TRCSEQRSTEVR.
</li><li>ETM TRCSSCCR&lt;n>.
</li><li>ETM TRCSSPCICR&lt;n>.
</li><li>ETM TRCSTALLCTLR.
</li><li>ETM TRCSYNCPR.
</li><li>ETM TRCTRACEIDR.
</li><li>ETM TRCTSCTLR.
</li><li>ETM TRCVIIECTLR.
</li><li>ETM TRCVIPCSSCTLR.
</li><li>ETM TRCVISSCTLR.
</li><li>ETM TRCVMIDCCTLR0.
</li><li>ETM TRCVMIDCCTLR1.
</li><li>ETM TRCVMIDCVR&lt;n>.
</li></ul><table class="valuetable"><tr><th>TRC</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of the System registers listed above are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the System registers listed above are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>A write of an unimplemented register is <span class="arm-defined-word">UNDEFINED</span>.</p><p><a href="AArch64-trcextinselrn.html">TRCEXTINSELR&lt;n></a> and <a href="AArch64-trcrsr.html">TRCRSR</a> are <del>only </del>implemented<ins> only</ins> if FEAT_ETE is implemented.</p><p>TRCEXTINSELR is <del>only </del>implemented<ins> only</ins> if FEAT_ETE is not implemented and FEAT_ETMv4 is implemented.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-33_33-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-32_32-1">PMSLATFR_EL1, bit [32]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmslatfr_el1.html">PMSLATFR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMSLATFR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmslatfr_el1.html">PMSLATFR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmslatfr_el1.html">PMSLATFR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-32_32-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-31_31-1">PMSIRR_EL1, bit [31]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmsirr_el1.html">PMSIRR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMSIRR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmsirr_el1.html">PMSIRR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmsirr_el1.html">PMSIRR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-31_31-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-30_30">Bit [30]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-29_29-1">PMSICR_EL1, bit [29]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmsicr_el1.html">PMSICR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMSICR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmsicr_el1.html">PMSICR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmsicr_el1.html">PMSICR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-29_29-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-28_28-1">PMSFCR_EL1, bit [28]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMSFCR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmsfcr_el1.html">PMSFCR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-28_28-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-27_27-1">PMSEVFR_EL1, bit [27]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmsevfr_el1.html">PMSEVFR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMSEVFR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmsevfr_el1.html">PMSEVFR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmsevfr_el1.html">PMSEVFR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-27_27-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-26_26-1">PMSCR_EL1, bit [26]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMSCR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmscr_el1.html">PMSCR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-26_26-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-25_25-1">PMBSR_EL1, bit [25]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMBSR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmbsr_el1.html">PMBSR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-25_25-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-24_24-1">PMBPTR_EL1, bit [24]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmbptr_el1.html">PMBPTR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMBPTR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmbptr_el1.html">PMBPTR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmbptr_el1.html">PMBPTR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-24_24-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-23_23-1">PMBLIMITR_EL1, bit [23]<span class="condition"><br/>When FEAT_SPE is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMBLIMITR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-pmblimitr_el1.html">PMBLIMITR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-23_23-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-22_22">Bit [22]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-21_21-1">PMCR_EL0, bit [21]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmcr_el0.html">PMCR_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> writes of <a href="AArch32-pmcr.html">PMCR</a> at EL0 using AArch32 when EL1 is using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMCR_EL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmcr_el0.html">PMCR_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> writes of <a href="AArch32-pmcr.html">PMCR</a> at EL0 using AArch32 are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes of <a href="AArch64-pmcr_el0.html">PMCR_EL0</a> at EL1 and EL0 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> writes of <a href="AArch32-pmcr.html">PMCR</a> at EL0 using AArch32 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-21_21-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-20_20-1">PMSWINC_EL0, bit [20]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmswinc_el0.html">PMSWINC_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> writes of <a href="AArch32-pmswinc.html">PMSWINC</a> at EL0 using AArch32 when EL1 is using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMSWINC_EL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmswinc_el0.html">PMSWINC_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> writes of <a href="AArch32-pmswinc.html">PMSWINC</a> at EL0 using AArch32 are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes of <a href="AArch64-pmswinc_el0.html">PMSWINC_EL0</a> at EL1 and EL0 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> writes of <a href="AArch32-pmswinc.html">PMSWINC</a> at EL0 using AArch32 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-20_20-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-19_19-1">PMSELR_EL0, bit [19]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> writes of <a href="AArch32-pmselr.html">PMSELR</a> at EL0 using AArch32 when EL1 is using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMSELR_EL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> writes of <a href="AArch32-pmselr.html">PMSELR</a> at EL0 using AArch32 are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes of <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a> at EL1 and EL0 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> writes of <a href="AArch32-pmselr.html">PMSELR</a> at EL0 using AArch32 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-19_19-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-18_18-1">PMOVS, bit [18]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes and <span class="instruction">MCR</span> writes of multiple System registers.</p><p>Enables a trap to EL2 the following operations:</p><ul><li>At EL1 and EL0 using AArch64: <span class="instruction">MSR</span> writes of <a href="AArch64-pmovsclr_el0.html">PMOVSCLR_EL0</a> and <a href="AArch64-pmovsset_el0.html">PMOVSSET_EL0</a>.
</li><li>At EL0 using AArch32 when EL1 is using AArch64: <span class="instruction">MCR</span> writes of <a href="AArch32-pmovsr.html">PMOVSR</a> and <a href="AArch32-pmovsset.html">PMOVSSET</a>.
</li></ul><table class="valuetable"><tr><th>PMOVS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The operations listed above are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes at EL1 and EL0 using AArch64 of <a href="AArch64-pmovsclr_el0.html">PMOVSCLR_EL0</a> and <a href="AArch64-pmovsset_el0.html">PMOVSSET_EL0</a> are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> writes at EL0 using AArch32 of <a href="AArch32-pmovsr.html">PMOVSR</a> and <a href="AArch32-pmovsset.html">PMOVSSET</a> are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-18_18-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-17_17-1">PMINTEN, bit [17]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of multiple System registers. Enables a trap on <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the following AArch64 System registers to EL2:</p><ul><li><a href="AArch64-pmintenclr_el1.html">PMINTENCLR_EL1</a>.
</li><li><a href="AArch64-pmintenset_el1.html">PMINTENSET_EL1</a>.
</li></ul><table class="valuetable"><tr><th>PMINTEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of the System registers listed above are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the System registers listed above are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-17_17-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-16_16-1">PMCNTEN, bit [16]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes and <span class="instruction">MCR</span> writes of multiple System registers.</p><p>Enables a trap to EL2 the following operations:</p><ul><li>At EL1 and EL0 using AArch64: <span class="instruction">MSR</span> writes of <a href="AArch64-pmcntenclr_el0.html">PMCNTENCLR_EL0</a> and <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a>.
</li><li>At EL0 using AArch32 when EL1 is using AArch64: <span class="instruction">MCR</span> writes of <a href="AArch32-pmcntenclr.html">PMCNTENCLR</a> and <a href="AArch32-pmcntenset.html">PMCNTENSET</a>.
</li></ul><table class="valuetable"><tr><th>PMCNTEN</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The operations listed above are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes at EL1 and EL0 using AArch64 of <a href="AArch64-pmcntenclr_el0.html">PMCNTENCLR_EL0</a> and <a href="AArch64-pmcntenset_el0.html">PMCNTENSET_EL0</a> are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> writes at EL0 using AArch32 of <a href="AArch32-pmcntenclr.html">PMCNTENCLR</a> and <a href="AArch32-pmcntenset.html">PMCNTENSET</a> are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-16_16-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-15_15-1">PMCCNTR_EL0, bit [15]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> and <span class="instruction">MCRR</span> writes of <a href="AArch32-pmccntr.html">PMCCNTR</a> at EL0 using AArch32 when EL1 is using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMCCNTR_EL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> and <span class="instruction">MCRR</span> writes of <a href="AArch32-pmccntr.html">PMCCNTR</a> at EL0 using AArch32 are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64 and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes of <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> at EL1 and EL0 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> and <span class="instruction">MCRR</span> writes of <a href="AArch32-pmccntr.html">PMCCNTR</a> at EL0 using AArch32 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span> (for <span class="instruction">MCR</span>) or <span class="hexnumber">0x04</span> (for <span class="instruction">MCRR</span>).
</li></ul></td></tr></table><p><a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> can also be indirectly set to zero by a write of 1 to <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.C or <a href="AArch64-pmzr_el0.html">PMZR_EL0</a>.C in AArch64 state, or a write of 1 to <a href="AArch32-pmcr.html">PMCR</a>.C in AArch32 state. Setting this field to 1 has no effect on indirect writes to <a href="AArch64-pmccntr_el0.html">PMCCNTR_EL0</a> using <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>, <a href="AArch64-pmzr_el0.html">PMZR_EL0</a>, or <a href="AArch32-pmcr.html">PMCR</a>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul><li>When EL3 is not implemented,
            this field resets to
            <span class="binarynumber">0</span>.
</li><li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></li></ul></div><h4 id="fieldset_0-15_15-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-14_14-1">PMCCFILTR_EL0, bit [14]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-pmccfiltr_el0.html">PMCCFILTR_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> writes of <a href="AArch32-pmccfiltr.html">PMCCFILTR</a> at EL0 using AArch32 when EL1 is using AArch64 to EL2.</p><table class="valuetable"><tr><th>PMCCFILTR_EL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-pmccfiltr_el0.html">PMCCFILTR_EL0</a> at EL1 and EL0 using AArch64 and <span class="instruction">MCR</span> writes of <a href="AArch32-pmccfiltr.html">PMCCFILTR</a> at EL0 using AArch32 are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes of <a href="AArch64-pmccfiltr_el0.html">PMCCFILTR_EL0</a> at EL1 and EL0 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> writes of <a href="AArch32-pmccfiltr.html">PMCCFILTR</a> at EL0 using AArch32 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></td></tr></table><p><a href="AArch64-pmccfiltr_el0.html">PMCCFILTR_EL0</a> can also be accessed in AArch64 state using <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a> when <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>.SEL == 31, and <a href="AArch32-pmccfiltr.html">PMCCFILTR</a> can also be accessed in AArch32 state using <a href="AArch32-pmxevtyper.html">PMXEVTYPER</a> when <a href="AArch32-pmselr.html">PMSELR</a>.SEL == 31.</p><p>Setting this field to 1 has no effect on accesses to <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a> and <a href="AArch32-pmxevtyper.html">PMXEVTYPER</a>, regardless of the value of <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>.SEL or <a href="AArch32-pmselr.html">PMSELR</a>.SEL.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-14_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-13_13-1">PMEVTYPERn_EL0, bit [13]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes and <span class="instruction">MCR</span> writes of multiple System registers.</p><p>Enables a trap to EL2 the following operations:</p><ul><li>At EL1 and EL0 using AArch64: <span class="instruction">MSR</span> writes of <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n>_EL0</a> and <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a>.
</li><li>At EL0 using AArch32 when EL1 is using AArch64: <span class="instruction">MCR</span> writes of <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n></a> and <a href="AArch32-pmxevtyper.html">PMXEVTYPER</a>.
</li></ul><table class="valuetable"><tr><th>PMEVTYPERn_EL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The operations listed above are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes at EL1 and EL0 using AArch64 of <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n>_EL0</a> and <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a> are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> writes at EL0 using AArch32 of <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n></a> and <a href="AArch32-pmxevtyper.html">PMXEVTYPER</a> are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></td></tr></table><p>Regardless of the value of this field, for each value n:</p><ul><li>If event counter n is not implemented, the following accesses are <span class="arm-defined-word">UNDEFINED</span>:<ul><li>In AArch64 state, a write of <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n>_EL0</a>, or, if n is not 31, a write of <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a> when <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>.SEL == n.
</li><li>In AArch32 state, a write of <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n></a>, or, if n is not 31, a write of <a href="AArch32-pmxevtyper.html">PMXEVTYPER</a> when <a href="AArch32-pmselr.html">PMSELR</a>.SEL == n.
</li></ul></li><li>If event counter n is implemented, n is greater-than-or-equal-to <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN, and EL2 is implemented and enabled in the current Security state, the following generate a Trap exception to EL2 from EL0 or EL1:<ul><li>In AArch64 state, a write of <a href="AArch64-pmevtypern_el0.html">PMEVTYPER&lt;n>_EL0</a>, or a write of <a href="AArch64-pmxevtyper_el0.html">PMXEVTYPER_EL0</a> when <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>.SEL == n, reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li>In AArch32 state, a write of <a href="AArch32-pmevtypern.html">PMEVTYPER&lt;n></a>, or a write of <a href="AArch32-pmxevtyper.html">PMXEVTYPER</a> when <a href="AArch32-pmselr.html">PMSELR</a>.SEL == n, reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></li></ul><p>See also HDFGWTR_EL2.PMCCFILTR_EL0.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-13_13-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-12_12-1">PMEVCNTRn_EL0, bit [12]<span class="condition"><br/>When FEAT_PMUv3 is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes and <span class="instruction">MCR</span> writes of multiple System registers.</p><p>Enables a trap to EL2 the following operations:</p><ul><li>At EL1 and EL0 using AArch64: <span class="instruction">MSR</span> writes of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a> and <a href="AArch64-pmxevcntr_el0.html">PMXEVCNTR_EL0</a>.
</li><li>At EL0 using AArch32 when EL1 is using AArch64: <span class="instruction">MCR</span> writes of <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a> and <a href="AArch32-pmxevcntr.html">PMXEVCNTR</a>.
</li></ul><table class="valuetable"><tr><th>PMEVCNTRn_EL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The specified operations are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, <a href="AArch64-hcr_el2.html">HCR_EL2</a>.{E2H, TGE} != {1, 1}, EL1 is using AArch64 and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then, unless the write generates a higher priority exception:</p><ul><li><span class="instruction">MSR</span> writes at EL1 and EL0 using AArch64 of the specified operations are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li><span class="instruction">MCR</span> writes at EL0 using AArch32 of the specified operations are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></td></tr></table><p>Regardless of the value of this field, for each value n:</p><ul><li>If event counter n is not implemented, the following accesses are <span class="arm-defined-word">UNDEFINED</span>:<ul><li>In AArch64 state, a write of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a>, or a write of <a href="AArch64-pmxevcntr_el0.html">PMXEVCNTR_EL0</a> when <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>.SEL is n.
</li><li>In AArch32 state, a write of <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a> , or a write of <a href="AArch32-pmxevcntr.html">PMXEVCNTR</a> when <a href="AArch32-pmselr.html">PMSELR</a>.SEL is n.
</li></ul></li><li>If event counter n is implemented, n is greater than or equal to <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN, and EL2 is implemented and enabled in the current Security state, the following generate a Trap exception to EL2 from EL0 or EL1:<ul><li>In AArch64 state, a write of <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a>, or a write of <a href="AArch64-pmxevcntr_el0.html">PMXEVCNTR_EL0</a> when <a href="AArch64-pmselr_el0.html">PMSELR_EL0</a>.SEL is n, reported with EC syndrome value <span class="hexnumber">0x18</span>.
</li><li>In AArch32 state, a write of <a href="AArch32-pmevcntrn.html">PMEVCNTR&lt;n></a>, or a write of <a href="AArch32-pmxevcntr.html">PMXEVCNTR</a> when <a href="AArch32-pmselr.html">PMSELR</a>.SEL is n, reported with EC syndrome value <span class="hexnumber">0x03</span>.
</li></ul></li></ul><p>For values of n less than <a href="AArch64-mdcr_el2.html">MDCR_EL2</a>.HPMN, <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a> can also be indirectly set to zero by a write of 1 to <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>.P or <a href="AArch64-pmzr_el0.html">PMZR_EL0</a>.P&lt;n> in AArch64 state, or a write of 1 to <a href="AArch32-pmcr.html">PMCR</a>.P in AArch32 state. Setting this field to 1 has no effect on indirect writes to <a href="AArch64-pmevcntrn_el0.html">PMEVCNTR&lt;n>_EL0</a> using <a href="AArch64-pmcr_el0.html">PMCR_EL0</a>, <a href="AArch64-pmzr_el0.html">PMZR_EL0</a>, or <a href="AArch32-pmcr.html">PMCR</a>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset:<ul><li>When EL3 is not implemented,
            this field resets to
            <span class="binarynumber">0</span>.
</li><li>Otherwise,
            this field resets to
            an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></li></ul></div><h4 id="fieldset_0-12_12-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-11_11-1">OSDLR_EL1, bit [11]<span class="condition"><br/>When FEAT_DoubleLock is implemented:
                        </span></h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>OSDLR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-osdlr_el1.html">OSDLR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-11_11-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-10_10">OSECCR_EL1, bit [10]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-oseccr_el1.html">OSECCR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>OSECCR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-oseccr_el1.html">OSECCR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-oseccr_el1.html">OSECCR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-9_9">Bit [9]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-8_8">OSLAR_EL1, bit [8]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-oslar_el1.html">OSLAR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>OSLAR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-oslar_el1.html">OSLAR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-oslar_el1.html">OSLAR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-7_7">DBGPRCR_EL1, bit [7]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>DBGPRCR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-dbgprcr_el1.html">DBGPRCR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-6_6">Bit [6]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-5_5">DBGCLAIM, bit [5]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of multiple System registers. Enables a trap on <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the following AArch64 System registers to EL2:</p><ul><li><a href="AArch64-dbgclaimclr_el1.html">DBGCLAIMCLR_EL1</a>.
</li><li><a href="AArch64-dbgclaimset_el1.html">DBGCLAIMSET_EL1</a>.
</li></ul><table class="valuetable"><tr><th>DBGCLAIM</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of the System registers listed above are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes at EL1 using AArch64 of any of the System registers listed above are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-4_4">MDSCR_EL1, bit [4]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>MDSCR_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-mdscr_el1.html">MDSCR_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-3_3">DBGWVRn_EL1, bit [3]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-dbgwvrn_el1.html">DBGWVR&lt;n>_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>DBGWVRn_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-dbgwvrn_el1.html">DBGWVR&lt;n>_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-dbgwvrn_el1.html">DBGWVR&lt;n>_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>If watchpoint n is not implemented, a write of <a href="AArch64-dbgwvrn_el1.html">DBGWVR&lt;n>_EL1</a> is <span class="arm-defined-word">UNDEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-2_2">DBGWCRn_EL1, bit [2]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-dbgwcrn_el1.html">DBGWCR&lt;n>_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>DBGWCRn_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-dbgwcrn_el1.html">DBGWCR&lt;n>_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-dbgwcrn_el1.html">DBGWCR&lt;n>_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>If watchpoint n is not implemented, a write of <a href="AArch64-dbgwcrn_el1.html">DBGWCR&lt;n>_EL1</a> is <span class="arm-defined-word">UNDEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-1_1">DBGBVRn_EL1, bit [1]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-dbgbvrn_el1.html">DBGBVR&lt;n>_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>DBGBVRn_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-dbgbvrn_el1.html">DBGBVR&lt;n>_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-dbgbvrn_el1.html">DBGBVR&lt;n>_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>If breakpoint n is not implemented, a write of <a href="AArch64-dbgbvrn_el1.html">DBGBVR&lt;n>_EL1</a> is <span class="arm-defined-word">UNDEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><h4 id="fieldset_0-0_0">DBGBCRn_EL1, bit [0]</h4><div class="field"><p>Trap <span class="instruction">MSR</span> writes of <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a> at EL1 using AArch64 to EL2.</p><table class="valuetable"><tr><th>DBGBCRn_EL1</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p><span class="instruction">MSR</span> writes of <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a> are not trapped by this mechanism.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>If EL2 is implemented and enabled in the current Security state, and either EL3 is not implemented or <a href="AArch64-scr_el3.html">SCR_EL3</a>.FGTEn == 1, then <span class="instruction">MSR</span> writes of <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a> at EL1 using AArch64 are trapped to EL2 and reported with EC syndrome value <span class="hexnumber">0x18</span>, unless the write generates a higher priority exception.</p></td></tr></table><p>If breakpoint n is not implemented, a write of <a href="AArch64-dbgbcrn_el1.html">DBGBCR&lt;n>_EL1</a> is <span class="arm-defined-word">UNDEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, in a system where the PE resets into EL2, 
      this field resets
       to <span class="binarynumber">0</span>.
</li></ul></div><div class="access_mechanisms"><h2>Accessing HDFGWTR_EL2</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt>, HDFGWTR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0011</td><td>0b0001</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV> == '11' then
        X[t, 64] = NVMem[0x1D8];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SCR_EL3.FGTEn == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; SCR_EL3.FGTEn == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = HDFGWTR_EL2;
elsif PSTATE.EL == EL3 then
    X[t, 64] = HDFGWTR_EL2;
                </p><h4 class="assembler">MSR HDFGWTR_EL2, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0011</td><td>0b0001</td><td>0b101</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV> == '11' then
        NVMem[0x1D8] = X[t, 64];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SCR_EL3.FGTEn == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; SCR_EL3.FGTEn == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        HDFGWTR_EL2 = X[t, 64];
elsif PSTATE.EL == EL3 then
    HDFGWTR_EL2 = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>30</ins><del>28</del>/03/2023 <ins>19</ins><del>16</del>:<ins>06</ins><del>01</del>; <ins>997dd0cf3258cacf72aa7cf7a885f19a4758c3af</ins><del>72747e43966d6b97dcbd230a1b3f0421d1ea3d94</del></p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>