<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>PAR_EL1</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">PAR_EL1, Physical Address Register</h1><p>The PAR_EL1 characteristics are:</p><h2>Purpose</h2><p>Returns the output address (OA) from an Address translation instruction that executed successfully, or fault information if the instruction did not execute successfully.</p><h2>Configuration</h2><p>AArch64 System register PAR_EL1 bits [63:0] are architecturally mapped to AArch32 System register <a href="AArch32-par.html">PAR[63:0]</a>.</p><p>AArch64 System register PAR_EL1 is a 128-bit register that can also be accessed as a 64-bit value. If it is accessed as a 64-bit register, accesses read and write bits [63:0] and do not modify bits [127:64].</p><p>Single stage AT Instructions (ATS1*) report their result using the 128-bit format of PAR_EL1 if the translation system that they target uses VMSAv9-128.</p><p>ATS12* Instructions report their result using the 128-bit format PAR_EL1 if either of the following is true:</p><ul><li>if stage 2 translations are enabled and the stage 2 translation system uses VMSAv9-128.
</li><li>if stage 2 translations are disabled and the stage 1 translation system uses VMSAv9-128.
</li></ul><p>Otherwise, 64-bit format of PAR_EL1 is used.</p><h2>Attributes</h2><p>PAR_EL1 is a:</p><ul><li>128-bit register when FEAT_D128 is implemented, GetPAR_EL1_D128() == 1 and GetPAR_EL1_F() == 0
</li><li>128-bit register when FEAT_D128 is implemented, GetPAR_EL1_D128() == 1 and GetPAR_EL1_F() == 1
</li><li>128-bit register when FEAT_D128 is implemented, GetPAR_EL1_D128() == 0 and GetPAR_EL1_F() == 0
</li><li>128-bit register when FEAT_D128 is implemented, GetPAR_EL1_D128() == 0 and GetPAR_EL1_F() == 1
</li><li>64-bit register when FEAT_D128 is not implemented and GetPAR_EL1_F() == 0
</li><li>64-bit register when FEAT_D128 is not implemented and GetPAR_EL1_F() == 1
</li></ul><h2>Field descriptions</h2><h3>When FEAT_D128 is implemented, GetPAR_EL1_D128() == 1 and GetPAR_EL1_F() == 0:</h3><table class="regdiagram"><thead><tr><td>127</td><td>126</td><td>125</td><td>124</td><td>123</td><td>122</td><td>121</td><td>120</td><td>119</td><td>118</td><td>117</td><td>116</td><td>115</td><td>114</td><td>113</td><td>112</td><td>111</td><td>110</td><td>109</td><td>108</td><td>107</td><td>106</td><td>105</td><td>104</td><td>103</td><td>102</td><td>101</td><td>100</td><td>99</td><td>98</td><td>97</td><td>96</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_0-127_120">RES0</a></td><td class="lr" colspan="24"><a href="#fieldset_0-119_76">PA</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>95</td><td>94</td><td>93</td><td>92</td><td>91</td><td>90</td><td>89</td><td>88</td><td>87</td><td>86</td><td>85</td><td>84</td><td>83</td><td>82</td><td>81</td><td>80</td><td>79</td><td>78</td><td>77</td><td>76</td><td>75</td><td>74</td><td>73</td><td>72</td><td>71</td><td>70</td><td>69</td><td>68</td><td>67</td><td>66</td><td>65</td><td>64</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_0-119_76">PA</a></td><td class="lr" colspan="11"><a href="#fieldset_0-75_65">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-64_64">D128</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_0-63_56">ATTR</a></td><td class="lr" colspan="24"><a href="#fieldset_0-55_12">RES0</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_0-55_12">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-11_11-1">NSE</a></td><td class="lr" colspan="1"><a href="#fieldset_0-10_10">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="1"><a href="#fieldset_0-9_9-1">NS</a></td><td class="lr" colspan="2"><a href="#fieldset_0-8_7">SH</a></td><td class="lr" colspan="6"><a href="#fieldset_0-6_1">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-0_0">F</a></td></tr></tbody><tr class="blank_row"/></table><div class="text_before_fields"><p>This section describes the register value returned by the successful execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p></div><h4 id="fieldset_0-127_120">Bits [127:120]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-119_76">PA, bits [119:76]</h4><div class="field"><p>Output address. The output address (OA) corresponding to the supplied input address. This field returns address bits[55:12].</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-75_65">Bits [75:65]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-64_64">D128, bit [64]</h4><div class="field"><p>Indicates if the PAR_EL1 uses the 128-bit format.</p><table class="valuetable"><tr><th>D128</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>PAR_EL1 uses the 128-bit format. PAR_EL1[127:0] holds valid data.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-63_56">ATTR, bits [63:56]</h4><div class="field"><p>Memory attributes for the returned output address. This field uses the same encoding as the Attr&lt;n> fields in <a href="AArch64-mair_el1.html">MAIR_EL1</a>, <a href="AArch64-mair_el2.html">MAIR_EL2</a>, and <a href="AArch64-mair_el3.html">MAIR_EL3</a>.</p><p>The value returned in this field can be the resulting attribute that is actually implemented by the implementation, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the translation table descriptor.</p><div class="note"><span class="note-header">Note</span><p>The attributes presented are consistent with the stages of translation applied in the address translation instruction. If the instruction performed a stage 1 translation only, the attributes are from the stage 1 translation. If the instruction performed a stage 1 and stage 2 translation, the attributes are from the combined stage 1 and stage 2 translation.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-55_12">Bits [55:12]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-11_11-1">NSE, bit [11]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field"><p>Reports the NSE attribute for a translation table descriptor from the EL3 translation regime.</p><p>For a description of the values derived by evaluating NS and NSE together, see PAR_EL1.NS.</p><p>For a result from a Secure, Non-secure, or Realm translation regime, this bit is unknown.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-11_11-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word"><ins>RES1</ins><del>RES0</del></span>.</p></div><h4 id="fieldset_0-10_10">IMPLEMENTATION DEFINED, bit [10]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p></div><h4 id="fieldset_0-9_9-1">NS, bit [9]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field"><p>Non-secure. The NS attribute for a translation table descriptor from a Secure translation regime, a Realm translation regime, and the EL3 translation regime.</p><table class="valuetable"><tr><th>NS</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>When NSE == 0: Secure.</p><p>When NSE == 1: Root.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>When NSE == 0: Non-secure.</p><p>When NSE == 1: Realm.</p></td></tr></table><p>For a result from a Secure translation regime, when <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2 is 1, this bit reflects the Security state of the intermediate physical address space of the translation for the instructions:</p><ul><li>In AArch64 state: <a href="AArch64-at-s1e1r.html">AT S1E1R</a>, <a href="AArch64-at-s1e1w.html">AT S1E1W</a>, <a href="AArch64-at-s1e1rp.html">AT S1E1RP</a>, <a href="AArch64-at-s1e1wp.html">AT S1E1WP</a>, <a href="AArch64-at-s1e0r.html">AT S1E0R</a>, and <a href="AArch64-at-s1e0w.html">AT S1E0W</a>.
</li><li>In AArch32 state: <a href="AArch32-ats1cpr.html">ATS1CPR</a>, <a href="AArch32-ats1cpw.html">ATS1CPW</a>, <a href="AArch32-ats1cprp.html">ATS1CPRP</a>, <a href="AArch32-ats1cpwp.html">ATS1CPWP</a>, <a href="AArch32-ats1cur.html">ATS1CUR</a>, and <a href="AArch32-ats1cuw.html">ATS1CUW</a>.
</li></ul><p>Otherwise, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p><p>For a result from a Non-secure translation regime, this bit is unknown.</p><p>For a result from an S1E1 or S1E0 operation on the Realm EL1&amp;0 translation regime, this bit is unknown.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-9_9-2"><span class="condition"><br/>When FEAT_RME is not implemented:
                        </span></h4><div class="field"><p>Non-secure.</p><p>The NS attribute for a translation table descriptor from a Secure translation regime.</p><p>For a result from a Secure translation regime, when <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2 is 1, this bit reflects the Security state of the intermediate physical address space of the translation for the instructions:</p><ul><li>In AArch64 state: <a href="AArch64-at-s1e1r.html">AT S1E1R</a>, <a href="AArch64-at-s1e1w.html">AT S1E1W</a>, <a href="AArch64-at-s1e1rp.html">AT S1E1RP</a>, <a href="AArch64-at-s1e1wp.html">AT S1E1WP</a>, <a href="AArch64-at-s1e0r.html">AT S1E0R</a>, and <a href="AArch64-at-s1e0w.html">AT S1E0W</a>.
</li><li>In AArch32 state: <a href="AArch32-ats1cpr.html">ATS1CPR</a>, <a href="AArch32-ats1cpw.html">ATS1CPW</a>, <a href="AArch32-ats1cprp.html">ATS1CPRP</a>, <a href="AArch32-ats1cpwp.html">ATS1CPWP</a>, <a href="AArch32-ats1cur.html">ATS1CUR</a>, and <a href="AArch32-ats1cuw.html">ATS1CUW</a>.
</li></ul><p>Otherwise, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p><p>For a result from a Non-secure translation regime, this bit is unknown.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-9_9-3"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-8_7">SH, bits [8:7]</h4><div class="field"><p>Shareability attribute, for the returned output address.</p><table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Non-shareable.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>Outer Shareable.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Inner Shareable.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Reserved.</p></td></tr></table><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the translation table descriptor.</p><div class="note"><span class="note-header">Note</span><p>This field returns the value <span class="binarynumber">0b10</span> for:</p><ul><li><p>Any type of Device memory.</p></li><li><p>Normal memory with both Inner Non-cacheable and Outer Non-cacheable attributes.</p></li></ul></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-6_1">Bits [6:1]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-0_0">F, bit [0]</h4><div class="field"><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Address translation completed successfully.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When FEAT_D128 is implemented, GetPAR_EL1_D128() == 1 and GetPAR_EL1_F() == 1:</h3><table class="regdiagram"><thead><tr><td>127</td><td>126</td><td>125</td><td>124</td><td>123</td><td>122</td><td>121</td><td>120</td><td>119</td><td>118</td><td>117</td><td>116</td><td>115</td><td>114</td><td>113</td><td>112</td><td>111</td><td>110</td><td>109</td><td>108</td><td>107</td><td>106</td><td>105</td><td>104</td><td>103</td><td>102</td><td>101</td><td>100</td><td>99</td><td>98</td><td>97</td><td>96</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_1-127_65">RES0</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>95</td><td>94</td><td>93</td><td>92</td><td>91</td><td>90</td><td>89</td><td>88</td><td>87</td><td>86</td><td>85</td><td>84</td><td>83</td><td>82</td><td>81</td><td>80</td><td>79</td><td>78</td><td>77</td><td>76</td><td>75</td><td>74</td><td>73</td><td>72</td><td>71</td><td>70</td><td>69</td><td>68</td><td>67</td><td>66</td><td>65</td><td>64</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="31"><a href="#fieldset_1-127_65">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_1-64_64">D128</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_1-63_56">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_1-55_52">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_1-51_48">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="16"><a href="#fieldset_1-47_16">RES0</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_1-47_16">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_1-15_15-1">DirtyBit</a></td><td class="lr" colspan="1"><a href="#fieldset_1-14_14-1">Overlay</a></td><td class="lr" colspan="1"><a href="#fieldset_1-13_13-1">TopLevel</a></td><td class="lr" colspan="1"><a href="#fieldset_1-12_12-1">AssuredOnly</a></td><td class="lr" colspan="1"><a href="#fieldset_1-11_11">RES1</a></td><td class="lr" colspan="1"><a href="#fieldset_1-10_10">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_1-9_9">S</a></td><td class="lr" colspan="1"><a href="#fieldset_1-8_8">PTW</a></td><td class="lr" colspan="1"><a href="#fieldset_1-7_7">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_1-6_1">FST</a></td><td class="lr" colspan="1"><a href="#fieldset_1-0_0">F</a></td></tr></tbody><tr class="blank_row"/></table><div class="text_before_fields"><p>This section describes the register value returned by a fault on the execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p></div><h4 id="fieldset_1-127_65">Bits [127:65]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-64_64">D128, bit [64]</h4><div class="field"><p>Indicates if the PAR_EL1 uses the 128-bit format.</p><table class="valuetable"><tr><th>D128</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>PAR_EL1 uses the 128-bit format. PAR_EL1[127:0] holds valid data.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-63_56">IMPLEMENTATION DEFINED, bits [63:56]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-55_52">IMPLEMENTATION DEFINED, bits [55:52]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-51_48">IMPLEMENTATION DEFINED, bits [51:48]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-47_16">Bits [47:16]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-15_15-1">DirtyBit, bit [15]<span class="condition"><br/>When FEAT_S1PIE is implemented or FEAT_S2PIE is implemented:
                        </span></h4><div class="field"><p>DirtyBit flag.</p><p>If a write access to memory generates a Data Abort for a Permission fault using Indirect Permission, this field holds information about the fault.</p><table class="valuetable"><tr><th>DirtyBit</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Permission Fault is not due to nDirty State or Dirty State.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Permission Fault is due to nDirty State or Dirty State.</p></td></tr></table><p>For any other fault or Access, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-15_15-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-14_14-1">Overlay, bit [14]<span class="condition"><br/>When FEAT_S1POE is implemented or FEAT_S2POE is implemented:
                        </span></h4><div class="field"><p>Overlay flag. If a memory access generates a Data Abort for a Permission fault, this field holds information about the fault.</p><table class="valuetable"><tr><th>Overlay</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort is due to Base Permissions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort is due to Overlay Permissions.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-14_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-13_13-1">TopLevel, bit [13]<span class="condition"><br/>When FEAT_THE is implemented:
                        </span></h4><div class="field"><p>Fault due to TopLevel. Indicates if the fault was due to TopLevel.</p><table class="valuetable"><tr><th>TopLevel</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Fault is not due to TopLevel.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Fault is due to TopLevel.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-13_13-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-12_12-1">AssuredOnly, bit [12]<span class="condition"><br/>When FEAT_THE is implemented:
                        </span></h4><div class="field"><p>AssuredOnly flag.</p><p>If a memory access generates a <ins>stage</ins><del>Stage</del> 2 Data Abort, this field holds information about the fault.</p><table class="valuetable"><tr><th>AssuredOnly</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort is not due to AssuredOnly.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort is due to AssuredOnly.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-12_12-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-11_11">Bit [11]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES1</span>.</p></div><h4 id="fieldset_1-10_10">Bit [10]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-9_9">S, bit [9]</h4><div class="field"><p>Indicates the translation stage at which the translation aborted:</p><table class="valuetable"><tr><th>S</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Translation aborted because of a fault in the stage 1 translation.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Translation aborted because of a fault in the stage 2 translation.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-8_8">PTW, bit [8]</h4><div class="field"><p>If this bit is set to 1, it indicates the translation aborted because of a stage 2 fault during a stage 1 translation table walk.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-7_7">Bit [7]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_1-6_1">FST, bits [6:1]</h4><div class="field"><p>Fault status code, as shown in the Data Abort ESR encoding.</p><table class="valuetable"><tr><th>FST</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td><p>Address size fault, level 0 of translation or translation table base register.</p></td></tr><tr><td class="bitfield">0b000001</td><td><p>Address size fault, level 1.</p></td></tr><tr><td class="bitfield">0b000010</td><td><p>Address size fault, level 2.</p></td></tr><tr><td class="bitfield">0b000011</td><td><p>Address size fault, level 3.</p></td></tr><tr><td class="bitfield">0b000100</td><td><p>Translation fault, level 0.</p></td></tr><tr><td class="bitfield">0b000101</td><td><p>Translation fault, level 1.</p></td></tr><tr><td class="bitfield">0b000110</td><td><p>Translation fault, level 2.</p></td></tr><tr><td class="bitfield">0b000111</td><td><p>Translation fault, level 3.</p></td></tr><tr><td class="bitfield">0b001001</td><td><p>Access flag fault, level 1.</p></td></tr><tr><td class="bitfield">0b001010</td><td><p>Access flag fault, level 2.</p></td></tr><tr><td class="bitfield">0b001011</td><td><p>Access flag fault, level 3.</p></td></tr><tr><td class="bitfield">0b001000</td><td><p>Access flag fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001100</td><td><p>Permission fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001101</td><td><p>Permission fault, level 1.</p></td></tr><tr><td class="bitfield">0b001110</td><td><p>Permission fault, level 2.</p></td></tr><tr><td class="bitfield">0b001111</td><td><p>Permission fault, level 3.</p></td></tr><tr><td class="bitfield">0b010010</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b010011</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b010100</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 0.</p></td></tr><tr><td class="bitfield">0b010101</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 1.</p></td></tr><tr><td class="bitfield">0b010110</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 2.</p></td></tr><tr><td class="bitfield">0b010111</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 3.</p></td></tr><tr><td class="bitfield">0b011011</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented and FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011100</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011101</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011110</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011111</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b100010</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented and FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100011</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_RME is implemented and FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b100100</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100101</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100110</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100111</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101000</td><td><p>Granule Protection Fault, not on translation table walk or hardware update of translation table.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101001</td><td><p>Address size fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101010</td><td><p>Translation fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b101011</td><td><p>Translation fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101100</td><td><p>Address Size fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b110000</td><td><p>TLB conflict abort.</p></td></tr><tr><td class="bitfield">0b110001</td><td><p>Unsupported atomic hardware update fault.</p></td><td>When FEAT_HAFDBS is implemented</td></tr><tr><td class="bitfield">0b111101</td><td><p>Section Domain fault, from an AArch32 stage 1 EL1&amp;0 translation regime using Short-descriptor translation table format.</p></td><td>When EL1 is capable of using AArch32</td></tr><tr><td class="bitfield">0b111110</td><td><p>Page Domain fault, from an AArch32 stage 1 EL1&amp;0 translation regime using Short-descriptor translation table format.</p></td><td>When EL1 is capable of using AArch32</td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_1-0_0">F, bit [0]</h4><div class="field"><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Address translation aborted.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When FEAT_D128 is implemented, GetPAR_EL1_D128() == 0 and GetPAR_EL1_F() == 0:</h3><table class="regdiagram"><thead><tr><td>127</td><td>126</td><td>125</td><td>124</td><td>123</td><td>122</td><td>121</td><td>120</td><td>119</td><td>118</td><td>117</td><td>116</td><td>115</td><td>114</td><td>113</td><td>112</td><td>111</td><td>110</td><td>109</td><td>108</td><td>107</td><td>106</td><td>105</td><td>104</td><td>103</td><td>102</td><td>101</td><td>100</td><td>99</td><td>98</td><td>97</td><td>96</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_2-127_65">RES0</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>95</td><td>94</td><td>93</td><td>92</td><td>91</td><td>90</td><td>89</td><td>88</td><td>87</td><td>86</td><td>85</td><td>84</td><td>83</td><td>82</td><td>81</td><td>80</td><td>79</td><td>78</td><td>77</td><td>76</td><td>75</td><td>74</td><td>73</td><td>72</td><td>71</td><td>70</td><td>69</td><td>68</td><td>67</td><td>66</td><td>65</td><td>64</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="31"><a href="#fieldset_2-127_65">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_2-64_64">D128</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_2-63_56">ATTR</a></td><td class="lr" colspan="4"><a href="#fieldset_2-55_52">RES0</a></td><td class="lr" colspan="4"><a href="#fieldset_2-51_48-1">PA[51:48]</a></td><td class="lr" colspan="16"><a href="#fieldset_2-47_12">PA[47:12]</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_2-47_12">PA[47:12]</a></td><td class="lr" colspan="1"><a href="#fieldset_2-11_11-1">NSE</a></td><td class="lr" colspan="1"><a href="#fieldset_2-10_10">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="1"><a href="#fieldset_2-9_9-1">NS</a></td><td class="lr" colspan="2"><a href="#fieldset_2-8_7">SH</a></td><td class="lr" colspan="6"><a href="#fieldset_2-6_1">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_2-0_0">F</a></td></tr></tbody><tr class="blank_row"/></table><div class="text_before_fields"><p>This section describes the register value returned by the successful execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p><p>On a successful conversion, the PAR_EL1 can return a value that indicates the resulting attributes, rather than the values that appear in the Translation table descriptors. More precisely:</p><ul><li>The PAR_EL1.{ATTR, SH} fields are permitted to report the resulting attributes, as determined by any permitted implementation choices and any applicable configuration bits, instead of reporting the values that appear in the Translation table descriptors.
</li><li>See the PAR_EL1.NS bit description for constraints on the value it returns.
</li></ul></div><h4 id="fieldset_2-127_65">Bits [127:65]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_2-64_64">D128, bit [64]</h4><div class="field"><p>Indicates if the PAR_EL1 uses the 128-bit format.</p><table class="valuetable"><tr><th>D128</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>PAR_EL1 uses the 128-bit format. PAR_EL1[127:0] holds valid data.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-63_56">ATTR, bits [63:56]</h4><div class="field"><p>Memory attributes for the returned output address. This field uses the same encoding as the Attr&lt;n> fields in <a href="AArch64-mair_el1.html">MAIR_EL1</a>, <a href="AArch64-mair_el2.html">MAIR_EL2</a>, and <a href="AArch64-mair_el3.html">MAIR_EL3</a>.</p><p>The value returned in this field can be the resulting attribute that is actually implemented by the implementation, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p><div class="note"><span class="note-header">Note</span><p>The attributes presented are consistent with the stages of translation applied in the address translation instruction. If the instruction performed a stage 1 translation only, the attributes are from the stage 1 translation. If the instruction performed a stage 1 and stage 2 translation, the attributes are from the combined stage 1 and stage 2 translation.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-55_52">Bits [55:52]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_2-51_48-1">PA[51:48], bits [51:48]<span class="condition"><br/>When FEAT_LPA is implemented:
                        </span></h4><div class="field"><p>Extension to PA[47:12]. For more information, see PA[47:12].</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-51_48-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_2-47_12">PA[47:12], bits [47:12]</h4><div class="field"><p>Output address. The output address (OA) corresponding to the supplied input address. This field returns address bits[47:12].</p><p>When <span class="xref">FEAT_LPA</span> is implemented and 52-bit addresses are in use, PA[51:48] forms the upper part of the address value. Otherwise, when 52-bit addresses are not in use, PA[51:48] is <span class="arm-defined-word">RES0</span>.</p><p>For implementations with fewer than 48 physical address bits, the corresponding upper bits in this field are <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-11_11-1">NSE, bit [11]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field"><p>Reports the NSE attribute for a translation table entry from the EL3 translation regime.</p><p>For a description of the values derived by evaluating NS and NSE together, see PAR_EL1.NS.</p><p>For a result from a Secure, Non-secure, or Realm translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p></div><h4 id="fieldset_2-11_11-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES1</span>.</p></div><h4 id="fieldset_2-10_10">IMPLEMENTATION DEFINED, bit [10]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-9_9-1">NS, bit [9]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field"><p>Non-secure. The NS attribute for a translation table entry from a Secure translation regime, a Realm translation regime, and the EL3 translation regime.</p><p>For a result from an EL3 translation regime, NS and NSE are evaluated together to report the physical address space:</p><table class="valuetable"><thead><tr><th>NSE</th><th>NS</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b0</span></td><td>When Secure state is implemented, Secure. Otherwise reserved.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b1</span></td><td>Non-secure.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b0</span></td><td>Root.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b1</span></td><td>Realm.</td></tr></tbody></table><p>For a result from a Secure translation regime, when <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2 is 1, this bit distinguishes between the Secure and Non-secure intermediate physical address space of the translation for the instructions:</p><ul><li>In AArch64 state: <a href="AArch64-at-s1e1r.html">AT S1E1R</a>, <a href="AArch64-at-s1e1w.html">AT S1E1W</a>, <a href="AArch64-at-s1e1rp.html">AT S1E1RP</a>, <a href="AArch64-at-s1e1wp.html">AT S1E1WP</a>, <a href="AArch64-at-s1e0r.html">AT S1E0R</a>, and <a href="AArch64-at-s1e0w.html">AT S1E0W</a>.
</li><li>In AArch32 state: <a href="AArch32-ats1cpr.html">ATS1CPR</a>, <a href="AArch32-ats1cpw.html">ATS1CPW</a>, <a href="AArch32-ats1cprp.html">ATS1CPRP</a>, <a href="AArch32-ats1cpwp.html">ATS1CPWP</a>, <a href="AArch32-ats1cur.html">ATS1CUR</a>, and <a href="AArch32-ats1cuw.html">ATS1CUW</a>.
</li></ul><p>Otherwise, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p><p>For a result from a Non-secure translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>For a result from an S1E1 or S1E0 operation on the Realm EL1&amp;0 translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-9_9-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Non-secure. The NS attribute for a translation table entry from a Secure translation regime.</p><p>For a result from a Secure translation regime, when <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2 is 1, this bit distinguishes between the Secure and Non-secure intermediate physical address space of the translation for the instructions:</p><ul><li>In AArch64 state: <a href="AArch64-at-s1e1r.html">AT S1E1R</a>, <a href="AArch64-at-s1e1w.html">AT S1E1W</a>, <a href="AArch64-at-s1e1rp.html">AT S1E1RP</a>, <a href="AArch64-at-s1e1wp.html">AT S1E1WP</a>, <a href="AArch64-at-s1e0r.html">AT S1E0R</a>, and <a href="AArch64-at-s1e0w.html">AT S1E0W</a>.
</li><li>In AArch32 state: <a href="AArch32-ats1cpr.html">ATS1CPR</a>, <a href="AArch32-ats1cpw.html">ATS1CPW</a>, <a href="AArch32-ats1cprp.html">ATS1CPRP</a>, <a href="AArch32-ats1cpwp.html">ATS1CPWP</a>, <a href="AArch32-ats1cur.html">ATS1CUR</a>, and <a href="AArch32-ats1cuw.html">ATS1CUW</a>.
</li></ul><p>Otherwise, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p><p>For a result from a Non-secure translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-8_7">SH, bits [8:7]</h4><div class="field"><p>Shareability attribute, for the returned output address.</p><table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Non-shareable.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Outer Shareable.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Inner Shareable.</p></td></tr></table><p>The value <span class="binarynumber">0b01</span> is reserved.</p><div class="note"><span class="note-header">Note</span><p>This field returns the value <span class="binarynumber">0b10</span> for:</p><ul><li>Any type of Device memory.</li><li>Normal memory with both Inner Non-cacheable and Outer Non-cacheable attributes.</li></ul></div><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_2-6_1">Bits [6:1]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_2-0_0">F, bit [0]</h4><div class="field"><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Address translation completed successfully.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When FEAT_D128 is implemented, GetPAR_EL1_D128() == 0 and GetPAR_EL1_F() == 1:</h3><table class="regdiagram"><thead><tr><td>127</td><td>126</td><td>125</td><td>124</td><td>123</td><td>122</td><td>121</td><td>120</td><td>119</td><td>118</td><td>117</td><td>116</td><td>115</td><td>114</td><td>113</td><td>112</td><td>111</td><td>110</td><td>109</td><td>108</td><td>107</td><td>106</td><td>105</td><td>104</td><td>103</td><td>102</td><td>101</td><td>100</td><td>99</td><td>98</td><td>97</td><td>96</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_3-127_65">RES0</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>95</td><td>94</td><td>93</td><td>92</td><td>91</td><td>90</td><td>89</td><td>88</td><td>87</td><td>86</td><td>85</td><td>84</td><td>83</td><td>82</td><td>81</td><td>80</td><td>79</td><td>78</td><td>77</td><td>76</td><td>75</td><td>74</td><td>73</td><td>72</td><td>71</td><td>70</td><td>69</td><td>68</td><td>67</td><td>66</td><td>65</td><td>64</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="31"><a href="#fieldset_3-127_65">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_3-64_64">D128</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_3-63_56">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_3-55_52">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_3-51_48">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="16"><a href="#fieldset_3-47_16">RES0</a></td></tr></tbody><tr class="blank_row"/><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_3-47_16">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_3-15_15-1">DirtyBit</a></td><td class="lr" colspan="1"><a href="#fieldset_3-14_14-1">Overlay</a></td><td class="lr" colspan="1"><a href="#fieldset_3-13_13-1">TopLevel</a></td><td class="lr" colspan="1"><a href="#fieldset_3-12_12-1">AssuredOnly</a></td><td class="lr" colspan="1"><a href="#fieldset_3-11_11">RES1</a></td><td class="lr" colspan="1"><a href="#fieldset_3-10_10">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_3-9_9">S</a></td><td class="lr" colspan="1"><a href="#fieldset_3-8_8">PTW</a></td><td class="lr" colspan="1"><a href="#fieldset_3-7_7">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_3-6_1">FST</a></td><td class="lr" colspan="1"><a href="#fieldset_3-0_0">F</a></td></tr></tbody><tr class="blank_row"/></table><div class="text_before_fields"><p>This section describes the register value returned by a fault on the execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p></div><h4 id="fieldset_3-127_65">Bits [127:65]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_3-64_64">D128, bit [64]</h4><div class="field"><p>Indicates if the PAR_EL1 uses the 128-bit format.</p><table class="valuetable"><tr><th>D128</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>PAR_EL1 uses the 128-bit format. PAR_EL1[127:0] holds valid data.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-63_56">IMPLEMENTATION DEFINED, bits [63:56]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-55_52">IMPLEMENTATION DEFINED, bits [55:52]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-51_48">IMPLEMENTATION DEFINED, bits [51:48]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-47_16">Bits [47:16]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_3-15_15-1">DirtyBit, bit [15]<span class="condition"><br/>When FEAT_S1PIE is implemented or FEAT_S2PIE is implemented:
                        </span></h4><div class="field"><p>DirtyBit flag.</p><p>If a write access to memory generates a Data Abort for a Permission fault using Indirect Permission, this field holds information about the fault.</p><table class="valuetable"><tr><th>DirtyBit</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Permission Fault is not due to nDirty State or Dirty State.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Permission Fault is due to nDirty State or Dirty State.</p></td></tr></table><p>For any other fault or Access, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-15_15-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_3-14_14-1">Overlay, bit [14]<span class="condition"><br/>When FEAT_S1POE is implemented or FEAT_S2POE is implemented:
                        </span></h4><div class="field"><p>Overlay flag. If a memory access generates a Data Abort for a Permission fault, this field holds information about the fault.</p><table class="valuetable"><tr><th>Overlay</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort is due to Base Permissions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort is due to Overlay Permissions.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-14_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_3-13_13-1">TopLevel, bit [13]<span class="condition"><br/>When FEAT_THE is implemented:
                        </span></h4><div class="field"><p>Fault due to TopLevel. Indicates if the fault was due to TopLevel.</p><table class="valuetable"><tr><th>TopLevel</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Fault is due to TopLevel.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-13_13-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_3-12_12-1">AssuredOnly, bit [12]<span class="condition"><br/>When FEAT_THE is implemented:
                        </span></h4><div class="field"><p>AssuredOnly flag.</p><p>If a memory access generates a <ins>stage</ins><del>Stage</del> 2 Data Abort, this field holds information about the fault.</p><table class="valuetable"><tr><th>AssuredOnly</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort is not due to AssuredOnly.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort is due to AssuredOnly.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-12_12-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_3-11_11">Bit [11]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES1</span>.</p></div><h4 id="fieldset_3-10_10">Bit [10]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_3-9_9">S, bit [9]</h4><div class="field"><p>Indicates the translation stage at which the translation aborted:</p><table class="valuetable"><tr><th>S</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Translation aborted because of a fault in the stage 1 translation.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Translation aborted because of a fault in the stage 2 translation.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-8_8">PTW, bit [8]</h4><div class="field"><p>If this bit is set to 1, it indicates the translation aborted because of a stage 2 fault during a stage 1 translation table walk.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-7_7">Bit [7]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_3-6_1">FST, bits [6:1]</h4><div class="field"><p>Fault status code, as shown in the Data Abort exception ESR encoding.</p><table class="valuetable"><tr><th>FST</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td><p>Address size fault, level 0 of translation or translation table base register.</p></td></tr><tr><td class="bitfield">0b000001</td><td><p>Address size fault, level 1.</p></td></tr><tr><td class="bitfield">0b000010</td><td><p>Address size fault, level 2.</p></td></tr><tr><td class="bitfield">0b000011</td><td><p>Address size fault, level 3.</p></td></tr><tr><td class="bitfield">0b000100</td><td><p>Translation fault, level 0.</p></td></tr><tr><td class="bitfield">0b000101</td><td><p>Translation fault, level 1.</p></td></tr><tr><td class="bitfield">0b000110</td><td><p>Translation fault, level 2.</p></td></tr><tr><td class="bitfield">0b000111</td><td><p>Translation fault, level 3.</p></td></tr><tr><td class="bitfield">0b001001</td><td><p>Access flag fault, level 1.</p></td></tr><tr><td class="bitfield">0b001010</td><td><p>Access flag fault, level 2.</p></td></tr><tr><td class="bitfield">0b001011</td><td><p>Access flag fault, level 3.</p></td></tr><tr><td class="bitfield">0b001000</td><td><p>Access flag fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001100</td><td><p>Permission fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001101</td><td><p>Permission fault, level 1.</p></td></tr><tr><td class="bitfield">0b001110</td><td><p>Permission fault, level 2.</p></td></tr><tr><td class="bitfield">0b001111</td><td><p>Permission fault, level 3.</p></td></tr><tr><td class="bitfield">0b010010</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b010011</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b010100</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 0.</p></td></tr><tr><td class="bitfield">0b010101</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 1.</p></td></tr><tr><td class="bitfield">0b010110</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 2.</p></td></tr><tr><td class="bitfield">0b010111</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 3.</p></td></tr><tr><td class="bitfield">0b011011</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented and FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011100</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011101</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011110</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011111</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b100010</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented and FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100011</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_RME is implemented and FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b100100</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100101</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100110</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100111</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101000</td><td><p>Granule Protection Fault, not on translation table walk or hardware update of translation table.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101001</td><td><p>Address size fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101010</td><td><p>Translation fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b101011</td><td><p>Translation fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101100</td><td><p>Address Size fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b110000</td><td><p>TLB conflict abort.</p></td></tr><tr><td class="bitfield">0b110001</td><td><p>Unsupported atomic hardware update fault.</p></td><td>When FEAT_HAFDBS is implemented</td></tr><tr><td class="bitfield">0b111101</td><td><p>Section Domain fault, from an AArch32 stage 1 EL1&amp;0 translation regime using Short-descriptor translation table format.</p></td><td>When EL1 is capable of using AArch32</td></tr><tr><td class="bitfield">0b111110</td><td><p>Page Domain fault, from an AArch32 stage 1 EL1&amp;0 translation regime using Short-descriptor translation table format.</p></td><td>When EL1 is capable of using AArch32</td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_3-0_0">F, bit [0]</h4><div class="field"><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Address translation aborted.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When FEAT_D128 is not implemented and GetPAR_EL1_F() == 0:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_4-63_56">ATTR</a></td><td class="lr" colspan="4"><a href="#fieldset_4-55_52">RES0</a></td><td class="lr" colspan="4"><a href="#fieldset_4-51_48-1">PA[51:48]</a></td><td class="lr" colspan="16"><a href="#fieldset_4-47_12">PA[47:12]</a></td></tr><tr class="firstrow"><td class="lr" colspan="20"><a href="#fieldset_4-47_12">PA[47:12]</a></td><td class="lr" colspan="1"><a href="#fieldset_4-11_11-1">NSE</a></td><td class="lr" colspan="1"><a href="#fieldset_4-10_10">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="1"><a href="#fieldset_4-9_9-1">NS</a></td><td class="lr" colspan="2"><a href="#fieldset_4-8_7">SH</a></td><td class="lr" colspan="6"><a href="#fieldset_4-6_1">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_4-0_0">F</a></td></tr></tbody></table><div class="text_before_fields"><p>This section describes the register value returned by the successful execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p><p>On a successful conversion, the PAR_EL1 can return a value that indicates the resulting attributes, rather than the values that appear in the Translation table descriptors. More precisely:</p><ul><li>The PAR_EL1.{ATTR, SH} fields are permitted to report the resulting attributes, as determined by any permitted implementation choices and any applicable configuration bits, instead of reporting the values that appear in the Translation table descriptors.
</li><li>See the PAR_EL1.NS bit description for constraints on the value it returns.
</li></ul></div><h4 id="fieldset_4-63_56">ATTR, bits [63:56]</h4><div class="field"><p>Memory attributes for the returned output address. This field uses the same encoding as the Attr&lt;n> fields in <a href="AArch64-mair_el1.html">MAIR_EL1</a>, <a href="AArch64-mair_el2.html">MAIR_EL2</a>, and <a href="AArch64-mair_el3.html">MAIR_EL3</a>.</p><p>If FEAT_MTE_PERM is implemented and the instruction performed a stage 2 translation, the following additional encoding is defined:</p><table class="valuetable"><thead><tr><th>ATTR</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b11100000</span></td><td>Tagged NoTagAccess Normal Inner Write-Back, Outer Write-Back,
Read-Allocate, Write-Allocate Non-transient memory.
Note: This encoding in MAIR_ELx is Reserved</td></tr></tbody></table><p>The value returned in this field can be the resulting attribute that is actually implemented by the implementation, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p><div class="note"><span class="note-header">Note</span><p>The attributes presented are consistent with the stages of translation applied in the address translation instruction. If the instruction performed a stage 1 translation only, the attributes are from the stage 1 translation. If the instruction performed a stage 1 and stage 2 translation, the attributes are from the combined stage 1 and stage 2 translation.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_4-55_52">Bits [55:52]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_4-51_48-1">PA[51:48], bits [51:48]<span class="condition"><br/>When FEAT_LPA is implemented:
                        </span></h4><div class="field"><p>Extension to PA[47:12]. For more information, see PA[47:12].</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_4-51_48-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_4-47_12">PA[47:12], bits [47:12]</h4><div class="field"><p>Output address. The output address (OA) corresponding to the supplied input address. This field returns address bits[47:12].</p><p>When <span class="xref">FEAT_LPA</span> is implemented and 52-bit addresses are in use, PA[51:48] forms the upper part of the address value. Otherwise, when 52-bit addresses are not in use, PA[51:48] is <span class="arm-defined-word">RES0</span>.</p><p>For implementations with fewer than 48 physical address bits, the corresponding upper bits in this field are <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_4-11_11-1">NSE, bit [11]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field"><p>Reports the NSE attribute for a translation table entry from the EL3 translation regime.</p><p>For a description of the values derived by evaluating NS and NSE together, see PAR_EL1.NS.</p><p>For a result from a Secure, Non-secure, or Realm translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p></div><h4 id="fieldset_4-11_11-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES1</span>.</p></div><h4 id="fieldset_4-10_10">IMPLEMENTATION DEFINED, bit [10]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_4-9_9-1">NS, bit [9]<span class="condition"><br/>When FEAT_RME is implemented:
                        </span></h4><div class="field"><p>Non-secure. The NS attribute for a translation table entry from a Secure translation regime, a Realm translation regime, and the EL3 translation regime.</p><p>For a result from an EL3 translation regime, NS and NSE are evaluated together to report the physical address space:</p><table class="valuetable"><thead><tr><th>NSE</th><th>NS</th><th>Meaning</th></tr></thead><tbody><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b0</span></td><td>When Secure state is implemented, Secure. Otherwise reserved.</td></tr><tr><td><span class="binarynumber">0b0</span></td><td><span class="binarynumber">0b1</span></td><td>Non-secure.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b0</span></td><td>Root.</td></tr><tr><td><span class="binarynumber">0b1</span></td><td><span class="binarynumber">0b1</span></td><td>Realm.</td></tr></tbody></table><p>For a result from a Secure translation regime, when <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2 is 1, this bit distinguishes between the Secure and Non-secure intermediate physical address space of the translation for the instructions:</p><ul><li>In AArch64 state: <a href="AArch64-at-s1e1r.html">AT S1E1R</a>, <a href="AArch64-at-s1e1w.html">AT S1E1W</a>, <a href="AArch64-at-s1e1rp.html">AT S1E1RP</a>, <a href="AArch64-at-s1e1wp.html">AT S1E1WP</a>, <a href="AArch64-at-s1e0r.html">AT S1E0R</a>, and <a href="AArch64-at-s1e0w.html">AT S1E0W</a>.
</li><li>In AArch32 state: <a href="AArch32-ats1cpr.html">ATS1CPR</a>, <a href="AArch32-ats1cpw.html">ATS1CPW</a>, <a href="AArch32-ats1cprp.html">ATS1CPRP</a>, <a href="AArch32-ats1cpwp.html">ATS1CPWP</a>, <a href="AArch32-ats1cur.html">ATS1CUR</a>, and <a href="AArch32-ats1cuw.html">ATS1CUW</a>.
</li></ul><p>Otherwise, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p><p>For a result from a Non-secure translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>For a result from an S1E1 or S1E0 operation on the Realm EL1&amp;0 translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_4-9_9-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Non-secure. The NS attribute for a translation table entry from a Secure translation regime.</p><p>For a result from a Secure translation regime, when <a href="AArch64-scr_el3.html">SCR_EL3</a>.EEL2 is 1, this bit distinguishes between the Secure and Non-secure intermediate physical address space of the translation for the instructions:</p><ul><li>In AArch64 state: <a href="AArch64-at-s1e1r.html">AT S1E1R</a>, <a href="AArch64-at-s1e1w.html">AT S1E1W</a>, <a href="AArch64-at-s1e1rp.html">AT S1E1RP</a>, <a href="AArch64-at-s1e1wp.html">AT S1E1WP</a>, <a href="AArch64-at-s1e0r.html">AT S1E0R</a>, and <a href="AArch64-at-s1e0w.html">AT S1E0W</a>.
</li><li>In AArch32 state: <a href="AArch32-ats1cpr.html">ATS1CPR</a>, <a href="AArch32-ats1cpw.html">ATS1CPW</a>, <a href="AArch32-ats1cprp.html">ATS1CPRP</a>, <a href="AArch32-ats1cpwp.html">ATS1CPWP</a>, <a href="AArch32-ats1cur.html">ATS1CUR</a>, and <a href="AArch32-ats1cuw.html">ATS1CUW</a>.
</li></ul><p>Otherwise, this bit reflects the Security state of the physical address space of the translation. This means it reflects the effect of the NSTable bits of earlier levels of the translation table walk if those NSTable bits have an effect on the translation.</p><p>For a result from a Non-secure translation regime, this bit is <span class="arm-defined-word">UNKNOWN</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_4-8_7">SH, bits [8:7]</h4><div class="field"><p>Shareability attribute, for the returned output address.</p><table class="valuetable"><tr><th>SH</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>Non-shareable.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>Outer Shareable.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>Inner Shareable.</p></td></tr></table><p>The value <span class="binarynumber">0b01</span> is reserved.</p><div class="note"><span class="note-header">Note</span><p>This field returns the value <span class="binarynumber">0b10</span> for:</p><ul><li>Any type of Device memory.</li><li>Normal memory with both Inner Non-cacheable and Outer Non-cacheable attributes.</li></ul></div><p>The value returned in this field can be the resulting attribute, as determined by any permitted implementation choices and any applicable configuration bits, instead of the value that appears in the Translation table descriptor.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_4-6_1">Bits [6:1]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_4-0_0">F, bit [0]</h4><div class="field"><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Address translation completed successfully.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h3>When FEAT_D128 is not implemented and GetPAR_EL1_F() == 1:</h3><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="8"><a href="#fieldset_5-63_56">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_5-55_52">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="4"><a href="#fieldset_5-51_48">IMPLEMENTATION DEFINED</a></td><td class="lr" colspan="16"><a href="#fieldset_5-47_16">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="16"><a href="#fieldset_5-47_16">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_5-15_15-1">DirtyBit</a></td><td class="lr" colspan="1"><a href="#fieldset_5-14_14-1">Overlay</a></td><td class="lr" colspan="1"><a href="#fieldset_5-13_13-1">TopLevel</a></td><td class="lr" colspan="1"><a href="#fieldset_5-12_12-1">AssuredOnly</a></td><td class="lr" colspan="1"><a href="#fieldset_5-11_11">RES1</a></td><td class="lr" colspan="1"><a href="#fieldset_5-10_10">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_5-9_9">S</a></td><td class="lr" colspan="1"><a href="#fieldset_5-8_8">PTW</a></td><td class="lr" colspan="1"><a href="#fieldset_5-7_7">RES0</a></td><td class="lr" colspan="6"><a href="#fieldset_5-6_1">FST</a></td><td class="lr" colspan="1"><a href="#fieldset_5-0_0">F</a></td></tr></tbody></table><div class="text_before_fields"><p>This section describes the register value returned by a fault on the execution of an Address translation instruction. Software might subsequently write a different value to the register, and that write does not affect the operation of the PE.</p></div><h4 id="fieldset_5-63_56">IMPLEMENTATION DEFINED, bits [63:56]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-55_52">IMPLEMENTATION DEFINED, bits [55:52]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-51_48">IMPLEMENTATION DEFINED, bits [51:48]</h4><div class="field"><p><span class="arm-defined-word">IMPLEMENTATION DEFINED</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-47_16">Bits [47:16]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_5-15_15-1">DirtyBit, bit [15]<span class="condition"><br/>When FEAT_S1PIE is implemented or FEAT_S2PIE is implemented:
                        </span></h4><div class="field"><p>DirtyBit flag.</p><p>If a write access to memory generates a Data Abort for a Permission fault using Indirect Permission, this field holds information about the fault.</p><table class="valuetable"><tr><th>DirtyBit</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Permission Fault is not due to nDirty State or Dirty State.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Permission Fault is due to nDirty State or Dirty State.</p></td></tr></table><p>For any other fault or Access, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-15_15-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_5-14_14-1">Overlay, bit [14]<span class="condition"><br/>When FEAT_S1POE is implemented or FEAT_S2POE is implemented:
                        </span></h4><div class="field"><p>Overlay flag. If a memory access generates a Data Abort for a Permission fault, this field holds information about the fault.</p><table class="valuetable"><tr><th>Overlay</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort is due to Base Permissions.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort is due to Overlay Permissions.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-14_14-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_5-13_13-1">TopLevel, bit [13]<span class="condition"><br/>When FEAT_THE is implemented:
                        </span></h4><div class="field"><p>Fault due to TopLevel. Indicates if the fault was due to TopLevel.</p><table class="valuetable"><tr><th>TopLevel</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Fault is due to TopLevel.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-13_13-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_5-12_12-1">AssuredOnly, bit [12]<span class="condition"><br/>When FEAT_THE is implemented:
                        </span></h4><div class="field"><p>AssuredOnly flag.</p><p>If a memory access generates a <ins>stage</ins><del>Stage</del> 2 Data Abort, this field holds information about the fault.</p><table class="valuetable"><tr><th>AssuredOnly</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>The Data Abort is not due to AssuredOnly.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>The Data Abort is due to AssuredOnly.</p></td></tr></table><p>For any other fault, this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-12_12-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_5-11_11">Bit [11]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES1</span>.</p></div><h4 id="fieldset_5-10_10">Bit [10]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_5-9_9">S, bit [9]</h4><div class="field"><p>Indicates the translation stage at which the translation aborted:</p><table class="valuetable"><tr><th>S</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>Translation aborted because of a fault in the stage 1 translation.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>Translation aborted because of a fault in the stage 2 translation.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-8_8">PTW, bit [8]</h4><div class="field"><p>If this bit is set to 1, it indicates the translation aborted because of a stage 2 fault during a stage 1 translation table walk.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-7_7">Bit [7]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_5-6_1">FST, bits [6:1]</h4><div class="field"><p>Fault status code, as shown in the Data Abort exception ESR encoding.</p><table class="valuetable"><tr><th>FST</th><th>Meaning</th><th>Applies when</th></tr><tr><td class="bitfield">0b000000</td><td><p>Address size fault, level 0 of translation or translation table base register.</p></td></tr><tr><td class="bitfield">0b000001</td><td><p>Address size fault, level 1.</p></td></tr><tr><td class="bitfield">0b000010</td><td><p>Address size fault, level 2.</p></td></tr><tr><td class="bitfield">0b000011</td><td><p>Address size fault, level 3.</p></td></tr><tr><td class="bitfield">0b000100</td><td><p>Translation fault, level 0.</p></td></tr><tr><td class="bitfield">0b000101</td><td><p>Translation fault, level 1.</p></td></tr><tr><td class="bitfield">0b000110</td><td><p>Translation fault, level 2.</p></td></tr><tr><td class="bitfield">0b000111</td><td><p>Translation fault, level 3.</p></td></tr><tr><td class="bitfield">0b001001</td><td><p>Access flag fault, level 1.</p></td></tr><tr><td class="bitfield">0b001010</td><td><p>Access flag fault, level 2.</p></td></tr><tr><td class="bitfield">0b001011</td><td><p>Access flag fault, level 3.</p></td></tr><tr><td class="bitfield">0b001000</td><td><p>Access flag fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001100</td><td><p>Permission fault, level 0.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b001101</td><td><p>Permission fault, level 1.</p></td></tr><tr><td class="bitfield">0b001110</td><td><p>Permission fault, level 2.</p></td></tr><tr><td class="bitfield">0b001111</td><td><p>Permission fault, level 3.</p></td></tr><tr><td class="bitfield">0b010010</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b010011</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b010100</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 0.</p></td></tr><tr><td class="bitfield">0b010101</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 1.</p></td></tr><tr><td class="bitfield">0b010110</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 2.</p></td></tr><tr><td class="bitfield">0b010111</td><td><p>Synchronous External abort on translation table walk or hardware update of translation table, level 3.</p></td></tr><tr><td class="bitfield">0b011011</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_LPA2 is implemented and FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011100</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011101</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011110</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b011111</td><td><p>Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RAS is not implemented</td></tr><tr><td class="bitfield">0b100010</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -2.</p></td><td>When FEAT_D128 is implemented and FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100011</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level -1.</p></td><td>When FEAT_RME is implemented and FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b100100</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 0.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100101</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 1.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100110</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 2.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b100111</td><td><p>Granule Protection Fault on translation table walk or hardware update of translation table, level 3.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101000</td><td><p>Granule Protection Fault, not on translation table walk or hardware update of translation table.</p></td><td>When FEAT_RME is implemented</td></tr><tr><td class="bitfield">0b101001</td><td><p>Address size fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101010</td><td><p>Translation fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b101011</td><td><p>Translation fault, level -1.</p></td><td>When FEAT_LPA2 is implemented</td></tr><tr><td class="bitfield">0b101100</td><td><p>Address Size fault, level -2.</p></td><td>When FEAT_D128 is implemented</td></tr><tr><td class="bitfield">0b110000</td><td><p>TLB conflict abort.</p></td></tr><tr><td class="bitfield">0b110001</td><td><p>Unsupported atomic hardware update fault.</p></td><td>When FEAT_HAFDBS is implemented</td></tr><tr><td class="bitfield">0b111101</td><td><p>Section Domain fault, from an AArch32 stage 1 EL1&amp;0 translation regime using Short-descriptor translation table format.</p></td><td>When EL1 is capable of using AArch32</td></tr><tr><td class="bitfield">0b111110</td><td><p>Page Domain fault, from an AArch32 stage 1 EL1&amp;0 translation regime using Short-descriptor translation table format.</p></td><td>When EL1 is capable of using AArch32</td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_5-0_0">F, bit [0]</h4><div class="field"><p>Indicates whether the instruction performed a successful address translation.</p><table class="valuetable"><tr><th>F</th><th>Meaning</th></tr><tr><td class="bitfield">0b1</td><td><p>Address translation aborted.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing PAR_EL1</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt>, PAR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0111</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGRTR_EL2.PAR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        X[t, 64] = PAR_EL1&lt;63:0>;
elsif PSTATE.EL == EL2 then
    X[t, 64] = PAR_EL1&lt;63:0>;
elsif PSTATE.EL == EL3 then
    X[t, 64] = PAR_EL1&lt;63:0>;
                </p><h4 class="assembler">MSR PAR_EL1, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0111</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGWTR_EL2.PAR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        PAR_EL1&lt;63:0> = X[t, 64];
elsif PSTATE.EL == EL2 then
    PAR_EL1&lt;63:0> = X[t, 64];
elsif PSTATE.EL == EL3 then
    PAR_EL1&lt;63:0> = X[t, 64];
                </p><h4 class="assembler"><span class="condition">
When FEAT_D128 is implemented
            </span><br/>MRRS &lt;Xt+1>, &lt;Xt>, PAR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0111</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SCR_EL3.D128En == '0' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGRTR_EL2.PAR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x14);
    elsif EL2Enabled() &amp;&amp; (!IsHCRXEL2Enabled() || HCRX_EL2.D128En == '0') then
        AArch64.SystemAccessTrap(EL2, 0x14);
    elsif HaveEL(EL3) &amp;&amp; SCR_EL3.D128En == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x14);
    else
        (X[t + 1, 64], X[t, 64]) = (PAR_EL1&lt;127:64>, PAR_EL1&lt;63:0>);
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SCR_EL3.D128En == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; SCR_EL3.D128En == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x14);
    else
        (X[t + 1, 64], X[t, 64]) = (PAR_EL1&lt;127:64>, PAR_EL1&lt;63:0>);
elsif PSTATE.EL == EL3 then
    (X[t + 1, 64], X[t, 64]) = (PAR_EL1&lt;127:64>, PAR_EL1&lt;63:0>);
                </p><h4 class="assembler"><span class="condition">
When FEAT_D128 is implemented
            </span><br/>MSRR PAR_EL1, &lt;Xt+1>, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b000</td><td>0b0111</td><td>0b0100</td><td>0b000</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SCR_EL3.D128En == '0' then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT) &amp;&amp; (!HaveEL(EL3) || SCR_EL3.FGTEn == '1') &amp;&amp; HFGWTR_EL2.PAR_EL1 == '1' then
        AArch64.SystemAccessTrap(EL2, 0x14);
    elsif EL2Enabled() &amp;&amp; (!IsHCRXEL2Enabled() || HCRX_EL2.D128En == '0') then
        AArch64.SystemAccessTrap(EL2, 0x14);
    elsif HaveEL(EL3) &amp;&amp; SCR_EL3.D128En == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x14);
    else
        (PAR_EL1&lt;127:64>, PAR_EL1&lt;63:0>) = (X[t + 1, 64], X[t, 64]);
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SCR_EL3.D128En == '0' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; SCR_EL3.D128En == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x14);
    else
        (PAR_EL1&lt;127:64>, PAR_EL1&lt;63:0>) = (X[t + 1, 64], X[t, 64]);
elsif PSTATE.EL == EL3 then
    (PAR_EL1&lt;127:64>, PAR_EL1&lt;63:0>) = (X[t + 1, 64], X[t, 64]);
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>30</ins><del>28</del>/03/2023 <ins>19</ins><del>16</del>:<ins>06</ins><del>02</del>; <ins>997dd0cf3258cacf72aa7cf7a885f19a4758c3af</ins><del>72747e43966d6b97dcbd230a1b3f0421d1ea3d94</del></p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>