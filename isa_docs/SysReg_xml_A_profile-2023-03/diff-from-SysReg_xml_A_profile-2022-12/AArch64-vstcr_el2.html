<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>VSTCR_EL2</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">VSTCR_EL2, Virtualization Secure Translation Control Register</h1><p>The VSTCR_EL2 characteristics are:</p><h2>Purpose</h2><p>The control register for stage 2 of the Secure EL1&amp;0 translation regime.</p><h2>Configuration</h2><p>This register is present only when FEAT_SEL2 is implemented. Otherwise, direct accesses to VSTCR_EL2 are <span class="arm-defined-word">UNDEFINED</span>.</p><p>This register has no effect if EL2 is not enabled in the current Security state.</p><h2>Attributes</h2><p>VSTCR_EL2 is a 64-bit register.</p><h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="30"><a href="#fieldset_0-63_34">RES0</a></td><td class="lr" colspan="1"><a href="#fieldset_0-33_33-1">SL2</a></td><td class="lr" colspan="1"><a href="#fieldset_0-32_32">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="1"><a href="#fieldset_0-31_31">RES1</a></td><td class="lr" colspan="1"><a href="#fieldset_0-30_30">SA</a></td><td class="lr" colspan="1"><a href="#fieldset_0-29_29">SW</a></td><td class="lr" colspan="13"><a href="#fieldset_0-28_16">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-15_14">TG0</a></td><td class="lr" colspan="6"><a href="#fieldset_0-13_8">RES0</a></td><td class="lr" colspan="2"><a href="#fieldset_0-7_6-1">SL0</a></td><td class="lr" colspan="6"><a href="#fieldset_0-5_0">T0SZ</a></td></tr></tbody></table><div class="text_before_fields"><p>Any of the bits in VSTCR_EL2 are permitted to be cached in a TLB.</p></div><h4 id="fieldset_0-63_34">Bits [63:34]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="field"><p><del>This field is IGNORED.</del></p></div><h4 id="fieldset_0-33_33-2"><span class="condition"><br/><del>When FEAT_LPA2 is implemented and (FEAT_D128 is not implemented or VTCR_EL2.D128 == 0):
                        </del></span></h4><h4 id="fieldset_0-33_33-1">SL2, bit [33]<span class="condition"><br/>When <ins>FEAT_LPA2</ins><del>FEAT_D128</del> is implemented and <ins>(FEAT_D128 is not implemented or </ins>VTCR_EL2.D128 == <ins>0):</ins><del>1:</del>
                        </span></h4><div class="field"><p>Starting level of the Secure stage 2 translation lookup controlled by VSTCR_EL2.</p><p>If <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.DS == 1, then VSTCR_EL2.SL2, in combination with VSTCR_EL2.SL0, gives encodings for the Secure stage 2 translation table walk initial lookup level.</p><p>If <a href="AArch64-vtcr_el2.html">VTCR_EL2</a>.DS == 0, then VSTCR_EL2.SL2 is <span class="arm-defined-word">RES0</span>.</p><p>If the translation granule size is not 4KB, then this field is <span class="arm-defined-word">RES0</span>.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-33_33-2"><span class="condition"><br/>Otherwise:
                        </span></h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-32_32">Bit [32]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-31_31">Bit [31]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES1</span>.</p></div><h4 id="fieldset_0-30_30">SA, bit [30]</h4><div class="field"><p>Secure stage 2 translation output address space.</p><table class="valuetable"><tr><th>SA</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>All stage 2 translations for the Secure IPA space access the Secure PA space.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>All stage 2 translations for the Secure IPA space access the Non-secure PA space.</p></td></tr></table><p>When the value of VSTCR_EL2.SW is 1, this bit behaves as 1 for all purposes other than reading back the value of the bit.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-29_29">SW, bit [29]</h4><div class="field"><p>Secure stage 2 translation address space.</p><table class="valuetable"><tr><th>SW</th><th>Meaning</th></tr><tr><td class="bitfield">0b0</td><td><p>All stage 2 translation table walks for the Secure IPA space are to the Secure PA space.</p></td></tr><tr><td class="bitfield">0b1</td><td><p>All stage 2 translation table walks for the Secure IPA space are to the Non-secure PA space.</p></td></tr></table><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-28_16">Bits [28:16]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-15_14">TG0, bits [15:14]</h4><div class="field"><p>Secure stage 2 granule size for <a href="AArch64-vsttbr_el2.html">VSTTBR_EL2</a>.</p><table class="valuetable"><tr><th>TG0</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>4KB.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>64KB.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>16KB.</p></td></tr></table><p>Other values are reserved.</p><p>If <span class="xref">FEAT_GTG</span> is implemented, <a href="AArch64-id_aa64mmfr0_el1.html">ID_AA64MMFR0_EL1</a>.{TGran4_2, TGran16_2, TGran64_2} indicate which granule sizes are supported for stage 2 translation.</p><p>If <span class="xref">FEAT_GTG</span> is not implemented, <a href="AArch64-id_aa64mmfr0_el1.html">ID_AA64MMFR0_EL1</a>.{TGran4, TGran16, TGran64} indicate which granule sizes are supported.</p><p>If the value is programmed to either a reserved value, or a size that has not been implemented, then for all purposes other than read back from this register, the hardware will treat the field as if it has been programmed to an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> choice of the sizes that has been implemented.</p><p>It is <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> whether the value read back is the value programmed or the value that corresponds to the size chosen.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-13_8">Bits [13:8]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-7_6-1">SL0, bits [7:6]<span class="condition"><br/>When FEAT_TTST is implemented and (FEAT_D128 is not implemented or VTCR_EL2.D128 == 0):
                        </span></h4><div class="field"><p>Starting level of the Secure stage 2 translation lookup, controlled by VSTCR_EL2. The meaning of this field depends on the value of VSTCR_EL2.TG0.</p><table class="valuetable"><tr><th>SL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b00</span> (4KB granule):</p><ul><li><p>If <span class="xref">FEAT_LPA2</span> is not implemented, start at level 2.</p></li><li><p>If <span class="xref">FEAT_LPA2</span> is implemented and VSTCR_EL2.SL2 is <span class="binarynumber">0b0</span>, start at level 2.</p></li><li><p>If <span class="xref">FEAT_LPA2</span> is implemented and VSTCR_EL2.SL2 is <span class="binarynumber">0b1</span>, start at level -1.</p></li></ul><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b10</span> (16KB granule) or <span class="binarynumber">0b01</span> (64KB granule), start at level 3.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b00</span> (4KB granule):</p><ul><li><p>If <span class="xref">FEAT_LPA2</span> is not implemented, start at level 1.</p></li><li><p>If <span class="xref">FEAT_LPA2</span> is implemented and VSTCR_EL2.SL2 is <span class="binarynumber">0b0</span>, start at level 1.</p></li><li><p>If <span class="xref">FEAT_LPA2</span> is implemented, the combination of VSTCR_EL2.SL0 == 01 and VSTCR_EL2.SL2 == 1 is reserved.</p></li></ul><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b10</span> (16KB granule) or <span class="binarynumber">0b01</span> (64KB granule), start at level 2.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b00</span> (4KB granule):</p><ul><li><p>If <span class="xref">FEAT_LPA2</span> is not implemented, start at level 0.</p></li><li><p>If <span class="xref">FEAT_LPA2</span> is implemented and VSTCR_EL2.SL2 is <span class="binarynumber">0b0</span>, start at level 0.</p></li><li><p>If <span class="xref">FEAT_LPA2</span> is implemented, the combination of VSTCR_EL2.SL0 == 10 and VSTCR_EL2.SL2 == 1 is reserved.</p></li></ul><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b10</span> (16KB granule) or <span class="binarynumber">0b01</span> (64KB granule), start at level 1.</p></td></tr><tr><td class="bitfield">0b11</td><td><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b00</span> (4KB granule):</p><ul><li><p>If <span class="xref">FEAT_LPA2</span> is not implemented, start at level 3.</p></li><li><p>If <span class="xref">FEAT_LPA2</span> is implemented and VSTCR_EL2.SL2 is <span class="binarynumber">0b0</span>, start at level 3.</p></li><li><p>If <span class="xref">FEAT_LPA2</span> is implemented, the combination of VSTCR_EL2.SL0 == 11 and VSTCR_EL2.SL2 == 1 is reserved.</p></li></ul><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b10</span> (16KB granule) and <span class="xref">FEAT_LPA2</span> is implemented, start at level 0.</p></td></tr></table><p>If this field is programmed to a value that is not consistent with the programming of VSTCR_EL2.T0SZ, then a stage 2 level 0 Translation fault is generated.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_6-2"><span class="condition"><br/><ins>When FEAT_TTST is not implemented and (FEAT_D128 is not implemented or VTCR_EL2.D128 == 0):</ins><del>Otherwise:</del>
                        </span></h4><div class="field"><p>Starting level of the Secure stage 2 translation lookup, controlled by VSTCR_EL2. The meaning of this field depends on the value of VSTCR_EL2.TG0.</p><table class="valuetable"><tr><th>SL0</th><th>Meaning</th></tr><tr><td class="bitfield">0b00</td><td><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b00</span> (4KB granule), start at level 2. If VSTCR_EL2.TG0 is <span class="binarynumber">0b10</span> (16KB granule) or <span class="binarynumber">0b01</span> (64KB granule), start at level 3.</p></td></tr><tr><td class="bitfield">0b01</td><td><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b00</span> (4KB granule), start at level 1. If VSTCR_EL2.TG0 is <span class="binarynumber">0b10</span> (16KB granule) or <span class="binarynumber">0b01</span> (64KB granule), start at level 2.</p></td></tr><tr><td class="bitfield">0b10</td><td><p>If VSTCR_EL2.TG0 is <span class="binarynumber">0b00</span> (4KB granule), start at level 0. If VSTCR_EL2.TG0 is <span class="binarynumber">0b10</span> (16KB granule) or <span class="binarynumber">0b01</span> (64KB granule), start at level 1.</p></td></tr></table><p>All other values are reserved. If this field is programmed to a reserved value, or to a value that is not consistent with the programming of VSTCR_EL2.T0SZ, then a stage 2 level 0 Translation fault is generated.</p><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><h4 id="fieldset_0-7_6-3"><span class="condition"><br/><ins>Otherwise:
                        </ins></span></h4><div class="field"><p><ins>Reserved, </ins><span class="arm-defined-word"><ins>RES0</ins></span><ins>.</ins></p></div><h4 id="fieldset_0-5_0">T0SZ, bits [5:0]</h4><div class="field"><p>The size offset of the memory region addressed by <a href="AArch64-vsttbr_el2.html">VSTTBR_EL2</a>. The region size is 2<sup>(64-T0SZ)</sup> bytes.</p><p>The maximum and minimum possible values for this field depend on the level of translation table and the memory translation granule size, as described in the AArch64 Virtual Memory System Architecture chapter.</p><p>If this field is programmed to a value that is not consistent with the programming of SL0, then a stage 2 level 0 Translation fault is generated.</p><div class="note"><span class="note-header">Note</span><p>For the 4KB translation granule, if <span class="xref">FEAT_LPA2</span> is implemented and this field is less than 16, the translation table walk begins with a level -1 initial lookup.</p><p>For the 16KB translation granule, if <span class="xref">FEAT_LPA2</span> is implemented and this field is less than 17, the translation table walk begins with a level 0 initial lookup.</p></div><p>The reset behavior of this field is:</p><ul><li>On a Warm reset, 
      this field resets
       to an architecturally <span class="arm-defined-word">UNKNOWN</span> value.</li></ul></div><div class="access_mechanisms"><h2>Accessing VSTCR_EL2</h2><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt>, VSTCR_EL2</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0010</td><td>0b0110</td><td>0b010</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if !IsCurrentSecurityState(SS_Secure) then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV> == '11' then
        X[t, 64] = NVMem[0x048];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if !IsCurrentSecurityState(SS_Secure) then
        UNDEFINED;
    else
        X[t, 64] = VSTCR_EL2;
elsif PSTATE.EL == EL3 then
    if SCR_EL3.EEL2 == '0' then
        UNDEFINED;
    else
        X[t, 64] = VSTCR_EL2;
                </p><h4 class="assembler">MSR VSTCR_EL2, &lt;Xt></h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b11</td><td>0b100</td><td>0b0010</td><td>0b0110</td><td>0b010</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if !IsCurrentSecurityState(SS_Secure) then
        UNDEFINED;
    elsif EL2Enabled() &amp;&amp; HCR_EL2.&lt;NV2,NV> == '11' then
        NVMem[0x048] = X[t, 64];
    elsif EL2Enabled() &amp;&amp; HCR_EL2.NV == '1' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    else
        UNDEFINED;
elsif PSTATE.EL == EL2 then
    if !IsCurrentSecurityState(SS_Secure) then
        UNDEFINED;
    else
        VSTCR_EL2 = X[t, 64];
elsif PSTATE.EL == EL3 then
    if SCR_EL3.EEL2 == '0' then
        UNDEFINED;
    else
        VSTCR_EL2 = X[t, 64];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>30</ins><del>28</del>/03/2023 <ins>19</ins><del>16</del>:<ins>06</ins><del>01</del>; <ins>997dd0cf3258cacf72aa7cf7a885f19a4758c3af</ins><del>72747e43966d6b97dcbd230a1b3f0421d1ea3d94</del></p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>