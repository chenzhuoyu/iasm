<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>SPMIIDR_EL1</title><link href="insn.css" rel="stylesheet" type="text/css"/></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h1 class="register-section">SPMIIDR_EL1, Implementation Identification Register</h1><p>The SPMIIDR_EL1 characteristics are:</p><h2>Purpose</h2><p>Provides discovery information for System PMU &lt;s>.</p><h2>Configuration</h2><p>This register is present only when FEAT_SPMU is implemented. Otherwise, direct accesses to SPMIIDR_EL1 are <span class="arm-defined-word">UNDEFINED</span>.</p><h2>Attributes</h2><p>SPMIIDR_EL1 is a 64-bit register.</p><h2>Field descriptions</h2><table class="regdiagram"><thead><tr><td>63</td><td>62</td><td>61</td><td>60</td><td>59</td><td>58</td><td>57</td><td>56</td><td>55</td><td>54</td><td>53</td><td>52</td><td>51</td><td>50</td><td>49</td><td>48</td><td>47</td><td>46</td><td>45</td><td>44</td><td>43</td><td>42</td><td>41</td><td>40</td><td>39</td><td>38</td><td>37</td><td>36</td><td>35</td><td>34</td><td>33</td><td>32</td></tr></thead><tfoot><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></tfoot><tbody><tr class="firstrow"><td class="lr" colspan="32"><a href="#fieldset_0-63_32">RES0</a></td></tr><tr class="firstrow"><td class="lr" colspan="12"><a href="#fieldset_0-31_20">ProductID</a></td><td class="lr" colspan="4"><a href="#fieldset_0-19_16">Variant</a></td><td class="lr" colspan="4"><a href="#fieldset_0-15_12">Revision</a></td><td class="lr" colspan="4"><a href="#fieldset_0-11_8">Implementer[10:7]</a></td><td class="lr" colspan="1"><a href="#fieldset_0-7_7">RES0</a></td><td class="lr" colspan="7"><a href="#fieldset_0-6_0">Implementer[6:0]</a></td></tr></tbody></table><h4 id="fieldset_0-63_32">Bits [63:32]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><h4 id="fieldset_0-31_20">ProductID, bits [31:20]</h4><div class="field"><p>Part number, bits [11:0]. The part number is selected by the designer of the component.</p><p>This field has an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><p>Access to this field is <span class="access_level">RO</span>.</p></div><h4 id="fieldset_0-19_16">Variant, bits [19:16]</h4><div class="field"><p>Component major revision.</p><p>Defines either a variant of the component defined by SPMIIDR_EL1.ProductID, or the major revision of the component.</p><p>When defining a major revision, SPMIIDR_EL1.Variant and SPMIIDR_EL1.Revision together form the revision number of the component, with SPMIIDR_EL1.Variant being the most significant part and SPMIIDR_EL1.Revision the least significant part. When a component is changed, SPMIIDR_EL1.Variant or SPMIIDR_EL1.Revision is increased to ensure that software can differentiate the different revisions of the component. If SPMIIDR_EL1.Variant is increased then SPMIIDR_EL1.Revision should be set to <span class="binarynumber">0b0000</span>.</p><p>This field has an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><p>Access to this field is <span class="access_level">RO</span>.</p></div><h4 id="fieldset_0-15_12">Revision, bits [15:12]</h4><div class="field"><p>Component minor revision.</p><p>When a component is changed:</p><ul><li>If SPMIIDR_EL1.Variant and SPMIIDR_EL1.Revision together form the revision number of the component then:<ul><li>SPMIIDR_EL1.Variant or SPMIIDR_EL1.Revision is increased to ensure that software can differentiate the different revisions of the component.
</li><li>If Variant is increased then Revision should be set to <span class="binarynumber">0b0000</span>.
</li></ul></li><li>Otherwise, SPMIIDR_EL1.Revision is increased to ensure that software can differentiate the different revisions of the component.
</li></ul><p>This field has an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><p>Access to this field is <span class="access_level">RO</span>.</p></div><h4 id="fieldset_0-11_8">Implementer, bits [11:8, 6:0]</h4><div class="field"><p>JEDEC-assigned JEP106 identification code of the designer of the component.</p><p>SPMIIDR_EL1[11:8] is the JEP106 bank identifier minus 1 and SPMIIDR_EL1[6:0] is the JEP106 identification code for the designer of the component. The code identifies the designer of the component, which might not be not the same as the implementer of the device containing the component. To obtain a number, or to see the assignment of these codes, contact JEDEC http://www.jedec.org.</p><div class="note"><span class="note-header">Note</span><p>For example, for a component designed by Arm Limited, the JEP106 bank is 5, and the JEP106 identification code is <span class="hexnumber">0x3B</span>, meaning SPMIIDR_EL1[11:0] has the value <span class="hexnumber">0x43B</span>.</p></div><p>Zero is not a valid JEP106 identification code, meaning a value of zero for SPMIIDR_EL1 indicates this register is not implemented.</p><p>This field has an <span class="arm-defined-word">IMPLEMENTATION DEFINED</span> value.</p><p>The Implementer field is split as follows:</p><ul><li>Implementer[10:7] is SPMIIDR_EL1[11:8].
</li><li>Implementer[6:0] is SPMIIDR_EL1[6:0].
</li></ul><p>Access to this field is <span class="access_level">RO</span>.</p></div><h4 id="fieldset_0-7_7">Bit [7]</h4><div class="field"><p>Reserved, <span class="arm-defined-word">RES0</span>.</p></div><div class="access_mechanisms"><h2>Accessing SPMIIDR_EL1</h2><p>To access SPMIIDR_EL1 for System PMU &lt;s>, set <a href="AArch64-spmselr_el0.html">SPMSELR_EL0</a>.SYSPMUSEL to s.</p><p>SPMIIDR_EL1 reads-as-zero if <ins>any</ins><del>the</del> <ins>of</ins><del>System</del> <ins>the</ins><del>PMU</del> <ins>following</ins><del>selected</del> <ins>are true:</ins><del>by</del><a href="AArch64-spmselr_el0.html"><del>SPMSELR_EL0</del></a><del>.SYSPMUSEL is not implemented.</del></p><ul><li><ins>System PMU &lt;s> is not implemented.
</ins></li><li><ins>System PMU &lt;s> does not implement SPMIIDR_EL1.
</ins></li></ul><p>Accesses to this register use the following encodings in the System register encoding space:</p><h4 class="assembler">MRS &lt;Xt>, SPMIIDR_EL1</h4><table class="access_instructions"><tr><th>op0</th><th>op1</th><th>CRn</th><th>CRm</th><th>op2</th></tr><tr><td>0b10</td><td>0b000</td><td>0b1001</td><td>0b1101</td><td>0b100</td></tr></table><p class="pseudocode">
if PSTATE.EL == EL0 then
    UNDEFINED;
elsif PSTATE.EL == EL1 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; MDCR_EL3.EnPM2 == '0' then
        UNDEFINED;
    elsif <ins>Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SPMACCESSR_EL3&lt;(UInt(SPMSELR_EL0.SYSPMUSEL) * 2) + 1:UInt(SPMSELR_EL0.SYSPMUSEL) * 2> == '00' then
        UNDEFINED;
    elsif </ins>EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT2) &amp;&amp; HaveEL(EL3) &amp;&amp; SCR_EL3.FGTEn2 == '0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; IsFeatureImplemented(FEAT_FGT2) &amp;&amp; HDFGRTR2_EL2.nSPMID == '0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif <ins>EL2Enabled() &amp;&amp; MDCR_EL2.EnSPM == '0' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif EL2Enabled() &amp;&amp; SPMACCESSR_EL2&lt;(UInt(SPMSELR_EL0.SYSPMUSEL) * 2) + 1:UInt(SPMSELR_EL0.SYSPMUSEL) * 2> == '00' then
        AArch64.SystemAccessTrap(EL2, 0x18);
    elsif </ins>HaveEL(EL3) &amp;&amp; MDCR_EL3.EnPM2 == '0' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    <ins>elsif HaveEL(EL3) &amp;&amp; SPMACCESSR_EL3&lt;(UInt(SPMSELR_EL0.SYSPMUSEL) * 2) + 1:UInt(SPMSELR_EL0.SYSPMUSEL) * 2> == '00' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        </ins>else<ins>
            AArch64.SystemAccessTrap(EL3, 0x18);
    else</ins>
        X[t, 64] = SPMIIDR_EL1[UInt(SPMSELR_EL0.SYSPMUSEL)];
elsif PSTATE.EL == EL2 then
    if Halted() &amp;&amp; HaveEL(EL3) &amp;&amp; EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; MDCR_EL3.EnPM2 == '0' then
        UNDEFINED;
    elsif <ins>Halted() &amp;&amp; </ins>HaveEL(EL3) &amp;&amp; <ins>EDSCR.SDD == '1' &amp;&amp; boolean IMPLEMENTATION_DEFINED "EL3 trap priority when SDD == '1'" &amp;&amp; SPMACCESSR_EL3&lt;(UInt(SPMSELR_EL0.SYSPMUSEL) * 2) + 1:UInt(SPMSELR_EL0.SYSPMUSEL) * 2> == '00' then
        UNDEFINED;
    elsif HaveEL(EL3) &amp;&amp; </ins>MDCR_EL3.EnPM2 == '0<ins>' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    elsif HaveEL(EL3) &amp;&amp; SPMACCESSR_EL3&lt;(UInt(SPMSELR_EL0.SYSPMUSEL) * 2) + 1:UInt(SPMSELR_EL0.SYSPMUSEL) * 2> == '00</ins>' then
        if Halted() &amp;&amp; EDSCR.SDD == '1' then
            UNDEFINED;
        else
            AArch64.SystemAccessTrap(EL3, 0x18);
    else
        X[t, 64] = SPMIIDR_EL1[UInt(SPMSELR_EL0.SYSPMUSEL)];
elsif PSTATE.EL == EL3 then
    X[t, 64] = SPMIIDR_EL1[UInt(SPMSELR_EL0.SYSPMUSEL)];
                </p></div><hr class="bottom_line"/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="AArch32-regindex.html">AArch32 Registers</a></div></td><td><div class="topbar"><a href="AArch64-regindex.html">AArch64 Registers</a></div></td><td><div class="topbar"><a href="AArch32-sysindex.html">AArch32 Instructions</a></div></td><td><div class="topbar"><a href="AArch64-sysindex.html">AArch64 Instructions</a></div></td><td><div class="topbar"><a href="enc_index.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="ext_alpha_index.html">External Registers</a></div></td><td><div class="topbar"><a href="ext_enc_index.html">External Registers by Offset</a></div></td><td><div class="topbar"><a href="func_index.html">Registers by Functional Group</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions"><ins>30</ins><del>28</del>/03/2023 <ins>19</ins><del>16</del>:<ins>07</ins><del>02</del>; <ins>997dd0cf3258cacf72aa7cf7a885f19a4758c3af</ins><del>72747e43966d6b97dcbd230a1b3f0421d1ea3d94</del></p><p class="copyconf">Copyright © 2010-2023 Arm Limited or its affiliates. All rights reserved. This document is Non-Confidential.</p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>