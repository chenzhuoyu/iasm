<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>BFCVTN, BFCVTN2 -- A64</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">BFCVTN, BFCVTN2</h2>
      <p class="aml">Floating-point convert from single-precision to BFloat16 format (vector) reads each single-precision element in the SIMD&amp;FP source vector, converts each value to BFloat16 format, and writes the results in the lower or upper half of the SIMD&amp;FP destination vector. The result elements are half the width of the source elements.</p>
      <p class="aml">The BFCVTN instruction writes the half-width results to the lower half of the destination vector and clears the upper half to zero, while the BFCVTN2 instruction writes the results to the upper half of the destination vector without affecting the other bits in the register.</p>
    
    <h3 class="classheading"><a id="iclass_simd_single_and_bf16"/>Vector single-precision to BFloat16<span style="font-size:smaller;"><br/>(FEAT_BF16)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">0</td><td class="lr">Q</td><td class="lr">0</td><td class="l">0</td><td>1</td><td>1</td><td>1</td><td class="r">0</td><td class="l">1</td><td class="r">0</td><td class="l">1</td><td>0</td><td>0</td><td>0</td><td class="r">0</td><td class="l">1</td><td>0</td><td>1</td><td>1</td><td class="r">0</td><td class="l">1</td><td class="r">0</td><td colspan="5" class="lr">Rn</td><td colspan="5" class="lr">Rd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="BFCVTN_asimdmisc_4S"/><p class="asm-code">BFCVTN<a href="#sa_2" title="Second and upper half specifier (field &quot;Q&quot;)">{2}</a>  <a href="#sa_vd" title="SIMD&amp;FP destination register (field &quot;Rd&quot;)">&lt;Vd&gt;</a>.<a href="#sa_ta" title="Arrangement specifier (field &quot;Q&quot;) [4H,8H]">&lt;Ta&gt;</a>, <a href="#sa_vn" title="SIMD&amp;FP source register (field &quot;Rn&quot;)">&lt;Vn&gt;</a>.4S</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-shared.HaveBF16Ext.0" title="function: boolean HaveBF16Ext()">HaveBF16Ext</a>() then UNDEFINED;
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rd);
integer part = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Q);
integer elements = 64 DIV 16;</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>2</td><td><a id="sa_2"/>
        <p>Is the second and upper half specifier. If present it causes the operation to be performed on the upper 64 bits of the registers holding the narrower elements, and is 
      encoded in
      <q>Q</q>:
        </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">Q</th>
                <th class="symbol">2</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">0</td>
                <td class="symbol">[absent]</td>
              </tr>
              <tr>
                <td class="bitfield">1</td>
                <td class="symbol">[present]</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Vd&gt;</td><td><a id="sa_vd"/>
        
          <p class="aml">Is the name of the SIMD&amp;FP destination register, encoded in the "Rd" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Ta&gt;</td><td><a id="sa_ta"/>
        <p>Is an arrangement specifier, 
      encoded in
      <q>Q</q>:
        </p>
        <table class="valuetable">
          
            <thead>
              <tr>
                <th class="bitfield">Q</th>
                <th class="symbol">&lt;Ta&gt;</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="bitfield">0</td>
                <td class="symbol">4H</td>
              </tr>
              <tr>
                <td class="bitfield">1</td>
                <td class="symbol">8H</td>
              </tr>
            </tbody>
          
        </table>
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Vn&gt;</td><td><a id="sa_vn"/>
        
          <p class="aml">Is the name of the SIMD&amp;FP source register, encoded in the "Rn" field.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckFPAdvSIMDEnabled64.0" title="function: CheckFPAdvSIMDEnabled64()">CheckFPAdvSIMDEnabled64</a>();
bits(128) operand = <a href="shared_pseudocode.html#impl-aarch64.V.read.2" title="accessor: bits(width) V[integer n, integer width]">V</a>[n, 128];
bits(64) result;

for e = 0 to elements-1
    <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e, 16] = <a href="shared_pseudocode.html#impl-shared.FPConvertBF.2" title="function: bits(N DIV 2) FPConvertBF(bits(N) op, FPCRType fpcr)">FPConvertBF</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand, e, 32], FPCR[]);

<a href="shared_pseudocode.html#impl-aarch64.Vpart.write.3" title="accessor: Vpart[integer n, integer part, integer width] = bits(width) value">Vpart</a>[d, part, 64] = result;</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.62, AdvSIMD v29.12, pseudocode v2023-03_rel, sve v2023-03_rc3b
      ; Build timestamp: 2023-03-31T11:36
    </p><p class="copyconf">
      Copyright Â© 2010-2023 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
