<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>LDNT1SH</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">LDNT1SH</h2><p>Gather load non-temporal signed halfwords</p>
      <p class="aml">Gather load non-temporal of signed halfwords to active elements of a vector register from memory addresses generated by a vector base plus a 64-bit unscaled scalar register offset. Inactive elements will not cause a read from Device memory or signal faults, and are set to zero in the destination vector.</p>
      <p class="aml">A non-temporal load is a hint to the system that this data is unlikely to be referenced again soon.</p>
      <p class="aml">This instruction is illegal when executed in Streaming SVE mode, unless FEAT_SME_FA64 is implemented and enabled.</p>
    
    <p class="desc">
      It has encodings from 2 classes:
      <a href="#iclass_off_s_x32_unscaled">32-bit unscaled offset</a>
       and 
      <a href="#iclass_off_d_64_unscaled">64-bit unscaled offset</a>
    </p>
    <h3 class="classheading"><a id="iclass_off_s_x32_unscaled"/>32-bit unscaled offset</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="l">0</td><td class="r">0</td><td colspan="5" class="lr">Rm</td><td class="l">1</td><td class="r">0</td><td class="lr">0</td><td colspan="3" class="lr">Pg</td><td colspan="5" class="lr">Zn</td><td colspan="5" class="lr">Zt</td></tr><tr class="secondrow"><td colspan="7"/><td class="droppedname">msz&lt;1&gt;</td><td class="droppedname">msz&lt;0&gt;</td><td colspan="2"/><td colspan="5"/><td colspan="2"/><td class="droppedname">U</td><td colspan="3"/><td colspan="5"/><td colspan="5"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="ldnt1sh_z_p_ar_s_x32_unscaled"/><p class="asm-code">LDNT1SH { <a href="#sa_zt" title="Scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt&gt;</a>.S }, <a href="#sa_pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg&gt;</a>/Z, [<a href="#sa_zn" title="Base scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a>.S{, <a href="#sa_xm" title="Optional 64-bit general-purpose offset register, default XZR (field &quot;Rm&quot;)">&lt;Xm&gt;</a>}]</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
constant integer esize = 32;
constant integer msize = 16;
boolean unsigned = FALSE;</p>
    <h3 class="classheading"><a id="iclass_off_d_64_unscaled"/>64-bit unscaled offset</h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">1</td><td class="l">0</td><td class="r">0</td><td colspan="5" class="lr">Rm</td><td class="lr">1</td><td class="lr">0</td><td class="lr">0</td><td colspan="3" class="lr">Pg</td><td colspan="5" class="lr">Zn</td><td colspan="5" class="lr">Zt</td></tr><tr class="secondrow"><td colspan="7"/><td class="droppedname">msz&lt;1&gt;</td><td class="droppedname">msz&lt;0&gt;</td><td colspan="2"/><td colspan="5"/><td/><td class="droppedname">U</td><td/><td colspan="3"/><td colspan="5"/><td colspan="5"/></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="ldnt1sh_z_p_ar_d_64_unscaled"/><p class="asm-code">LDNT1SH { <a href="#sa_zt" title="Scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt&gt;</a>.D }, <a href="#sa_pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg&gt;</a>/Z, [<a href="#sa_zn" title="Base scalable vector register (field &quot;Zn&quot;)">&lt;Zn&gt;</a>.D{, <a href="#sa_xm" title="Optional 64-bit general-purpose offset register, default XZR (field &quot;Rm&quot;)">&lt;Xm&gt;</a>}]</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSVE2.0" title="function: boolean HaveSVE2()">HaveSVE2</a>() then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
constant integer esize = 64;
constant integer msize = 16;
boolean unsigned = FALSE;</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zt&gt;</td><td><a id="sa_zt"/>
        
          <p class="aml">Is the name of the scalable vector register to be transferred, encoded in the "Zt" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Pg&gt;</td><td><a id="sa_pg"/>
        
          <p class="aml">Is the name of the governing scalable predicate register P0-P7, encoded in the "Pg" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zn&gt;</td><td><a id="sa_zn"/>
        
          <p class="aml">Is the name of the base scalable vector register, encoded in the "Zn" field.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Xm&gt;</td><td><a id="sa_xm"/>
        
          <p class="aml">Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the "Rm" field.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckNonStreamingSVEEnabled.0" title="function: CheckNonStreamingSVEEnabled()">CheckNonStreamingSVEEnabled</a>();
constant integer VL = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
constant integer PL = VL DIV 8;
constant integer elements = VL DIV esize;
bits(PL) mask = <a href="shared_pseudocode.html#impl-aarch64.P.read.2" title="accessor: bits(width) P[integer n, integer width]">P</a>[g, PL];
bits(VL) base;
bits(64) offset;
bits(VL) result;
bits(msize) data;
constant integer mbytes = msize DIV 8;
boolean contiguous = FALSE;
boolean nontemporal = TRUE;
boolean tagchecked = TRUE;
<a href="shared_pseudocode.html#AccessDescriptor" title="type AccessDescriptor is ( AccessType acctype, bits(2) el, SecurityState ss, boolean acqsc, boolean acqpc, boolean relsc, boolean limitedordered, boolean exclusive, boolean atomicop, MemAtomicOp modop, boolean nontemporal, boolean read, boolean write, CacheOp cacheop, CacheOpScope opscope, CacheType cachetype, boolean pan, boolean transactional, boolean nonfault, boolean firstfault, boolean first, boolean contiguous, boolean streamingsve, boolean ls64, boolean mops, boolean rcw, boolean rcws, boolean toplevel, VARange varange, boolean a32lsmd, boolean tagchecked, boolean tagaccess, MPAMinfo mpam )">AccessDescriptor</a> accdesc = <a href="shared_pseudocode.html#impl-shared.CreateAccDescSVE.4" title="function: AccessDescriptor CreateAccDescSVE(MemOp memop, boolean nontemporal, boolean contiguous, boolean tagchecked)">CreateAccDescSVE</a>(<a href="shared_pseudocode.html#MemOp_LOAD" title="enumeration MemOp {MemOp_LOAD, MemOp_STORE, MemOp_PREFETCH}">MemOp_LOAD</a>, nontemporal, contiguous, tagchecked);

if <a href="shared_pseudocode.html#impl-aarch64.AnyActiveElement.2" title="function: boolean AnyActiveElement(bits(N) mask, integer esize)">AnyActiveElement</a>(mask, esize) then
    base = <a href="shared_pseudocode.html#impl-aarch64.Z.read.2" title="accessor: bits(width) Z[integer n, integer width]">Z</a>[n, VL];
    offset = <a href="shared_pseudocode.html#impl-aarch64.X.read.2" title="accessor: bits(width) X[integer n, integer width]">X</a>[m, 64];

for e = 0 to elements-1
    if <a href="shared_pseudocode.html#impl-aarch64.ActivePredicateElement.3" title="function: boolean ActivePredicateElement(bits(N) pred, integer e, integer esize)">ActivePredicateElement</a>(mask, e, esize) then
        bits(64) addr = <a href="shared_pseudocode.html#impl-shared.ZeroExtend.2" title="function: bits(N) ZeroExtend(bits(M) x, integer N)">ZeroExtend</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[base, e, esize], 64) + offset;
        data = <a href="shared_pseudocode.html#impl-aarch64.Mem.read.3" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccessDescriptor accdesc]">Mem</a>[addr, mbytes, accdesc];
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e, esize] = <a href="shared_pseudocode.html#impl-shared.Extend.3" title="function: bits(N) Extend(bits(M) x, integer N, boolean unsigned)">Extend</a>(data, esize, unsigned);
    else
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e, esize] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(esize);

<a href="shared_pseudocode.html#impl-aarch64.Z.write.2" title="accessor: Z[integer n, integer width] = bits(width) value">Z</a>[t, VL] = result;</p>
    </div>
  <h3>Operational information</h3><p class="aml">If FEAT_SVE2 is implemented or FEAT_SME is implemented, then if PSTATE.DIT is 1, 
                  the timing of this instruction is insensitive to the value of the data being loaded or stored when its governing predicate register contains the same value for each execution.
                </p><hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.62, AdvSIMD v29.12, pseudocode v2023-03_rel, sve v2023-03_rc3b
      ; Build timestamp: 2023-03-31T11:36
    </p><p class="copyconf">
      Copyright Â© 2010-2023 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
