<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="insn.css"/><meta name="generator" content="iform.xsl"/><title>BFMAX (multiple and single vector)</title></head><body><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">BFMAX (multiple and single vector)</h2><p>Multi-vector BFloat16 floating-point maximum by vector</p>
      <p class="aml">Determine the maximum of BFloat16 elements of the second source vector and the corresponding BFloat16 elements of the two or four first source vectors and destructively place the results in the corresponding elements of the two or four first source vectors.</p>
      <p class="aml">When FPCR.AH is 0, the behavior is as follows:</p>
      <ul>
        <li>
          Negative zero compares less than positive zero.
        </li>
        <li>
          When FPCR.DN is 0, if either element is a NaN, the result is a quiet NaN.
        </li>
        <li>
          When FPCR.DN is 1, if either element is a NaN, the result is Default NaN.
        </li>
      </ul>
      <p class="aml">When FPCR.AH is 1, the behavior is as follows:</p>
      <ul>
        <li>
          If both elements are zeros, regardless of the sign of either zero, the result is the second element.
        </li>
        <li>
          If either element is a NaN, regardless of the value of FPCR.DN, the result is the second element.
        </li>
      </ul>
      <p class="aml">This instruction follows SME2.1 non-widening BFloat16 numerical behaviors corresponding to instructions that place their results in two or four SVE Z vectors.</p>
      <p class="aml">This instruction is unpredicated.</p>
      <p class="aml">ID_AA64SMFR0_EL1.B16B16 indicates whether this instruction is implemented.</p>
    
    <p class="desc">
      It has encodings from 2 classes:
      <a href="#iclass_to_2reg">Two registers</a>
       and 
      <a href="#iclass_to_4reg">Four registers</a>
    </p>
    <h3 class="classheading"><a id="iclass_to_2reg"/>Two registers<span style="font-size:smaller;"><br/>(FEAT_SVE_B16B16)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">0</td><td class="lr">0</td><td class="l">1</td><td class="r">0</td><td colspan="4" class="lr">Zm</td><td class="l">1</td><td>0</td><td>1</td><td>0</td><td>0</td><td class="r">0</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">0</td><td colspan="4" class="lr">Zdn</td><td class="lr">0</td></tr><tr class="secondrow"><td colspan="8"/><td class="droppedname">size&lt;1&gt;</td><td class="droppedname">size&lt;0&gt;</td><td colspan="2"/><td colspan="4"/><td colspan="6"/><td colspan="3"/><td/><td/><td colspan="4"/><td/></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="bfmax_mz_zzv_2x1"/><p class="asm-code">BFMAX   { <a href="#sa_zdn1" title="First scalable vector register of a multi-vector sequence (field Zdn)">&lt;Zdn1&gt;</a>.H-<a href="#sa_zdn2" title="Second scalable vector register of a multi-vector sequence (field Zdn)">&lt;Zdn2&gt;</a>.H }, { <a href="#sa_zdn1" title="First scalable vector register of a multi-vector sequence (field Zdn)">&lt;Zdn1&gt;</a>.H-<a href="#sa_zdn2" title="Second scalable vector register of a multi-vector sequence (field Zdn)">&lt;Zdn2&gt;</a>.H }, <a href="#sa_zm" title="Second source scalable vector register Z0-Z15 (field &quot;Zm&quot;)">&lt;Zm&gt;</a>.H</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSMEB16B16.0" title="function: boolean HaveSMEB16B16()">HaveSMEB16B16</a>() then UNDEFINED;
integer dn = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zdn:'0');
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('0':Zm);
constant integer nreg = 2;</p>
    <h3 class="classheading"><a id="iclass_to_4reg"/>Four registers<span style="font-size:smaller;"><br/>(FEAT_SVE_B16B16)
          </span></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">0</td><td class="lr">0</td><td class="l">1</td><td class="r">0</td><td colspan="4" class="lr">Zm</td><td class="l">1</td><td>0</td><td>1</td><td>0</td><td>1</td><td class="r">0</td><td class="l">0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">0</td><td colspan="3" class="lr">Zdn</td><td class="lr">0</td><td class="lr">0</td></tr><tr class="secondrow"><td colspan="8"/><td class="droppedname">size&lt;1&gt;</td><td class="droppedname">size&lt;0&gt;</td><td colspan="2"/><td colspan="4"/><td colspan="6"/><td colspan="3"/><td/><td/><td colspan="3"/><td/><td/></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="bfmax_mz_zzv_4x1"/><p class="asm-code">BFMAX   { <a href="#sa_zdn1_1" title="First scalable vector register of a multi-vector sequence (field Zdn)">&lt;Zdn1&gt;</a>.H-<a href="#sa_zdn4" title="Fourth scalable vector register of a multi-vector sequence (field Zdn)">&lt;Zdn4&gt;</a>.H }, { <a href="#sa_zdn1_1" title="First scalable vector register of a multi-vector sequence (field Zdn)">&lt;Zdn1&gt;</a>.H-<a href="#sa_zdn4" title="Fourth scalable vector register of a multi-vector sequence (field Zdn)">&lt;Zdn4&gt;</a>.H }, <a href="#sa_zm" title="Second source scalable vector register Z0-Z15 (field &quot;Zm&quot;)">&lt;Zm&gt;</a>.H</p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-aarch64.HaveSMEB16B16.0" title="function: boolean HaveSMEB16B16()">HaveSMEB16B16</a>() then UNDEFINED;
integer dn = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zdn:'00');
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>('0':Zm);
constant integer nreg = 4;</p>
  <div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zdn1&gt;</td><td><a id="sa_zdn1"/>
        
          
        
        
          <p class="aml">For the two registers variant: is the name of the first scalable vector register of a multi-vector sequence, encoded as "Zdn" times 2.</p>
        
      </td></tr><tr><td/><td><a id="sa_zdn1_1"/>
        
          
        
        
          <p class="aml">For the four registers variant: is the name of the first scalable vector register of a multi-vector sequence, encoded as "Zdn" times 4.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zdn4&gt;</td><td><a id="sa_zdn4"/>
        
          <p class="aml">Is the name of the fourth scalable vector register of a multi-vector sequence, encoded as "Zdn" times 4 plus 3.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zdn2&gt;</td><td><a id="sa_zdn2"/>
        
          <p class="aml">Is the name of the second scalable vector register of a multi-vector sequence, encoded as "Zdn" times 2 plus 1.</p>
        
      </td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Zm&gt;</td><td><a id="sa_zm"/>
        
          <p class="aml">Is the name of the second source scalable vector register Z0-Z15, encoded in the "Zm" field.</p>
        
      </td></tr></table></div><div class="syntax-notes"/>
    <div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckStreamingSVEEnabled.0" title="function: CheckStreamingSVEEnabled()">CheckStreamingSVEEnabled</a>();
constant integer VL = <a href="shared_pseudocode.html#impl-aarch64.CurrentVL.read.none" title="accessor: integer CurrentVL">CurrentVL</a>;
constant integer elements = VL DIV 16;
array [0..3] of bits(VL) results;

for r = 0 to nreg-1
    bits(VL) operand1 = <a href="shared_pseudocode.html#impl-aarch64.Z.read.2" title="accessor: bits(width) Z[integer n, integer width]">Z</a>[dn+r, VL];
    bits(VL) operand2 = <a href="shared_pseudocode.html#impl-aarch64.Z.read.2" title="accessor: bits(width) Z[integer n, integer width]">Z</a>[m, VL];
    for e = 0 to elements-1
        bits(16) element1 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1, e, 16];
        bits(16) element2 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2, e, 16];
        <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[results[r], e, 16] = <a href="shared_pseudocode.html#impl-shared.BFMax.3" title="function: bits(N) BFMax(bits(N) op1, bits(N) op2, FPCRType fpcr)">BFMax</a>(element1, element2, FPCR[]);

for r = 0 to nreg-1
    <a href="shared_pseudocode.html#impl-aarch64.Z.write.2" title="accessor: Z[integer n, integer width] = bits(width) value">Z</a>[dn+r, VL] = results[r];</p>
    </div>
  <hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.62, AdvSIMD v29.12, pseudocode v2023-03_rel, sve v2023-03_rc3b
      ; Build timestamp: 2023-03-31T11:36
    </p><p class="copyconf">
      Copyright Â© 2010-2023 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
