<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><link href="insn.css" rel="stylesheet" type="text/css"/><meta content="iform.xsl" name="generator"/><title>FCADD -- A64</title></head><body><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr/><h2 class="instruction-section">FCADD</h2><p class="aml">Floating-point Complex Add.</p><p class="aml">This instruction operates on complex numbers that are represented in SIMD&amp;FP registers as pairs of elements, with the more significant element holding the imaginary part of the number and the less significant element holding the real part of the number. Each element holds a floating-point value. It performs the following computation on the corresponding complex number element pairs from the two source registers:</p><ul><li>Considering the complex number from the second source register on an Argand diagram, the number is rotated counterclockwise by 90 or 270 degrees.</li><li>The rotated complex number is added to the complex number from the first source register.</li></ul><p class="aml">This instruction can generate a floating-point exception. Depending on the settings in <a class="armarm-xref" title="Reference to Armv8 ARM section">FPCR</a>, the exception results in either a flag being set in <a class="armarm-xref" title="Reference to Armv8 ARM section">FPSR</a> or a synchronous exception being generated. For more information, see <a class="armarm-xref" title="Reference to Armv8 ARM section">Floating-point exception traps</a>.</p><p class="aml">Depending on the settings in the <a class="armarm-xref" title="Reference to Armv8 ARM section">CPACR_EL1</a>, <a class="armarm-xref" title="Reference to Armv8 ARM section">CPTR_EL2</a>, and <a class="armarm-xref" title="Reference to Armv8 ARM section">CPTR_EL3</a> registers, and the current Security state and Exception level, an attempt to execute the instruction might be trapped.</p><h3 class="classheading"><a id="iclass_simd"/>Vector<span style="font-size:smaller;"><br/>(FEAT_FCMA)
          </span></h3><p class="desc"/><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="lr">0</td><td class="lr">Q</td><td class="lr">1</td><td class="l">0</td><td>1</td><td>1</td><td>1</td><td class="r">0</td><td class="lr" colspan="2">size</td><td class="lr">0</td><td class="lr" colspan="5">Rm</td><td class="lr">1</td><td class="l">1</td><td class="r">1</td><td class="lr">rot</td><td class="lr">0</td><td class="lr">1</td><td class="lr" colspan="5">Rn</td><td class="lr" colspan="5">Rd</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding"/><a id="FCADD_asimdsame2_C"/><p class="asm-code">FCADD  <a href="#sa_vd" title="SIMD&amp;FP destination register (field &quot;Rd&quot;)">&lt;Vd></a>.<a href="#sa_t" title="Arrangement specifier (field &quot;size:Q&quot;) [2D,2S,4H,4S,8H]">&lt;T></a>, <a href="#sa_vn" title="First SIMD&amp;FP source register (field &quot;Rn&quot;)">&lt;Vn></a>.<a href="#sa_t" title="Arrangement specifier (field &quot;size:Q&quot;) [2D,2S,4H,4S,8H]">&lt;T></a>, <a href="#sa_vm" title="Second SIMD&amp;FP source register (field &quot;Rm&quot;)">&lt;Vm></a>.<a href="#sa_t" title="Arrangement specifier (field &quot;size:Q&quot;) [2D,2S,4H,4S,8H]">&lt;T></a>, #<a href="#sa_rotate" title="Rotation (field &quot;rot&quot;) [90,270]">&lt;rotate></a></p></div><p class="pseudocode">if !<a href="shared_pseudocode.html#impl-shared.HaveFCADDExt.0" title="function: boolean HaveFCADDExt()">HaveFCADDExt</a>() then UNDEFINED;
integer d = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rd);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
if size == '00' then UNDEFINED;
if Q == '0' &amp;&amp; size == '11' then UNDEFINED;
integer esize = 8 &lt;&lt; <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(size);
if !<a href="shared_pseudocode.html#impl-shared.HaveFP16Ext.0" title="function: boolean HaveFP16Ext()">HaveFP16Ext</a>() &amp;&amp; esize == 16 then UNDEFINED;
integer datasize = if Q == '1' then 128 else 64;
integer elements = datasize DIV esize;</p><div class="encoding-notes"/><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Vd></td><td><a id="sa_vd"/><p class="aml">Is the name of the SIMD&amp;FP destination register, encoded in the "Rd" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;T></td><td><a id="sa_t"/><p>Is an arrangement specifier, 
      encoded in
      <q>size:Q</q>:
        </p><table class="valuetable"><thead><tr><th class="bitfield">size</th><th class="bitfield">Q</th><th class="symbol">&lt;T></th></tr></thead><tbody><tr><td class="bitfield">00</td><td class="bitfield">x</td><td class="symbol">RESERVED</td></tr><tr><td class="bitfield">01</td><td class="bitfield">0</td><td class="symbol">4H</td></tr><tr><td class="bitfield">01</td><td class="bitfield">1</td><td class="symbol">8H</td></tr><tr><td class="bitfield">10</td><td class="bitfield">0</td><td class="symbol">2S</td></tr><tr><td class="bitfield">10</td><td class="bitfield">1</td><td class="symbol">4S</td></tr><tr><td class="bitfield">11</td><td class="bitfield">0</td><td class="symbol">RESERVED</td></tr><tr><td class="bitfield">11</td><td class="bitfield">1</td><td class="symbol">2D</td></tr></tbody></table></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Vn></td><td><a id="sa_vn"/><p class="aml">Is the name of the first SIMD&amp;FP source register, encoded in the "Rn" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;Vm></td><td><a id="sa_vm"/><p class="aml">Is the name of the second SIMD&amp;FP source register, encoded in the "Rm" field.</p></td></tr></table><table><col class="asyn-l"/><col class="asyn-r"/><tr><td>&lt;rotate></td><td><a id="sa_rotate"/><p>Is the rotation, 
      encoded in
      <q>rot</q>:
        </p><table class="valuetable"><thead><tr><th class="bitfield">rot</th><th class="symbol">&lt;rotate></th></tr></thead><tbody><tr><td class="bitfield">0</td><td class="symbol">90</td></tr><tr><td class="bitfield">1</td><td class="symbol">270</td></tr></tbody></table></td></tr></table></div><div class="syntax-notes"/><div class="ps"><a id="execute"/><h3 class="pseudocode">Operation</h3><p class="pseudocode"><a href="shared_pseudocode.html#impl-aarch64.CheckFPAdvSIMDEnabled64.0" title="function: CheckFPAdvSIMDEnabled64()">CheckFPAdvSIMDEnabled64</a>();
bits(datasize) operand1 = <a href="shared_pseudocode.html#impl-aarch64.V.read.2" title="accessor: bits(width) V[integer n, integer width]">V</a>[n, datasize];
bits(datasize) operand2 = <a href="shared_pseudocode.html#impl-aarch64.V.read.2" title="accessor: bits(width) V[integer n, integer width]">V</a>[m, datasize];
bits(datasize) result;
bits(esize) element1;
bits(esize) element3;

<ins>for e = 0 to (elements DIV 2)-1
</ins><del>for e = 0 to (elements DIV 2) -1
</del>    case rot of
        when '0'
            element1 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2, e*2+1, esize]);
            element3 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2, e*2, esize];
        when '1'
            element1 = <a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2, e*2+1, esize];
            element3 = <a href="shared_pseudocode.html#impl-shared.FPNeg.1" title="function: bits(N) FPNeg(bits(N) op)">FPNeg</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand2, e*2, esize]);
    <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e*2, esize] = <a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1, e*2, esize], element1, FPCR[]);
    <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[result, e*2+1, esize] = <a href="shared_pseudocode.html#impl-shared.FPAdd.3" title="function: bits(N) FPAdd(bits(N) op1, bits(N) op2, FPCRType fpcr)">FPAdd</a>(<a href="shared_pseudocode.html#impl-shared.Elem.read.3" title="accessor: bits(size) Elem[bits(N) vector, integer e, integer size]">Elem</a>[operand1, e*2+1, esize], element3, FPCR[]);

<a href="shared_pseudocode.html#impl-aarch64.V.write.2" title="accessor: V[integer n, integer width] = bits(width) value">V</a>[d, datasize] = result;</p></div><hr/><table style="margin: 0 auto;"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="mortlachindex.html">SME Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v33.62, AdvSIMD v29.12, pseudocode v2023-03_rel, sve v2023-03_rc3b
      ; Build timestamp: <ins>2023-03-31T11</ins><del>2023-03-31T10</del>:<ins>36</ins><del>41</del>
    </p><p class="copyconf">
      Copyright Â© 2010-2023 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p><div align="center" class="htmldiff_header"><table><tbody><tr><td class="old">(old) </td><td class="explain">htmldiff from-</td><td class="new">(new) </td></tr></tbody></table></div></body></html>