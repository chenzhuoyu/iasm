#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import itertools

from typing import cast
from typing import Literal
from typing import Iterator
from typing import NamedTuple

from enum import Enum
from xml.etree import ElementTree
from xml.etree.ElementTree import Element

class CodeGen:
    def __init__(self):
        self.buf = []
        self.level = 0

    @property
    def src(self) -> str:
        return '\n'.join(self.buf)

    def line(self, src: str = ''):
        self.buf.append(' ' * (self.level * 4) + src)

    def dedent(self):
        self.level -= 1

    def indent(self):
        self.level += 1

def status(*args):
    sys.stdout.write('\x1b[#F\x1b[K')
    print(*args)

print()
status('* Preparing ...')

### ---------- Advanced SIMD Registers ---------- ###

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()
cc.line('import (')
cc.indent()
cc.line('`fmt`')
cc.line()
cc.line('`github.com/chenzhuoyu/iasm/asm`')
cc.line('`github.com/chenzhuoyu/iasm/internal/tag`')
cc.dedent()
cc.line(')')
cc.line()
cc.line('// SIMDVector represents a SIMD vector.')
cc.line('type SIMDVector interface {')
cc.indent()
cc.line('fmt.Stringer')
cc.line('Arrangement() SIMDVectorArrangement')
cc.dedent()
cc.line('}')
cc.line()
cc.line('// SIMDRegister represents an Advanced SIMD hardware register.')
cc.line('type SIMDRegister interface {')
cc.indent()
cc.line('asm.Register')
cc.line('ItemWidth() uint8')
cc.dedent()
cc.line('}')
cc.line()

cc.line('// SIMDVectorArrangement represents the data arrangement of a V register.')
cc.line('type SIMDVectorArrangement uint8')
cc.line()

cc.line('const (')
cc.indent()
cc.line('Vec8B  SIMDVectorArrangement = 0b000')
cc.line('Vec16B SIMDVectorArrangement = 0b001')
cc.line('Vec4H  SIMDVectorArrangement = 0b010')
cc.line('Vec8H  SIMDVectorArrangement = 0b011')
cc.line('Vec2S  SIMDVectorArrangement = 0b100')
cc.line('Vec4S  SIMDVectorArrangement = 0b101')
cc.line('Vec1D  SIMDVectorArrangement = 0b110')
cc.line('Vec2D  SIMDVectorArrangement = 0b111')
cc.dedent()
cc.line(')')
cc.line()

cc.line('// SIMDVectorArrangements maps the arrangement name to the actual value.')
cc.line('var SIMDVectorArrangements = map[string]SIMDVectorArrangement {')
cc.indent()
cc.line('"8b"  : Vec8B,')
cc.line('"16b" : Vec16B,')
cc.line('"4h"  : Vec4H,')
cc.line('"8h"  : Vec8H,')
cc.line('"2s"  : Vec2S,')
cc.line('"4s"  : Vec4S,')
cc.line('"1d"  : Vec1D,')
cc.line('"2d"  : Vec2D,')
cc.dedent()
cc.line('}')
cc.line()

cc.line('func (self SIMDVectorArrangement) q()    uint8 { return uint8(self & 1)  }')
cc.line('func (self SIMDVectorArrangement) size() uint8 { return uint8(self >> 1) }')
cc.line('func (self SIMDVectorArrangement) imm5() uint8 { return 1 << self.size() }')
cc.line()

cc.line('func (self SIMDVectorArrangement) String() string {')
cc.indent()
cc.line('switch self {')
cc.indent()
cc.line('case Vec8B  : return "8b"')
cc.line('case Vec16B : return "16b"')
cc.line('case Vec4H  : return "4h"')
cc.line('case Vec8H  : return "8h"')
cc.line('case Vec2S  : return "2s"')
cc.line('case Vec4S  : return "4s"')
cc.line('case Vec1D  : return "1d"')
cc.line('case Vec2D  : return "2d"')
cc.line('default     : panic("aarch64: invalid SIMD vector arrangement")')
cc.dedent()
cc.line('}')
cc.dedent()
cc.line('}')
cc.line()

cc.line('// SIMDVector1 represents an unarranged SIMD vector with a single register.')
cc.line('type SIMDVector1 [1]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector2 represents an unarranged SIMD vector with two registers that share the the same arrangement.')
cc.line('type SIMDVector2 [2]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector3 represents an unarranged SIMD vector with three registers that share the the same arrangement.')
cc.line('type SIMDVector3 [3]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector4 represents an unarranged SIMD vector with four registers that share the the same arrangement.')
cc.line('type SIMDVector4 [4]SIMDRegister128v')
cc.line()

for n in range(1, 5):
    ax = ', '.join('v%d' % i for i in range(n)).ljust(14)
    cc.line('func Vec%d(%s SIMDRegister128v) SIMDVector%d { return SIMDVector%d { %s } }' % (n, ax, n, n, ax))
else:
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%d) As(v SIMDVectorArrangement) SIMDVector%dr { return SIMDVector%dr { self, v } }' % (n, n, n))
else:
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%d) String() string {' % n)
    cc.indent()

    cc.line('return fmt.Sprintf("{ %s }", %s)' % (
        ', '.join(['%s'] * n),
        ', '.join('self[%d]' % i for i in range(n)))
    )

    cc.dedent()
    cc.line('}')
    cc.line()

cc.line('type (')
cc.indent()

for n in range(1, 5):
    cc.line('SIMDVector%dr struct { V SIMDVector%d; A SIMDVectorArrangement }' % (n, n))

cc.dedent()
cc.line(')')
cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%dr) String() string {' % n)
    cc.indent()

    cc.line('return fmt.Sprintf("{ %s }.%%s", %s, self.A)' % (
        ', '.join(['%s'] * n),
        ', '.join('self.V[%d]' % i for i in range(n)))
    )

    cc.dedent()
    cc.line('}')
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%dr) Arrangement() SIMDVectorArrangement { return self.A }' % n)

cc.line()
cc.line('type (')
cc.indent()

for i in range(5):
    cc.line('SIMDRegister%-3d  uint8' % (8 << i))

cc.line('SIMDRegister128v uint8')
cc.line('SIMDRegister128r uint8')
cc.dedent()
cc.line(')')
cc.line()

for i in range(5):
    cc.line('func (SIMDRegister%-4s  Sealed(tag.Tag) {}' % ('%d)' % (8 << i)))

cc.line('func (SIMDRegister128r) Sealed(tag.Tag) {}')
cc.line()

for i in range(5):
    cc.line('func (SIMDRegister%-4s  ItemWidth() uint8 { return %d }' % ('%d)' % (8 << i), 8 << i))

cc.line('func (SIMDRegister128r) ItemWidth() uint8 { return 128 }')
cc.line()

for i in range(5):
    cc.line('func (self SIMDRegister%-4s  ID() uint8 { return uint8(self) & 0b11111 }' % ('%d)' % (8 << i)))

cc.line('func (self SIMDRegister128r) ID() uint8 { return uint8(self) & 0b11111 }')
cc.line()

REG_PREFIX_TAB = [
    'B',
    'H',
    'S',
    'D',
    'Q',
]

for i in range(5):
    cc.line('func (self SIMDRegister%-4s  String() string { return fmt.Sprintf("%c%%d", self.ID()) }' % (
        '%d)' % (8 << i),
        REG_PREFIX_TAB[i].lower(),
    ))

cc.line('func (self SIMDRegister128v) String() string { return fmt.Sprintf("v%d", self) }')
cc.line('func (self SIMDRegister128r) String() string { return fmt.Sprintf("v%d.%s", self.ID(), self.Arrangement()) }')
cc.line()

cc.line('func (self SIMDRegister128v) As(v SIMDVectorArrangement) SIMDRegister128r {')
cc.indent()
cc.line('if self &^ 0b11111 != 0 {')
cc.indent()
cc.line('panic("aarch64: invalid unarranged vector register")')
cc.dedent()
cc.line('} else {')
cc.indent()
cc.line('return SIMDRegister128r(uint8(v) << 5 | uint8(self))')
cc.dedent()
cc.line('}')
cc.dedent()
cc.line('}')
cc.line()

cc.line('func (self SIMDRegister128r) Arrangement() SIMDVectorArrangement {')
cc.indent()
cc.line('return SIMDVectorArrangement(self >> 5)')
cc.dedent()
cc.line('}')
cc.line()

for i in range(5):
    cc.line('const (')
    cc.indent()
    cc.line('%s0 SIMDRegister%d = iota' % (REG_PREFIX_TAB[i], 8 << i))

    for j in range(1, 32):
        cc.line('%s%d' % (REG_PREFIX_TAB[i], j))

    cc.dedent()
    cc.line(')')
    cc.line()

cc.line('const (')
cc.indent()
cc.line('V0 SIMDRegister128v = iota')

for j in range(1, 32):
    cc.line('V%d' % j)

cc.dedent()
cc.line(')')
cc.line()

with open('arch/aarch64/registers_advsimd.go', 'w') as fp:
    fp.write('\n'.join(cc.buf))

### ---------- Instruction Encoding Classes ---------- ###

class Account:
    name: str
    desc: str

    def __init__(self, name: str, desc: str):
        self.name = name
        self.desc = desc

    def __repr__(self) -> str:
        return '%s %s' % (self.name, self.desc)

class Definition:
    name: str
    desc: str
    bits: dict[str, set[str]]

    def __init__(self, name: str, desc: str, bits: dict[str, set[str]]):
        self.name = name
        self.desc = desc
        self.bits = bits

    def __repr__(self) -> str:
        return '%s %s [%s]' % (self.name, self.desc, ' '.join(
            '%s=%s%s%s' % (
                key,
                '' if len(vals) == 1 else '{',
                ','.join(sorted(vals)),
                '' if len(vals) == 1 else '}'
            ) for key, vals in self.bits.items()
        ))

class Instruction:
    bits: list[int | None]
    refs: dict[str, tuple[int, int]]

    def __init__(self, other: 'Instruction | None' = None):
        if other is None:
            self.refs = {}
            self.bits = [None] * 32
        else:
            self.bits = other.bits[:]
            self.refs = dict(other.refs)

    def __repr__(self) -> str:
        char = 0
        mlen = 0
        refs = []
        bits = ['x' if v is None else str(v) for v in self.bits]

        for v in self.refs:
            mlen = max(mlen, len(v))

        bits.extend(' ' * mlen)
        bits.extend('  ')

        for p, n in self.refs.values():
            char += 1
            bits[p:p + n] = [
                '\x1b[3%dm%s\x1b[0m' % (char % 5 + 1, 'x' if v is None else v)
                for v in self.bits[p:p + n]
            ]

        vals = list(self.refs.items())
        vals.sort(key = lambda x: x[1], reverse = True)

        for i, (v, (p, n)) in enumerate(vals):
            line = list(v[::-1].rjust(mlen + 34))
            line[p + n // 2] = '┘'
            line[p + n // 2 + 1:33] = '─' * (32 - p - n // 2)

            for i in range(len(refs)):
                refs[i][p + n // 2] = '│'
            else:
                refs.append(line)

        return '\n'.join([
            ''.join(bits[::-1]),
            *(''.join(v[::-1]) for v in refs),
        ])

    def update(self, boxes: list[Element]):
        for box in boxes:
            hibit = int(box.attrib['hibit'])
            width = int(box.attrib.get('width', 1))

            if box.attrib.get('usename') == '1':
                self.refs[box.attrib['name']] = (hibit - width + 1, width)
                continue

            for i, item in enumerate(box.findall('c')):
                assert item.text in {'0', '1'}, 'invalid cell value: ' + repr(item.text)
                self.bits[hibit - i] = int(item.text)

class EncodingTabEntry(NamedTuple):
    name: str
    desc: str
    form: str
    file: str
    func: str
    bits: Instruction

    def __repr__(self) -> str:
        return '\n'.join([
            'Encoding %s {' % self.name,
            '    ' + self.desc,
            '    form = ' + self.form,
            '    file = ' + self.file,
            '    func = ' + self.func,
            *('    ' + v for v in repr(self.bits).splitlines()),
            '}',
        ])

class InstructionTabEntry(NamedTuple):
    name: str
    desc: str
    data: Element
    base: Instruction

    def __repr__(self) -> str:
        return '\n'.join([
            'Instruction %s {' % self.name,
            '    ' + self.desc,
            *('    ' + v for v in repr(self.base).splitlines()),
            '}',
        ])

def parse_bit(bit: str) -> int | None:
    match bit:
        case '0': return 0
        case '1': return 1
        case 'x': return None
        case _  : raise AssertionError('invalid bit value: ' + repr(bit))

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()

enctab = dict[str, EncodingTabEntry]()
instab = dict[str, InstructionTabEntry]()

isadocs = ElementTree.parse(os.path.join(sys.argv[1], 'onebigfile.xml')).getroot()
encindex = isadocs.find('.//encodingindex')
assert encindex is not None, 'invalid encoding index file'

for iclass in sorted(encindex.findall('iclass_sect'), key = lambda x: x.attrib['id']):
    name = iclass.attrib['id']
    desc = iclass.attrib['title']
    itab = iclass.find('instructiontable')

    # TODO: support SVE instructions sometime in the future
    if name.startswith('sve_'):
        continue

    assert itab is not None, 'missing instruction table for ' + name
    assert itab.attrib['iclass'] == name, 'wrong instruction table iclass for ' + name
    status('* Instruction Class:', name)

    bits = Instruction()
    bits.update(iclass.findall('regdiagram/box'))

    cond = set()
    vals = bits.bits[:]
    args = sorted(bits.refs.items(), key = lambda x: x[1], reverse = True)

    for dc in iclass.findall('decode_constraints/decode_constraint'):
        cond.add((
            dc.attrib['name'],
            dc.attrib['op'],
            dc.attrib['val'],
        ))

    for p, n in bits.refs.values():
        vals[p:p + n] = [0] * n

    instab[name] = InstructionTabEntry(
        name = name,
        desc = desc,
        data = itab,
        base = bits,
    )

    cc.line('// %s: %s' % (name, desc))
    cc.line('func %s(%s uint32) uint32 {' % (name, ', '.join(v for v, _ in args)))
    cc.indent()

    for th, (_, n) in args:
        cc.line('if %s &^ 0b%s != 0 {' % (th, '1' * n))
        cc.indent()
        cc.line('panic("%s: invalid %s")' % (name, th))
        cc.dedent()
        cc.line('}')

    for key, op, val in sorted(cond):
        assert op == '!=', 'decode constraint is not implemented: %s %s %s' % (key, op, val)
        cc.line('if %s == 0b%s {' % (key, val))
        cc.indent()
        cc.line('panic("%s: decode constraint is not satisfied: %s %s %s")' % (name, key, op, val))
        cc.dedent()
        cc.line('}')

    assert None not in vals, 'unset bit in %s: %r' % (name, vals)
    cc.line('ret := uint32(0x%08x)' % int(''.join(map(str, vals))[::-1], 2))

    for th, (p, _) in args:
        if p == 0:
            cc.line('ret |= ' + th)
        else:
            cc.line('ret |= %s << %d' % (th, p))

    cc.line('return ret;')
    cc.dedent()
    cc.line('}')
    cc.line()

with open('arch/aarch64/encodings.go', 'w') as fp:
    fp.write('\n'.join(cc.buf))

for name, entry in sorted(instab.items(), key = lambda v: v[0]):
    keys = []
    itab = entry.data

    for th in itab.findall('thead/tr[@id="heading2"]/th[@class="bitfields"]'):
        assert th.text, 'missing field name for ' + name
        keys.append(th.text)

    for th in itab.findall('tbody/tr[@class="instructiontable"]'):
        if th.attrib.get('undef') != '1':
            encname   = th.attrib['encname']
            iformfile = th.attrib['iformfile']
            iformname = th.find('td[@class="iformname"]')
            bitfields = th.findall('td[@class="bitfield"]')

            # TODO: remove this
            # if encname != 'CASPAL_CP32_ldstexcl':
            # if iformfile != 'add_addsub_imm.xml':
            #     continue

            assert iformfile, 'missing iform files for ' + name
            assert iformname is not None, 'missing iform names for ' + name
            assert len(bitfields) == len(keys), 'mismatched bitfields for %s.%s' % (name, encname)

            desc = iformname.text
            form = iformname.attrib['iformid']
            assert desc and form, 'missing form or description for %s.%s' % (name, encname)

            bits = []
            instr = Instruction(entry.base)

            for field in bitfields:
                if not field.text or field.text.startswith('!='):
                    bits.append(None)
                else:
                    bits.append(list(map(parse_bit, field.text[::-1])))

            for key, vals in zip(keys, bits):
                if vals is not None:
                    p, n = instr.refs[key]
                    assert len(vals) == n, 'mismatched bits for %s.%s.%s' % (name, encname, key)
                    instr.bits[p:p + n] = vals

            enc = EncodingTabEntry(
                name = encname,
                desc = desc,
                form = form,
                file = iformfile,
                func = name,
                bits = instr,
            )

            assert encname not in enctab, 'duplicated encoding name %s.%s' % (name, encname)
            status('* Encoding Table Entry: %s.%s' % (name, encname))
            enctab[encname] = enc

### ---------- Instruction Assembly Template ---------- ###

class Op(Enum):
    LSL  = 'lsl'
    MSL  = 'msl'
    LSR  = 'lsr'
    ASR  = 'asr'
    UXTB = 'uxtb'
    UXTH = 'uxth'
    UXTW = 'uxtw'
    UXTX = 'uxtx'
    SXTB = 'sxtb'
    SXTH = 'sxth'
    SXTW = 'sxtw'
    SXTX = 'sxtx'

class Sym(Enum):
    CSYNC  = 'CSYNC'
    PRFOP  = 'prfop'
    OPTION = 'option'
    SYSREG = 'systemreg'

class Tag(str):
    def __str__(self) -> str:
        return '=' + self

    def __repr__(self) -> str:
        return 'Tag(%s)' + super().__repr__()

class Imm(str):
    def __str__(self) -> str:
        return '#' + self

    def __repr__(self) -> str:
        return 'Imm(%s)' % super().__repr__()

class Lit:
    ty  : type
    val : object

    def __init__(self, v: object):
        self.ty  = type(v)
        self.val = v

    def __str__(self) -> str:
        return '#%s' % self.val

    def __repr__(self) -> str:
        return 'Lit(%s: %s)' % (self.val, self.ty)

class Reg(NamedTuple):
    name: str
    altr: str | None = None
    size: str | None = None
    mode: str | Tag | None = None
    vidx: Imm | Lit | None = None

    def __str__(self) -> str:
        if self.size is not None:
            assert self.altr is None
            assert self.mode is None
            assert self.vidx is None
            return '%s[%s]' % (self.size, self.name)
        elif self.mode is not None and self.vidx is not None:
            assert self.altr is None
            return '%s.%s[%s]' % (self.name, self.mode, self.vidx)
        elif self.mode is not None:
            assert self.altr is None
            return '%s.%s' % (self.name, self.mode)
        elif self.altr is not None:
            assert self.vidx is None
            return '(%s|%s)' % (self.name, self.altr)
        else:
            return self.name

class Vec(NamedTuple):
    mode: str | Tag
    regs: list[str]
    vidx: Imm | Lit | None = None

    def __str__(self) -> str:
        return '{ %s }.%s%s' % (
            ', '.join(self.regs),
            self.mode,
            '' if self.vidx is None else '[%s]' % self.vidx
        )

class Mod(NamedTuple):
    mod: str | Op
    imm: tuple[Imm | Lit, bool] | None = None

    def name(self) -> str:
        if isinstance(self.mod, str):
            return self.mod
        else:
            return self.mod.name

    def __str__(self) -> str:
        if self.imm is None:
            return self.name()
        elif not self.imm[1]:
            return '%s %s' % (self.name(), self.imm[0])
        else:
            return '%s {%s}' % (self.name(), self.imm[0])

class Mem(NamedTuple):
    base   : Reg
    offs   : tuple[Reg | Imm | Lit, bool] | None = None
    index  : Literal['pre', 'post'] | None       = None
    extend : tuple[Mod, bool] | None             = None

    def __str__(self) -> str:
        ret = []
        ret.append('[')
        ret.append(self.base)

        if self.offs and self.index != 'post':
            v, o = self.offs
            ret.append('%s, %s%s' % ('{' if o else '', str(v), '}' if o else ''))

        if self.extend:
            v, o = self.extend
            ret.append('%s, %s%s' % ('{' if o else '', str(v), '}' if o else ''))

        match self.index:
            case 'pre':
                assert self.offs, 'missing index for pre index'
                ret.append(']!')

            case 'post':
                assert self.offs, 'missing index for post index'
                v, o = self.offs
                ret.append(']%s+%s%s' % ('{' if o else '', str(v), '}' if o else ''))

            case v:
                ret.append(']')
                assert v is None

        return ''.join(
            str(v)
            for v in ret
        )

class Seq(NamedTuple):
    req: list[Reg | Vec | Mem | Mod | Imm | Lit | Sym]
    opt: Reg | Vec | Mem | Mod | Imm | Lit | Sym | None = None

    def __str__(self) -> str:
        return ''.join(
            '%s%s' % (', ' if i else '', str(v))
            for i, v in enumerate(self.req + [self.opt])
            if v is not None
        )

class Instr(NamedTuple):
    mnemonic: str
    operands: Seq
    modifier: str | None

    def __str__(self) -> str:
        return ''.join([
            self.mnemonic,
            '{%s}' % self.modifier if self.modifier else '',
            ' ' if self.operands.req or self.operands.opt is not None else '',
            str(self.operands)
        ])

class Token(NamedTuple):
    name: str
    text: str

    def __repr__(self) -> str:
        return '\x1b[31m{%s}\x1b[0m' % self.name

    @classmethod
    def parse(cls, item: Element) -> 'Token':
        return cls(
            text = item.text or '',
            name = item.attrib['link'],
        )

class AsmTemplate:
    pos: int
    buf: list[str | Token]

    ops = {
        v.name
        for v in Op
    }

    amounts = {
        'amount',
        'amount_1',
        'amount_2',
        'amount_3',
        'amount_4',
        'shift',
        'shift_1',
        'shift_2',
        'shift_3',
    }

    registers = {
        'd',
        'm',
        'n',
        't',
    }

    modifiers = {
        'shift',
        'extend',
        'extend_1',
    }

    immediates = {
        'imm',
        'imm_1',
        'imm_2',
        'imm_3',
    }

    predefined = {
        'CSYNC': (
            Sym.CSYNC,
            'CSYNC option',
            []
        ),
        'prfop': (
            Sym.PRFOP,
            'prefetch option',
            ['|', '#', 'imm5']
        ),
        'option': (
            Sym.OPTION,
            'barrier option',
            ['|', '#', 'imm']
        ),
        'systemreg': (
            Sym.SYSREG,
            'system register',
            ['|', 'S', 'op0', '_', 'op1', '_', 'cn', '_', 'cm', '_', 'op2']
        ),
    }

    for v in Sym:
        assert v.value in predefined

    def __init__(self, tok: list[str | Token]):
        self.pos = 0
        self.buf = tok

    @property
    def eof(self) -> bool:
        return self.pos >= len(self.buf)

    @property
    def tok(self) -> str | Token:
        if self.eof:
            raise SyntaxError('unexpected EOF')
        else:
            return self.buf[self.pos]

    def next(self) -> str | Token:
        ret = self.tok
        self.pos += 1
        return ret

    def must(self, tok: str):
        if self.next() != tok:
            raise SyntaxError('"%s" expected' % tok)

    def skip(self, tok: str) -> bool:
        if self.eof or self.buf[self.pos] != tok:
            return False
        else:
            self.pos += 1
            return True

    def dsym(self, name: str) -> Sym:
        tok = []
        sym, msg, mat = self.predefined[name]

        for _ in mat:
            v = self.next()
            tok.append(v.name if isinstance(v, Token) else v)

        if tok != mat:
            raise SyntaxError('invalid %s: %r' % (msg, name))
        else:
            return sym

    def value(self) -> Reg | Vec | Mem | Mod | Imm | Lit | Sym:
        match self.next():
            case '#':
                match self.next():
                    case '0.0'                                   : return Lit(0.0)
                    case v if isinstance(v, str) and v.isdigit() : return Lit(int(v))
                    case v if isinstance(v, Token)               : return Imm(v.name)
                    case v                                       : raise SyntaxError('integer or token expected')

            case '(':
                reg = self.next()
                tab = self.predefined

                if not isinstance(reg, Token):
                    raise SyntaxError('register token expected')

                if reg.name in tab:
                    ret = self.dsym(reg.name)
                    self.must(')')
                    return ret

                self.must('|')
                tok = self.next()

                if not isinstance(tok, Token):
                    raise SyntaxError('register token expected')

                ret = Reg(reg.name, altr = tok.name)
                self.must(')')
                return ret

            case '[':
                buf = self.vlist()
                self.must(']')

                if not buf.req:
                    raise SyntaxError('invalid memory operand')

                idx = 'pre' if self.skip('!') else None
                args = [(v, bool(True)) for v in buf.req]

                if buf.opt is not None:
                    args.append((buf.opt, False))

                exts = None
                offs = None
                base = args[0][0]

                if not isinstance(base, Reg):
                    raise SyntaxError('memory base must be a register')

                if len(args) >= 2:
                    if not isinstance(args[1][0], (Reg, Imm, Lit)):
                        raise SyntaxError('memory offset must be a register or an immediate value')
                    else:
                        offs = (args[1][0], args[1][1])

                if len(args) >= 3:
                    if not isinstance(args[2][0], Mod):
                        raise SyntaxError('memory offset extension must be an extension')
                    else:
                        exts = (args[2][0], args[2][1])

                if len(args) >= 4:
                    raise SyntaxError('too many argumnets for memory operand')

                return Mem(
                    base   = base,
                    offs   = offs,
                    index  = idx,
                    extend = exts,
                )

            case '{{':
                regs = []
                mode = None
                vidx = None

                while True:
                    reg = self.next()
                    self.must('.')

                    if not isinstance(reg, Token):
                        raise SyntaxError('invalid vector element')

                    tok = self.next()
                    tag = Tag(tok) if isinstance(tok, str) else tok.name

                    if mode != tag and mode is not None:
                        raise SyntaxError('mode confliction within vector')

                    mode = tag
                    regs.append(reg.name)

                    match self.next():
                        case ','  : pass
                        case '}}' : break
                        case _    : raise SyntaxError('"," or "}" expected')

                if self.skip('['):
                    vidx = self.next()
                    vidx = Imm(vidx.name) if isinstance(vidx, Token) else Lit(int(vidx))
                    self.must(']')

                return Vec(
                    mode = mode,
                    regs = regs,
                    vidx = vidx,
                )

            case v if isinstance(v, str) and v in self.predefined:
                return self.dsym(v)

            case v if isinstance(v, Token) and v.name in self.immediates:
                return Imm(v.name)

            case v if isinstance(v, Token) and v.name in self.predefined:
                return self.dsym(v.name)

            case v if isinstance(v, Token) and v.name not in self.modifiers:
                mode = None
                size = None
                vidx = None
                name = v.name

                if not self.eof:
                    if self.skip('.'):
                        mode = self.next()
                        mode = Tag(mode) if isinstance(mode, str) else mode.name

                        if self.skip('['):
                            vidx = self.next()
                            vidx = Imm(vidx.name) if isinstance(vidx, Token) else Lit(int(vidx))
                            self.must(']')

                    elif isinstance(self.tok, Token) and self.tok.name in self.registers:
                        size = v.name
                        name = self.tok.name
                        self.next()

                return Reg(
                    name = name,
                    mode = mode,
                    size = size,
                    vidx = vidx,
                )

            case v:
                opt = False
                mod = v.name if isinstance(v, Token) else v

                if mod not in (self.ops if isinstance(v, str) else self.modifiers):
                    raise SyntaxError('unexpected token: ' + repr(v))

                if self.tok == '{':
                    opt = True
                    self.next()

                if self.tok == '#':
                    imm = self.value()
                elif isinstance(self.tok, Token):
                    imm = Imm(cast(Token, self.next()).name)
                else:
                    imm = None

                if opt and self.next() != '}':
                    raise SyntaxError('"}" expected')

                if imm is not None and not isinstance(imm, Lit):
                    if not isinstance(imm, Imm) or not imm in self.amounts:
                        raise SyntaxError('invalid extension immediate')

                if mod in self.ops:
                    mod = Op(mod.lower())

                if imm is None:
                    return Mod(mod)
                else:
                    return Mod(mod, (imm, opt))

    def vlist(self) -> Seq:
        req = []
        opt = None

        if not self.eof and self.tok != '{':
            val = self.value()
            req.append(val)

            while self.skip(','):
                val = self.value()
                mem = req[-1] if req else None

                if not isinstance(mem, Mem):
                    req.append(val)
                elif not isinstance(val, (Reg, Imm, Lit)):
                    req.append(val)
                elif mem.offs is not None or mem.index is not None:
                    req.append(val)
                else:
                    req[-1] = Mem(mem.base, (val, False), 'post', mem.extend)

        if self.skip('{'):
            if req:
                self.must(',')

            opt = self.value()
            self.must('}')

        return Seq(
            req = req,
            opt = opt,
        )

    def instr(self) -> Instr:
        mods = None
        args = Seq([])
        name = self.next()

        if not isinstance(name, str):
            raise SyntaxError('mnemonic expected')

        if not self.eof:
            match self.tok:
                case '.' if name == 'B':
                    self.next()
                    cond = self.next()

                    if not isinstance(cond, Token):
                        raise SyntaxError('branch condition expected')
                    else:
                        mods = cond.name

                case v if isinstance(v, Token) and v.name == '2':
                    mods = '2'
                    self.next()

                case v if isinstance(v, Token) and v.name == 'bt' and name == 'BFMLAL':
                    mods = 'bt'
                    self.next()

        if not self.eof:
            args = self.vlist()

        if not self.eof:
            raise SyntaxError('junk after instruction: ' + str(self.next()))

        return Instr(
            mnemonic = name,
            operands = args,
            modifier = mods,
        )

    class Lexer:
        buf   : str
        sbuf  : str
        items : list[Element]

        def __init__(self, items: list[Element]):
            self.buf   = ''
            self.sbuf  = ''
            self.items = items

        def __iter__(self) -> Iterator[str | Token]:
            for item in self.items:
                match item.tag:
                    case 'a':
                        yield from self._parse_text()
                        yield Token.parse(item)
                        self.buf = ''

                    case 'text':
                        if item.text:
                            self.buf += item.text

                    case _:
                        raise AssertionError('unexpected tag in assembly template: ' + repr(item.tag))

            yield from self._parse_text()
            self.buf = ''

        def _parse_dots(self) -> Iterator[str]:
            if self.sbuf:
                if self.sbuf == '.' or self.sbuf[-1] != '.':
                    yield self.sbuf
                else:
                    yield self.sbuf[:-1]
                    yield self.sbuf[-1]

        def _parse_text(self) -> Iterator[str]:
            for i, ch in enumerate(self.buf):
                if ch.isalnum() or ch == '_' or (self.sbuf and ch == '.'):
                    self.sbuf += ch
                    continue

                yield from self._parse_dots()
                self.sbuf = ''

                if not ch.isspace():
                    if ch == '}' and i != 0 and self.buf[i - 1].isspace():
                        yield '}}'
                    elif ch == '{' and i != len(self.buf) - 1 and self.buf[i + 1].isspace():
                        yield '{{'
                    else:
                        yield ch

            yield from self._parse_dots()
            self.sbuf = ''

    @classmethod
    def parse(cls, items: list[Element]) -> Instr:
        return cls(list(cls.Lexer(items))).instr()

class InstrForm(NamedTuple):
    text   : str
    inst   : Instr
    bits   : Instruction
    opts   : dict[str, str]
    args   : list[str | int]
    enctab : EncodingTabEntry
    fields : dict[str, Account | Definition]

def permu_bits(bit: str) -> str:
    match bit:
        case '0': return '0'
        case '1': return '1'
        case 'x': return '01'
        case _  : raise AssertionError('invalid bit value: ' + repr(bit))

def parse_props(out: dict[str, str], p: Element):
    for v in p.findall('docvars/docvar'):
        out[v.attrib['key']] = v.attrib['value']

def parse_boxes(ins: Instruction, boxes: list[Element]):
    for box in boxes:
        boxes = box.findall('c')
        hibit = int(box.attrib['hibit'])

        for i, item in enumerate(boxes):
            if item.text == '0':
                assert ins.bits[hibit - i] != 1, 'bit confiction: 0'
                ins.bits[hibit - i] = 0
            elif item.text == '1':
                assert ins.bits[hibit - i] != 0, 'bit confiction: 1'
                ins.bits[hibit - i] = 1
            else:
                assert item.text in {None, '', 'x', 'z', 'N', 'Z'}, \
                    'invalid cell value: ' + repr(item.text)

def parse_symdef(defs: Element) -> dict[str, set[str]]:
    rets = {}
    tabs = defs.findall('.//tgroup')
    rows = defs.findall('.//tbody/row')
    dest = defs.attrib['encodedin']

    if len(tabs) != 1:
        raise AssertionError('expect exactly 1 table: encodedin="%s"' % dest)

    for row in rows:
        bits = []
        syms = row.find('entry[@class="symbol"]')

        for bv in row.findall('entry[@class="bitfield"]'):
            if not bv.text:
                raise AssertionError('missing symbol or bitfield: encodedin="%s"' % dest)
            else:
                bits.append(bv.text)

        if not bits or syms is None or not syms.text:
            raise AssertionError('missing symbol or bitfield: encodedin="%s"' % dest)

        for sym in map(str.strip, syms.text.split('|')):
            prod = itertools.product(*map(permu_bits, ''.join(bits)))
            rets.setdefault(sym, set()).update(''.join(v) for v in prod)

    if not rets:
        raise AssertionError('missing definitions: encodedin="%s"' % dest)
    else:
        return rets

maxargs = 0
formtab = dict[str, list[InstrForm]]()
fieldtab = dict[str, dict[str, Account | Definition]]()

for expl in isadocs.findall('.//explanation'):
    symbol = expl.find('symbol')
    symacc = expl.find('account')
    symdef = expl.find('definition')

    if symbol is None or (symacc is None) is (symdef is None):
        raise AssertionError('invalid explanation')

    desc = symbol.text or ''
    name = symbol.attrib['link']
    status('* Field Explanation:', name)

    if symacc is not None:
        assert symdef is None
        defs = Account(symacc.attrib['encodedin'], desc)
    else:
        assert isinstance(symdef, Element)
        defs = Definition(symdef.attrib['encodedin'], desc, parse_symdef(symdef))

    for enc in expl.attrib['enclist'].split(','):
        tab = fieldtab.setdefault(enc.strip(), {})
        tab[name] = defs

for encdata in sorted(enctab.values(), key = lambda x: x.name):
    node = isadocs.find('.//iclass/encoding[@name="%s"]' % encdata.name)
    assert node is not None, 'encoding %s does not exists' % repr(encdata.name)

    tokens = node.findall('asmtemplate/*')
    assert tokens, 'encoding %s does not have an assembly syntax' % repr(encdata.name)

    text = ''.join(v.text or '' for v in tokens)
    status('* Assembly Template:', text)

    args = []
    opts = {}
    bits = Instruction(encdata.bits)
    inst = AsmTemplate.parse(tokens)

    parse_props(opts, node)
    parse_boxes(bits, node.findall('box'))
    assert inst.mnemonic == opts['mnemonic']

    if inst.operands.opt is None:
        maxargs = max(maxargs, len(inst.operands.req))
    else:
        maxargs = max(maxargs, len(inst.operands.req) + 1)

    vals = list(bits.refs.items())
    vals.sort(key = lambda x: x[1], reverse = True)

    for v, (p, n) in vals:
        if None in bits.bits[p:p + n]:
            args.append(v)
        else:
            args.append(int(''.join(map(str, bits.bits[p:p + n])), 2))

    formtab.setdefault(inst.mnemonic, []).append(InstrForm(
        text   = text,
        inst   = inst,
        bits   = bits,
        opts   = opts,
        args   = args,
        enctab = encdata,
        fields = fieldtab.get(encdata.name, {})
    ))

### ---------- Per-instruction Encoding ---------- ###

class Or(list['And | Or | str']):
    def __init__(self, *terms: 'And | Or | str'):
        super().__init__(terms)

    def __str__(self) -> str:
        return ' || '.join(str(v) for v in self)

class And(list['And | Or | str']):
    def __init__(self, *terms: 'And | Or | str'):
        super().__init__(terms)

    def __str__(self) -> str:
        if len(self) == 1 and isinstance(self[0], Or):
            return str(self[0])
        else:
            return ' && '.join('(%s)' % str(v) if isinstance(v, Or) else str(v) for v in self)

REG_CHECKS = {
    'xd_sp'  : 'isXrOrSP',
    'xn_sp'  : 'isXrOrSP',
    'wd_wsp' : 'isWrOrWSP',
    'wn_wsp' : 'isWrOrWSP',
}

def match_operand(inst: Instr, argc: int) -> Iterator[str]:
    for val in inst.operands:
        print(repr(val), val)

        if isinstance(val, Reg):
            print(REG_CHECKS[val.name])
            if val.size is not None:
                print('%s[%s]' % (val.size, val.name))
            elif val.mode is not None and val.vidx is not None:
                print('%s.%s[%s]' % (val.name, val.mode, val.vidx))
            elif val.mode is not None:
                print('%s.%s' % (val.name, val.mode))
            elif val.altr is not None:
                print('(%s|%s)' % (val.name, val.altr))
            else:
                print(val.name)

        elif isinstance(val, Vec):
            pass
        elif isinstance(val, Mem):
            pass
        elif isinstance(val, Mod):
            pass
        elif isinstance(val, Imm):
            pass
        elif isinstance(val, Lit):
            pass
        else:
            pass

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()
cc.line('const (')
cc.indent()
cc.line('_N_args  = %d' % maxargs)
cc.line('_N_forms = %d' % max(len(v) for v in formtab.values()))
cc.dedent()
cc.line(')')
cc.line()

for name, forms in sorted(formtab.items(), key = lambda x: x[0]):
    argc = set()
    status('* Instruction:', name)

    if len(forms) == 1:
        cc.line('// %s instruction have a single form:' % name)
        cc.line('//')
    else:
        cc.line('// %s instruction have a %s forms:' % (name, len(forms)))
        cc.line('//')

    for form in forms:
        nop = len(form.inst.operands.req)
        argc.add(nop)

        if form.inst.operands.opt is not None:
            argc.add(nop + 1)

        cc.line('//   * %s' % form.text)

    fixed = min(argc)
    fargs = ', '.join('v%d' % i for i in range(fixed))

    if fixed == max(argc):
        cc.line('func (self *Program) %s(%s interface{}) *Instruction {' % (name, fargs))
        cc.indent()

    else:
        cc.line('func (self *Program) %s(%s interface{}, vv ...interface{}) *Instruction {' % (name, fargs))
        cc.indent()
        cc.line('var p *Instruction')

    cc.line('return p')
    cc.dedent()
    cc.line('}')
    cc.line()

with open('arch/aarch64/instructions.go', 'w') as fp:
    fp.write('\n'.join(cc.buf))

# data = ElementTree.parse(os.path.join(sys.argv[1], 'onebigfile.xml'))
# instrs = data.findall('.//sect1[@id="iformpages"]//file/instructionsection[@type="instruction"]')

# for instr in instrs:
#     opts = {}
#     fields = {}

#     print('>>>>> %(id)s: %(title)s' % instr.attrib)
#     parse_props(opts, instr)

#     # TODO: implement SVE instructions
#     if opts.get('instr-class') == 'sve':
#         continue

#     for expl in instr.findall('explanations/explanation'):
#         symbol = expl.find('symbol')
#         symacc = expl.find('account')
#         symdef = expl.find('definition')

#         if symbol is None or (symacc is None) is (symdef is None):
#             raise AssertionError('invalid explanation')

#         desc = symbol.text or ''
#         name = symbol.attrib['link']

#         if symacc is not None:
#             assert symdef is None
#             defs = Account(symacc.attrib['encodedin'], desc)
#         else:
#             assert isinstance(symdef, Element)
#             defs = Definition(symdef.attrib['encodedin'], desc, parse_symdef(symdef))

#         for enc in expl.attrib['enclist'].split(','):
#             tab = fields.setdefault(enc.strip(), {})
#             tab[name] = defs

#     # # TODO: remove this
#     if 'CASPAL_CP32_ldstexcl' not in fields:
#         continue

#     for iclass in instr.findall('classes/iclass'):
#         attrs = dict(opts)
#         proto = Instruction(insdata.bits)

#         parse_props(attrs, iclass)
#         parse_boxes(proto, iclass.findall('regdiagram/box'))

#         for encoding in iclass.findall('encoding'):
#             props = dict(attrs)
#             instr = Instruction(proto)
#             lexer = TokenStream.parse(encoding.attrib['name'], encoding.findall('asmtemplate/*'))

#             parse_props(props, encoding)
#             parse_boxes(instr, encoding.findall('box'))

#             print('-------- %s --------' % lexer.name)
#             print('Mnemonic :', props['mnemonic'])
#             print('Syntax   :', ' '.join(map(repr, lexer)))
#             import pprint
#             print('Fields   :', end = ' ')
#             pprint.pprint(fields.get(lexer.name, {}), compact = True, sort_dicts = True)
#             print('Encoding :')
#             print(instr)
#             print()
