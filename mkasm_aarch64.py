#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import itertools

from typing import cast
from typing import Literal
from typing import Iterator
from typing import NamedTuple

from enum import Enum
from xml.etree import ElementTree
from xml.etree.ElementTree import Element

class CodeGen:
    def __init__(self):
        self.buf = []
        self.level = 0

    @property
    def src(self) -> str:
        return '\n'.join(self.buf)

    def line(self, src: str = ''):
        self.buf.append(' ' * (self.level * 4) + src)

    def dedent(self):
        self.level -= 1

    def indent(self):
        self.level += 1

### ---------- Advanced SIMD Registers ---------- ###

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()
cc.line("import (")
cc.indent()
cc.line("`fmt`")
cc.dedent()
cc.line(")")
cc.line()
cc.line('// SIMDVector represents a SIMD vector.')
cc.line('type SIMDVector interface {')
cc.indent()
cc.line('String() string')
cc.line('Arrangement() SIMDVectorArrangement')
cc.dedent()
cc.line('}')
cc.line()
cc.line('// SIMDRegister represents an Advanced SIMD hardware register.')
cc.line('type SIMDRegister interface {')
cc.indent()
cc.line('Register')
cc.line('Bits() uint8')
cc.dedent()
cc.line('}')
cc.line()

cc.line('// SIMDVectorArrangement represents the data arrangement of a V register.')
cc.line('type SIMDVectorArrangement uint8')
cc.line()

cc.line('const (')
cc.indent()
cc.line('Vec8B  SIMDVectorArrangement = 0b000')
cc.line('Vec16B SIMDVectorArrangement = 0b001')
cc.line('Vec4H  SIMDVectorArrangement = 0b010')
cc.line('Vec8H  SIMDVectorArrangement = 0b011')
cc.line('Vec2S  SIMDVectorArrangement = 0b100')
cc.line('Vec4S  SIMDVectorArrangement = 0b101')
cc.line('Vec1D  SIMDVectorArrangement = 0b110')
cc.line('Vec2D  SIMDVectorArrangement = 0b111')
cc.dedent()
cc.line(')')
cc.line()

cc.line('// SIMDVectorArrangements maps the arrangement name to the actual value.')
cc.line('var SIMDVectorArrangements = map[string]SIMDVectorArrangement {')
cc.indent()
cc.line('"8b"  : Vec8B,')
cc.line('"16b" : Vec16B,')
cc.line('"4h"  : Vec4H,')
cc.line('"8h"  : Vec8H,')
cc.line('"2s"  : Vec2S,')
cc.line('"4s"  : Vec4S,')
cc.line('"1d"  : Vec1D,')
cc.line('"2d"  : Vec2D,')
cc.dedent()
cc.line('}')
cc.line()

cc.line('func (self SIMDVectorArrangement) q()    uint8 { return uint8(self & 1)  }')
cc.line('func (self SIMDVectorArrangement) size() uint8 { return uint8(self >> 1) }')
cc.line('func (self SIMDVectorArrangement) imm5() uint8 { return 1 << self.size() }')
cc.line()

cc.line('func (self SIMDVectorArrangement) String() string {')
cc.indent()
cc.line('switch self {')
cc.indent()
cc.line('case Vec8B  : return "8b"')
cc.line('case Vec16B : return "16b"')
cc.line('case Vec4H  : return "4h"')
cc.line('case Vec8H  : return "8h"')
cc.line('case Vec2S  : return "2s"')
cc.line('case Vec4S  : return "4s"')
cc.line('case Vec1D  : return "1d"')
cc.line('case Vec2D  : return "2d"')
cc.line('default     : panic("aarch64: invalid SIMD vector arrangement")')
cc.dedent()
cc.line('}')
cc.dedent()
cc.line('}')
cc.line()

cc.line('// SIMDVector1 represents an unarranged SIMD vector with a single register.')
cc.line('type SIMDVector1 [1]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector2 represents an unarranged SIMD vector with two registers that share the the same arrangement.')
cc.line('type SIMDVector2 [2]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector3 represents an unarranged SIMD vector with three registers that share the the same arrangement.')
cc.line('type SIMDVector3 [3]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector4 represents an unarranged SIMD vector with four registers that share the the same arrangement.')
cc.line('type SIMDVector4 [4]SIMDRegister128v')
cc.line()

for n in range(1, 5):
    ax = ', '.join('v%d' % i for i in range(n)).ljust(14)
    cc.line('func Vec%d(%s SIMDRegister128v) SIMDVector%d { return SIMDVector%d { %s } }' % (n, ax, n, n, ax))
else:
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%d) As(v SIMDVectorArrangement) SIMDVector%dr { return SIMDVector%dr { self, v } }' % (n, n, n))
else:
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%d) String() string {' % n)
    cc.indent()

    cc.line('return fmt.Sprintf("{ %s }", %s)' % (
        ', '.join(['%s'] * n),
        ', '.join('self[%d]' % i for i in range(n)))
    )

    cc.dedent()
    cc.line('}')
    cc.line()

cc.line()
cc.line('type (')
cc.indent()

for n in range(1, 5):
    cc.line('SIMDVector%dr struct { V SIMDVector%d; A SIMDVectorArrangement }' % (n, n))

cc.dedent()
cc.line(')')
cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%dr) String() string {' % n)
    cc.indent()

    cc.line('return fmt.Sprintf("{ %s }.%%s", %s, self.A)' % (
        ', '.join(['%s'] * n),
        ', '.join('self.V[%d]' % i for i in range(n)))
    )

    cc.dedent()
    cc.line('}')
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%dr) Arrangement() SIMDVectorArrangement { return self.A }' % n)

cc.line()
cc.line('type (')
cc.indent()

for i in range(5):
    cc.line('SIMDRegister%-3d  uint8' % (8 << i))

cc.line('SIMDRegister128v uint8')
cc.line('SIMDRegister128r uint8')
cc.dedent()
cc.line(')')
cc.line()

for i in range(5):
    cc.line('func (SIMDRegister%-4s  Bits() uint8 { return %d }' % ('%d)' % (8 << i), 8 << i))

cc.line('func (SIMDRegister128r) Bits() uint8 { return 128 }')
cc.line()

for i in range(5):
    cc.line('func (self SIMDRegister%-4s  ID() uint8 { return uint8(self) & 0b11111 }' % ('%d)' % (8 << i)))

cc.line('func (self SIMDRegister128r) ID() uint8 { return uint8(self) & 0b11111 }')
cc.line()

REG_PREFIX_TAB = [
    'B',
    'H',
    'S',
    'D',
    'Q',
]

for i in range(5):
    cc.line('func (self SIMDRegister%-4s  String() string { return fmt.Sprintf("%c%%d", self.ID()) }' % (
        '%d)' % (8 << i),
        REG_PREFIX_TAB[i].lower(),
    ))

cc.line('func (self SIMDRegister128v) String() string { return fmt.Sprintf("v%d", self) }')
cc.line('func (self SIMDRegister128r) String() string { return fmt.Sprintf("v%d.%s", self.ID(), self.Arrangement()) }')
cc.line()

ARRANGEMENTS = [
    ('B', (8, 16)),
    ('H', (4, 8)),
    ('S', (2, 4)),
    ('D', (1, 2)),
]

for k, (v1, v2) in ARRANGEMENTS:
    cc.line('func (self SIMDRegister128v) %s(n byte) SIMDRegister128r {' % k)
    cc.indent()
    cc.line('switch n {')
    cc.indent()
    cc.line('case %-2d : return self.As(Vec%d%c)' % (v1, v1, k))
    cc.line('case %-2d : return self.As(Vec%d%c)' % (v2, v2, k))
    cc.line('default : panic("aarch64: invalid element count for unit size %s")' % k)
    cc.dedent()
    cc.line('}')
    cc.dedent()
    cc.line('}')
    cc.line()

cc.line('func (self SIMDRegister128v) As(v SIMDVectorArrangement) SIMDRegister128r {')
cc.indent()
cc.line('if self &^ 0b11111 != 0 {')
cc.indent()
cc.line('panic("aarch64: invalid unarranged vector register")')
cc.dedent()
cc.line('} else {')
cc.indent()
cc.line('return SIMDRegister128r(uint8(v) << 5 | uint8(self))')
cc.dedent()
cc.line('}')
cc.dedent()
cc.line('}')
cc.line()

cc.line('func (self SIMDRegister128r) Arrangement() SIMDVectorArrangement {')
cc.indent()
cc.line('return SIMDVectorArrangement(self >> 5)')
cc.dedent()
cc.line('}')
cc.line()

for i in range(5):
    cc.line('const (')
    cc.indent()
    cc.line('%s0 SIMDRegister%d = iota' % (REG_PREFIX_TAB[i], 8 << i))

    for j in range(1, 32):
        cc.line('%s%d' % (REG_PREFIX_TAB[i], j))

    cc.dedent()
    cc.line(')')
    cc.line()

cc.line('const (')
cc.indent()
cc.line('V0 SIMDRegister128v = iota')

for j in range(1, 32):
    cc.line('V%d' % j)

cc.dedent()
cc.line(')')
cc.line()

with open('arch/aarch64/registers_advsimd.go', 'w') as fp:
    fp.write('\n'.join(cc.buf))

### ---------- Instruction Encoding Classes ---------- ###

class Account:
    name: str
    desc: str

    def __init__(self, name: str, desc: str):
        self.name = name
        self.desc = desc

    def __repr__(self) -> str:
        return '%s %s' % (self.name, self.desc)

class Definition:
    name: str
    desc: str
    bits: dict[str, set[str]]

    def __init__(self, name: str, desc: str, bits: dict[str, set[str]]):
        self.name = name
        self.desc = desc
        self.bits = bits

    def __repr__(self) -> str:
        return '%s %s [%s]' % (self.name, self.desc, ' '.join(
            '%s=%s%s%s' % (
                key,
                '' if len(vals) == 1 else '{',
                ','.join(sorted(vals)),
                '' if len(vals) == 1 else '}'
            ) for key, vals in self.bits.items()
        ))

class Instruction:
    bits: list[int | None]
    refs: dict[str, tuple[int, int]]

    def __init__(self, other: 'Instruction | None' = None):
        if other is None:
            self.refs = {}
            self.bits = [None] * 32
        else:
            self.bits = other.bits[:]
            self.refs = dict(other.refs)

    def __repr__(self) -> str:
        char = 0
        mlen = 0
        refs = []
        bits = ['x' if v is None else str(v) for v in self.bits]

        for v in self.refs:
            mlen = max(mlen, len(v))

        bits.extend(' ' * mlen)
        bits.extend('  ')

        for p, n in self.refs.values():
            char += 1
            bits[p:p + n] = [
                '\x1b[3%dm%s\x1b[0m' % (char % 5 + 1, 'x' if v is None else v)
                for v in self.bits[p:p + n]
            ]

        vals = list(self.refs.items())
        vals.sort(key = lambda x: x[1], reverse = True)

        for i, (v, (p, n)) in enumerate(vals):
            line = list(v[::-1].rjust(mlen + 34))
            line[p + n // 2] = '┘'
            line[p + n // 2 + 1:33] = '─' * (32 - p - n // 2)

            for i in range(len(refs)):
                refs[i][p + n // 2] = '│'
            else:
                refs.append(line)

        return '\n'.join([
            ''.join(bits[::-1]),
            *(''.join(v[::-1]) for v in refs),
        ])

    def update(self, boxes: list[Element]):
        for box in boxes:
            hibit = int(box.attrib['hibit'])
            width = int(box.attrib.get('width', 1))

            if box.attrib.get('usename') == '1':
                self.refs[box.attrib['name']] = (hibit - width + 1, width)
                continue

            for i, item in enumerate(box.findall('c')):
                assert item.text in {'0', '1'}, 'invalid cell value: ' + repr(item.text)
                self.bits[hibit - i] = int(item.text)

class EncodingTabEntry(NamedTuple):
    name: str
    desc: str
    form: str
    file: str
    func: str
    bits: Instruction

    def __repr__(self) -> str:
        return '\n'.join([
            'Encoding %s {' % self.name,
            '    ' + self.desc,
            '    form = ' + self.form,
            '    file = ' + self.file,
            '    func = ' + self.func,
            *('    ' + v for v in repr(self.bits).splitlines()),
            '}',
        ])

class InstructionTabEntry(NamedTuple):
    name: str
    desc: str
    data: Element
    base: Instruction

    def __repr__(self) -> str:
        return '\n'.join([
            'Instruction %s {' % self.name,
            '    ' + self.desc,
            *('    ' + v for v in repr(self.base).splitlines()),
            '}',
        ])

def parse_bit(bit: str) -> int | None:
    match bit:
        case '0': return 0
        case '1': return 1
        case 'x': return None
        case _  : raise AssertionError('invalid bit value: ' + repr(bit))

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()

enctab = dict[str, EncodingTabEntry]()
instab = dict[str, InstructionTabEntry]()

isadocs = ElementTree.parse(os.path.join(sys.argv[1], 'onebigfile.xml')).getroot()
encindex = isadocs.find('.//encodingindex')
assert encindex is not None, 'invalid encoding index file'

for iclass in sorted(encindex.findall('iclass_sect'), key = lambda x: x.attrib['id']):
    name = iclass.attrib['id']
    desc = iclass.attrib['title']
    itab = iclass.find('instructiontable')

    # TODO: support SVE instructions sometime in the future
    if name.startswith('sve_'):
        continue

    assert itab is not None, 'missing instruction table for ' + name
    assert itab.attrib['iclass'] == name, 'wrong instruction table iclass for ' + name

    bits = Instruction()
    bits.update(iclass.findall('regdiagram/box'))

    cond = set()
    vals = bits.bits[:]
    args = sorted(bits.refs.items(), key = lambda x: x[1], reverse = True)

    for dc in iclass.findall('decode_constraints/decode_constraint'):
        cond.add((
            dc.attrib['name'],
            dc.attrib['op'],
            dc.attrib['val'],
        ))

    for p, n in bits.refs.values():
        vals[p:p + n] = [0] * n

    instab[name] = InstructionTabEntry(
        name = name,
        desc = desc,
        data = itab,
        base = bits,
    )

    cc.line('// %s: %s' % (name, desc))
    cc.line('func %s(%s uint32) Instruction {' % (name, ', '.join(v for v, _ in args)))
    cc.indent()

    for th, (_, n) in args:
        cc.line('if %s &^ 0b%s != 0 {' % (th, '1' * n))
        cc.indent()
        cc.line('panic("%s: invalid %s")' % (name, th))
        cc.dedent()
        cc.line('}')

    for key, op, val in sorted(cond):
        assert op == '!=', 'decode constraint is not implemented: %s %s %s' % (key, op, val)
        cc.line('if %s == 0b%s {' % (key, val))
        cc.indent()
        cc.line('panic("%s: decode constraint is not satisfied: %s %s %s")' % (name, key, op, val))
        cc.dedent()
        cc.line('}')

    assert None not in vals, 'unset bit in %s: %r' % (name, vals)
    cc.line('ret := uint32(0x%08x)' % int(''.join(map(str, vals))[::-1], 2))

    for th, (p, _) in args:
        if p == 0:
            cc.line('ret |= ' + th)
        else:
            cc.line('ret |= %s << %d' % (th, p))

    cc.line('return Instruction(ret);')
    cc.dedent()
    cc.line('}')
    cc.line()

with open('arch/aarch64/encodings.go', 'w') as fp:
    fp.write('\n'.join(cc.buf))

for name, entry in sorted(instab.items(), key = lambda v: v[0]):
    keys = []
    itab = entry.data

    for th in itab.findall('thead/tr[@id="heading2"]/th[@class="bitfields"]'):
        assert th.text, 'missing field name for ' + name
        keys.append(th.text)

    for th in itab.findall('tbody/tr[@class="instructiontable"]'):
        if th.attrib.get('undef') != '1':
            encname   = th.attrib['encname']
            iformfile = th.attrib['iformfile']
            iformname = th.find('td[@class="iformname"]')
            bitfields = th.findall('td[@class="bitfield"]')

            # TODO: remove this
            # if encname != 'CASPAL_CP32_ldstexcl':
            if iformfile != 'ld1_advsimd_mult.xml':
                continue

            assert iformfile, 'missing iform files for ' + name
            assert iformname is not None, 'missing iform names for ' + name
            assert len(bitfields) == len(keys), 'mismatched bitfields for %s.%s' % (name, encname)

            desc = iformname.text
            form = iformname.attrib['iformid']
            assert desc and form, 'missing form or description for %s.%s' % (name, encname)

            bits = []
            instr = Instruction(entry.base)

            for field in bitfields:
                if not field.text or field.text.startswith('!='):
                    bits.append(None)
                else:
                    bits.append(list(map(parse_bit, field.text[::-1])))

            for key, vals in zip(keys, bits):
                if vals is not None:
                    p, n = instr.refs[key]
                    assert len(vals) == n, 'mismatched bits for %s.%s.%s' % (name, encname, key)
                    instr.bits[p:p + n] = vals

            enc = EncodingTabEntry(
                name = encname,
                desc = desc,
                form = form,
                file = iformfile,
                func = name,
                bits = instr,
            )

            assert encname not in enctab, 'duplicated encoding name %s.%s' % (name, encname)
            enctab[encname] = enc

### ---------- Per-instruction Encodings ---------- ###

class Op(Enum):
    LSL  = 'lsl'
    MSL  = 'msl'
    LSR  = 'lsr'
    ASR  = 'asr'
    UXTB = 'uxtb'
    UXTH = 'uxth'
    UXTW = 'uxtw'
    UXTX = 'uxtx'
    SXTB = 'sxtb'
    SXTH = 'sxth'
    SXTW = 'sxtw'
    SXTX = 'sxtx'

class Sym(Enum):
    CSYNC  = 'CSYNC'
    PRFOP  = 'prfop'
    OPTION = 'option'
    SYSREG = 'systemreg'

class Tag(str):
    def __str__(self) -> str:
        return '=' + self

class Imm(str):
    def __str__(self) -> str:
        return '#' + self

class Lit:
    ty  : type
    val : object

    def __init__(self, v: object):
        self.ty  = type(v)
        self.val = v

    def __str__(self) -> str:
        return '#%s' % self.val

class Reg(NamedTuple):
    name: str
    altr: str | None = None
    size: str | None = None
    mode: str | Tag | None = None
    vidx: Imm | Lit | None = None

    def __str__(self) -> str:
        if self.size is not None:
            assert self.altr is None
            assert self.mode is None
            assert self.vidx is None
            return '%s[%s]' % (self.size, self.name)
        elif self.mode is not None:
            assert self.altr is None
            return '%s.%s%s' % (self.name, self.mode, '' if self.vidx is None else '[%s]' % self.vidx)
        elif self.altr is not None:
            assert self.vidx is None
            return '(%s|%s)' % (self.name, self.altr)
        else:
            return self.name

class Vec(NamedTuple):
    mode: str | Tag
    regs: list[str]
    vidx: Imm | Lit | None = None

    def __str__(self) -> str:
        return '{ %s }.%s%s' % (
            ', '.join(self.regs),
            self.mode,
            '' if self.vidx is None else '[%s]' % self.vidx
        )

class Mod(NamedTuple):
    mod: str | Op
    imm: tuple[Imm | Lit, bool] | None = None

    def name(self) -> str:
        if isinstance(self.mod, str):
            return self.mod
        else:
            return self.mod.name

    def __str__(self) -> str:
        if self.imm is None:
            return self.name()
        elif not self.imm[1]:
            return '%s %s' % (self.name(), self.imm[0])
        else:
            return '%s {%s}' % (self.name(), self.imm[0])

class Mem(NamedTuple):
    base   : Reg
    offs   : tuple[Reg | Imm | Lit, bool] | None = None
    index  : Literal['pre', 'post'] | None       = None
    extend : tuple[Mod, bool] | None             = None

    def __str__(self) -> str:
        ret = []
        ret.append('[')
        ret.append(self.base)

        if self.offs and self.index != 'post':
            v, o = self.offs
            ret.append('%s, %s%s' % ('{' if o else '', str(v), '}' if o else ''))

        if self.extend:
            v, o = self.extend
            ret.append('%s, %s%s' % ('{' if o else '', str(v), '}' if o else ''))

        match self.index:
            case 'pre':
                assert self.offs, 'missing index for pre index'
                ret.append(']!')

            case 'post':
                assert self.offs, 'missing index for post index'
                v, o = self.offs
                ret.append(']%s+%s%s' % ('{' if o else '', str(v), '}' if o else ''))

            case v:
                ret.append(']')
                assert v is None

        return ''.join(
            str(v)
            for v in ret
        )

class Instr(NamedTuple):
    mnemonic: str
    modifier: str | None
    operands: list[tuple[Reg | Vec | Mem | Mod | Imm | Lit | Sym, bool]]

    def __str__(self) -> str:
        return ''.join([
            self.mnemonic,
            '{%s}' % self.modifier if self.modifier else '',
            ' ' if self.operands else '',
            *(
                '%s%s%s%s' % ('{' if o else '', ', ' if i else '', str(v), '}' if o else '')
                for i, (v, o) in enumerate(self.operands)
            )
        ])

class Token(NamedTuple):
    name: str
    text: str

    def __repr__(self) -> str:
        return '\x1b[31m{%s}\x1b[0m' % self.name

    @classmethod
    def parse(cls, item: Element) -> 'Token':
        return cls(
            text = item.text or '',
            name = item.attrib['link'],
        )

class AsmTemplate:
    pos: int
    buf: list[str | Token]

    ops = {
        v.name
        for v in Op
    }

    amounts = {
        'amount',
        'amount_1',
        'amount_2',
        'amount_3',
        'amount_4',
        'shift',
        'shift_1',
        'shift_2',
        'shift_3',
    }

    registers = {
        'd',
        'm',
        'n',
        't',
    }

    modifiers = {
        'shift',
        'extend',
        'extend_1',
    }

    immediates = {
        'imm',
        'imm_1',
        'imm_2',
        'imm_3',
    }

    predefined = {
        'CSYNC': (
            Sym.CSYNC,
            'CSYNC option',
            []
        ),
        'prfop': (
            Sym.PRFOP,
            'prefetch option',
            ['|', '#', 'imm5']
        ),
        'option': (
            Sym.OPTION,
            'barrier option',
            ['|', '#', 'imm']
        ),
        'systemreg': (
            Sym.SYSREG,
            'system register',
            ['|', 'S', 'op0', '_', 'op1', '_', 'cn', '_', 'cm', '_', 'op2']
        ),
    }

    for v in Sym:
        assert v.value in predefined

    def __init__(self, tok: list[str | Token]):
        self.pos = 0
        self.buf = tok

    @property
    def eof(self) -> bool:
        return self.pos >= len(self.buf)

    @property
    def tok(self) -> str | Token:
        if self.eof:
            raise SyntaxError('unexpected EOF')
        else:
            return self.buf[self.pos]

    def next(self) -> str | Token:
        ret = self.tok
        self.pos += 1
        return ret

    def dsym(self, name: str) -> Sym:
        tok = []
        sym, msg, mat = self.predefined[name]

        for _ in mat:
            v = self.next()
            tok.append(v.name if isinstance(v, Token) else v)

        if tok != mat:
            raise SyntaxError('invalid %s: %r' % (msg, name))
        else:
            return sym

    def value(self) -> Reg | Vec | Mem | Mod | Imm | Lit | Sym:
        match self.next():
            case '#':
                match self.next():
                    case '0.0'                                   : return Lit(0.0)
                    case v if isinstance(v, str) and v.isdigit() : return Lit(int(v))
                    case v if isinstance(v, Token)               : return Imm(v.name)
                    case v                                       : raise SyntaxError('integer or token expected')

            case '(':
                reg = self.next()
                tab = self.predefined

                if not isinstance(reg, Token):
                    raise SyntaxError('register token expected')

                if reg.name in tab:
                    ret = self.dsym(reg.name)
                elif self.next() != '|':
                    raise SyntaxError('"|" expected')
                else:
                    match self.next():
                        case v if isinstance(v, Token) : ret = Reg(reg.name, altr = v.name)
                        case _                         : raise SyntaxError('register token expected')

                if self.next() != ')':
                    raise SyntaxError('")" expected')
                else:
                    return ret

            case '[':
                idx = None
                args = self.vlist()

                if not args:
                    raise SyntaxError('invalid memory operand')

                if self.next() != ']':
                    raise SyntaxError('"]" expected')

                if not self.eof and self.tok == '!':
                    idx = 'pre'
                    self.next()

                exts = None
                offs = None
                base, opt = args[0]

                if opt or not isinstance(base, Reg):
                    raise SyntaxError('memory base must be a non-optional register')

                if len(args) >= 2:
                    if not isinstance(args[1][0], (Reg, Imm, Lit)):
                        raise SyntaxError('memory offset must be a register or an immediate value')
                    else:
                        offs = (args[1][0], args[1][1])

                if len(args) >= 3:
                    if not isinstance(args[2][0], Mod):
                        raise SyntaxError('memory offset extension must be an extension')
                    else:
                        exts = (args[2][0], args[2][1])

                if len(args) >= 4:
                    raise SyntaxError('too many argumnets for memory operand')

                return Mem(
                    base   = base,
                    offs   = offs,
                    index  = idx,
                    extend = exts,
                )

            case '{{':
                regs = []
                mode = None

                while True:
                    reg = self.next()
                    dot = self.next()
                    tag = self.next()

                    if dot != '.' or not isinstance(reg, Token):
                        raise SyntaxError('invalid vector element')

                    if isinstance(tag, str):
                        tag = Tag(tag)
                    else:
                        tag = tag.name

                    if mode != tag and mode is not None:
                        raise SyntaxError('mode confliction within vector')

                    mode = tag
                    regs.append(reg.name)

                    match self.next():
                        case ','  : pass
                        case '}}' : break
                        case _    : raise SyntaxError('"," or "}" expected')

                if self.eof or self.tok != '[':
                    return Vec(mode, regs, vidx = None)

                self.next()
                vidx = self.next()

                if self.next() != ']':
                    raise SyntaxError('"]" expected')

                if isinstance(vidx, Token):
                    return Vec(mode, regs, Imm(vidx.name))
                else:
                    return Vec(mode, regs, Lit(int(vidx)))

            case v if isinstance(v, str) and v in self.predefined:
                return self.dsym(v)

            case v if isinstance(v, Token) and v.name in self.immediates:
                return Imm(v.name)

            case v if isinstance(v, Token) and v.name in self.predefined:
                return self.dsym(v.name)

            case v if isinstance(v, Token) and v.name not in self.modifiers:
                mode = None
                size = None
                vidx = None
                name = v.name

                if not self.eof:
                    if self.tok == '.':
                        self.next()
                        mode = self.next()

                        if isinstance(mode, str):
                            mode = Tag(mode)
                        else:
                            mode = mode.name

                        if not self.eof and self.tok == '[':
                            self.next()
                            vidx = self.next()

                            if self.next() != ']':
                                raise SyntaxError('"]" expected')

                            if isinstance(vidx, Token):
                                vidx = Imm(vidx.name)
                            else:
                                vidx = Lit(int(vidx))

                    elif isinstance(self.tok, Token) and self.tok.name in self.registers:
                        size = v.name
                        name = self.tok.name
                        self.next()

                return Reg(
                    name = name,
                    mode = mode,
                    size = size,
                    vidx = vidx,
                )

            case v:
                opt = False
                mod = v.name if isinstance(v, Token) else v

                if mod not in (self.ops if isinstance(v, str) else self.modifiers):
                    raise SyntaxError('unexpected token: ' + repr(v))

                if self.tok == '{':
                    opt = True
                    self.next()

                if self.tok == '#':
                    imm = self.value()
                elif isinstance(self.tok, Token):
                    imm = Imm(cast(Token, self.next()).name)
                else:
                    imm = None

                if opt and self.next() != '}':
                    raise SyntaxError('"}" expected')

                if imm is not None and not isinstance(imm, Lit):
                    if not isinstance(imm, Imm) or not imm in self.amounts:
                        raise SyntaxError('invalid extension immediate')

                if mod in self.ops:
                    mod = Op(mod.lower())

                if imm is None:
                    return Mod(mod)
                else:
                    return Mod(mod, (imm, opt))

    def vlist(self) -> list[tuple[Reg | Vec | Mem | Mod | Imm | Lit | Sym, bool]]:
        ret = []
        opt = False

        if not self.eof and self.tok == '{':
            opt = True
            self.next()

        while True:
            mem = None
            opx = False
            val = self.value()

            if ret:
                mem, opx = ret[-1]

            if not isinstance(mem, Mem):
                ret.append((val, bool(opt)))
            elif not isinstance(val, (Reg, Imm, Lit)):
                ret.append((val, bool(opt)))
            elif mem.offs is not None or mem.index is not None:
                ret.append((val, bool(opt)))
            elif opt == opx:
                ret[-1] = Mem(mem.base, (val, opt), 'post', mem.extend), opx
            else:
                raise SyntaxError('mismatched operand requirements')

            if not self.eof:
                match self.tok:
                    case '{':
                        if opt:
                            raise SyntaxError('nested "{"')
                        else:
                            opt = True
                            self.next()

                    case '}':
                        if not opt:
                            raise SyntaxError('unbalanced "}"')
                        else:
                            opt = False
                            self.next()

            if not self.eof and self.tok == ',':
                self.next()
            else:
                break

        if opt:
            raise SyntaxError('unbalanced "{"')
        else:
            return ret

    def instr(self) -> Instr:
        args = []
        mods = None
        name = self.next()

        if not isinstance(name, str):
            raise SyntaxError('mnemonic expected')

        if not self.eof:
            match self.tok:
                case '.' if name == 'B':
                    self.next()
                    cond = self.next()

                    if not isinstance(cond, Token):
                        raise SyntaxError('branch condition expected')
                    else:
                        mods = cond.name

                case v if isinstance(v, Token) and v.name == '2':
                    mods = '2'
                    self.next()

                case v if isinstance(v, Token) and v.name == 'bt' and name == 'BFMLAL':
                    mods = 'bt'
                    self.next()

        if not self.eof:
            args = self.vlist()

        if not self.eof:
            raise SyntaxError('junk after instruction: ' + str(self.next()))

        return Instr(
            mnemonic = name,
            operands = args,
            modifier = mods,
        )

    class Lexer:
        buf   : str
        sbuf  : str
        items : list[Element]

        def __init__(self, items: list[Element]):
            self.buf   = ''
            self.sbuf  = ''
            self.items = items

        def __iter__(self) -> Iterator[str | Token]:
            for item in self.items:
                match item.tag:
                    case 'a':
                        yield from self._parse_text()
                        yield Token.parse(item)
                        self.buf = ''

                    case 'text':
                        if item.text:
                            self.buf += item.text

                    case _:
                        raise AssertionError('unexpected tag in assembly template: ' + repr(item.tag))

            yield from self._parse_text()
            self.buf = ''

        def _parse_dots(self) -> Iterator[str]:
            if self.sbuf:
                if self.sbuf == '.' or self.sbuf[-1] != '.':
                    yield self.sbuf
                else:
                    yield self.sbuf[:-1]
                    yield self.sbuf[-1]

        def _parse_text(self) -> Iterator[str]:
            for i, ch in enumerate(self.buf):
                if ch.isalnum() or ch == '_' or (self.sbuf and ch == '.'):
                    self.sbuf += ch
                    continue

                yield from self._parse_dots()
                self.sbuf = ''

                if not ch.isspace():
                    if ch == '}' and i != 0 and self.buf[i - 1].isspace():
                        yield '}}'
                    elif ch == '{' and i != len(self.buf) - 1 and self.buf[i + 1].isspace():
                        yield '{{'
                    else:
                        yield ch

            yield from self._parse_dots()
            self.sbuf = ''

    @classmethod
    def parse(cls, items: list[Element]) -> Instr:
        return cls(list(cls.Lexer(items))).instr()

def permu_bits(bit: str) -> str:
    match bit:
        case '0': return '0'
        case '1': return '1'
        case 'x': return '01'
        case _  : raise AssertionError('invalid bit value: ' + repr(bit))

def parse_props(out: dict[str, str], p: Element):
    for v in p.findall('docvars/docvar'):
        out[v.attrib['key']] = v.attrib['value']

def parse_boxes(ins: Instruction, boxes: list[Element]):
    for box in boxes:
        boxes = box.findall('c')
        hibit = int(box.attrib['hibit'])

        for i, item in enumerate(boxes):
            if item.text == '0':
                assert ins.bits[hibit - i] != 1, 'bit confiction: 0'
                ins.bits[hibit - i] = 0
            elif item.text == '1':
                assert ins.bits[hibit - i] != 0, 'bit confiction: 1'
                ins.bits[hibit - i] = 1
            else:
                assert item.text in {None, '', 'x', 'z', 'N', 'Z'}, \
                    'invalid cell value: ' + repr(item.text)

def parse_symdef(defs: Element) -> dict[str, set[str]]:
    rets = {}
    tabs = defs.findall('.//tgroup')
    rows = defs.findall('.//tbody/row')
    dest = defs.attrib['encodedin']

    if len(tabs) != 1:
        raise AssertionError('expect exactly 1 table: encodedin="%s"' % dest)

    for row in rows:
        bits = []
        syms = row.find('entry[@class="symbol"]')

        for bv in row.findall('entry[@class="bitfield"]'):
            if not bv.text:
                raise AssertionError('missing symbol or bitfield: encodedin="%s"' % dest)
            else:
                bits.append(bv.text)

        if not bits or syms is None or not syms.text:
            raise AssertionError('missing symbol or bitfield: encodedin="%s"' % dest)

        for sym in map(str.strip, syms.text.split('|')):
            prod = itertools.product(*map(permu_bits, ''.join(bits)))
            rets.setdefault(sym, set()).update(''.join(v) for v in prod)

    if not rets:
        raise AssertionError('missing definitions: encodedin="%s"' % dest)
    else:
        return rets

ARG_CHECK_TAB = {
    '2'           : None,
    'amount'      : None,
    'amount_1'    : None,
    'amount_2'    : None,
    'amount_3'    : None,
    'amount_4'    : None,
    'at_op'       : None,
    'bt'          : None,
    'cm'          : None,
    'cn'          : None,
    'cond'        : None,
    'cond_1'      : None,
    'const'       : None,
    'd'           : None,
    'da'          : None,
    'dc_op'       : None,
    'dd'          : None,
    'dm'          : None,
    'dn'          : None,
    'dn_1'        : None,
    'dt'          : None,
    'dt1'         : None,
    'dt2'         : None,
    'extend'      : None,
    'extend_1'    : None,
    'fbits'       : None,
    'fbits_1'     : None,
    'ha'          : None,
    'hd'          : None,
    'hm'          : None,
    'hn'          : None,
    'hn_1'        : None,
    'ht'          : None,
    'ic_op'       : None,
    'imm'         : None,
    'imm1'        : None,
    'imm2'        : None,
    'imm5'        : None,
    'imm6'        : None,
    'imm8'        : None,
    'imm_1'       : None,
    'imm_2'       : None,
    'imm_3'       : None,
    'imm_4'       : None,
    'imm_5'       : None,
    'immr'        : None,
    'immr_1'      : None,
    'imms'        : None,
    'imms_1'      : None,
    'index'       : None,
    'index1'      : None,
    'index2'      : None,
    'index_1'     : None,
    'index_2'     : None,
    'index_3'     : None,
    'label'       : None,
    'lsb'         : None,
    'lsb_1'       : None,
    'lsb_2'       : None,
    'lsb_3'       : None,
    'm'           : None,
    'mask'        : None,
    'mod'         : None,
    'n'           : None,
    'n_sp'        : None,
    'nzcv'        : None,
    'op0'         : None,
    'op1'         : None,
    'op2'         : None,
    'option'      : None,
    'pattern'     : None,
    'pd'          : None,
    'pdm'         : None,
    'pdn'         : None,
    'pg'          : None,
    'pimm'        : None,
    'pimm_1'      : None,
    'pimm_2'      : None,
    'pimm_3'      : None,
    'pimm_4'      : None,
    'pm'          : None,
    'pn'          : None,
    'prfop'       : None,
    'pstatefield' : None,
    'pt'          : None,
    'qd'          : None,
    'qn'          : None,
    'qt'          : None,
    'qt1'         : None,
    'qt2'         : None,
    'r'           : None,
    'rotate'      : None,
    'sa'          : None,
    'sd'          : None,
    'shift'       : None,
    'shift_1'     : None,
    'shift_2'     : None,
    'shift_3'     : None,
    'simm'        : None,
    'sm'          : None,
    'sn'          : None,
    'sn_1'        : None,
    'st'          : None,
    'st1'         : None,
    'st2'         : None,
    'systemreg'   : None,
    't'           : None,
    't_1'         : None,
    't_2'         : None,
    'ta'          : None,
    'targets'     : None,
    'tb'          : None,
    'tlbi_op'     : None,
    'ts'          : None,
    'ts_1'        : None,
    'uimm4'       : None,
    'uimm6'       : None,
    'v'           : None,
    'v_1'         : None,
    'va'          : None,
    'vb'          : None,
    'vd'          : None,
    'vm'          : None,
    'vm_1'        : None,
    'vn'          : None,
    'vn_1'        : None,
    'vn_plus_1'   : None,
    'vn_plus_2'   : None,
    'vn_plus_3'   : None,
    'vt'          : None,
    'vt2'         : None,
    'vt3'         : None,
    'vt4'         : None,
    'w_s_plus_1'  : None,
    'w_t_plus_1'  : None,
    'wa'          : None,
    'wd'          : None,
    'wd_wsp'      : None,
    'wdn'         : None,
    'width'       : None,
    'width_1'     : None,
    'wm'          : None,
    'wm_1'        : None,
    'wn'          : None,
    'wn_1'        : None,
    'wn_wsp'      : None,
    'ws'          : None,
    'wt'          : None,
    'wt1'         : None,
    'wt2'         : None,
    'x_s_plus_1'  : None,
    'x_t_plus_1'  : None,
    'xa'          : None,
    'xd'          : None,
    'xd_sp'       : None,
    'xdn'         : None,
    'xm'          : None,
    'xm_1'        : None,
    'xm_sp'       : None,
    'xn'          : None,
    'xn_1'        : None,
    'xn_sp'       : None,
    'xs'          : None,
    'xt'          : None,
    'xt1'         : None,
    'xt2'         : None,
    'xt_1'        : None,
    'xt_sp'       : None,
    'za'          : None,
    'zd'          : None,
    'zda'         : None,
    'zdn'         : None,
    'zm'          : None,
    'zm_1'        : None,
    'zn'          : None,
    'zt'          : None,
    'zt1'         : None,
    'zt2'         : None,
    'zt3'         : None,
    'zt4'         : None,
}

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()

formtab = {}
fieldtab = {}

for expl in isadocs.findall('.//explanation'):
    symbol = expl.find('symbol')
    symacc = expl.find('account')
    symdef = expl.find('definition')

    if symbol is None or (symacc is None) is (symdef is None):
        raise AssertionError('invalid explanation')

    desc = symbol.text or ''
    name = symbol.attrib['link']

    if symacc is not None:
        assert symdef is None
        defs = Account(symacc.attrib['encodedin'], desc)
    else:
        assert isinstance(symdef, Element)
        defs = Definition(symdef.attrib['encodedin'], desc, parse_symdef(symdef))

    for enc in expl.attrib['enclist'].split(','):
        tab = fieldtab.setdefault(enc.strip(), {})
        tab[name] = defs

for encdata in sorted(enctab.values(), key = lambda x: x.name):
    node = isadocs.find('.//iclass/encoding[@name="%s"]' % encdata.name)
    assert node is not None, 'encoding %s does not exists' % repr(encdata.name)

    tokens = node.findall('asmtemplate/*')
    assert tokens, 'encoding %s does not have an assembly syntax' % repr(encdata.name)

    args = []
    opts = {}
    bits = Instruction(encdata.bits)
    inst = AsmTemplate.parse(tokens)

    parse_props(opts, node)
    parse_boxes(bits, node.findall('box'))

    vals = list(bits.refs.items())
    vals.sort(key = lambda x: x[1], reverse = True)

    for v, (p, n) in vals:
        if None in bits.bits[p:p + n]:
            args.append(v)
        else:
            args.append(str(int(''.join(map(str, bits.bits[p:p + n])), 2)))

    print('-----------------------------------')
    print(inst)
    import pprint
    pprint.pprint(opts)
    print(bits)
    print(fieldtab.get(encdata.name, {}))
    print(opts['mnemonic'], '/', len(inst.operands), encdata.func, args)

# data = ElementTree.parse(os.path.join(sys.argv[1], 'onebigfile.xml'))
# instrs = data.findall('.//sect1[@id="iformpages"]//file/instructionsection[@type="instruction"]')

# for instr in instrs:
#     opts = {}
#     fields = {}

#     print('>>>>> %(id)s: %(title)s' % instr.attrib)
#     parse_props(opts, instr)

#     # TODO: implement SVE instructions
#     if opts.get('instr-class') == 'sve':
#         continue

#     for expl in instr.findall('explanations/explanation'):
#         symbol = expl.find('symbol')
#         symacc = expl.find('account')
#         symdef = expl.find('definition')

#         if symbol is None or (symacc is None) is (symdef is None):
#             raise AssertionError('invalid explanation')

#         desc = symbol.text or ''
#         name = symbol.attrib['link']

#         if symacc is not None:
#             assert symdef is None
#             defs = Account(symacc.attrib['encodedin'], desc)
#         else:
#             assert isinstance(symdef, Element)
#             defs = Definition(symdef.attrib['encodedin'], desc, parse_symdef(symdef))

#         for enc in expl.attrib['enclist'].split(','):
#             tab = fields.setdefault(enc.strip(), {})
#             tab[name] = defs

#     # # TODO: remove this
#     if 'CASPAL_CP32_ldstexcl' not in fields:
#         continue

#     for iclass in instr.findall('classes/iclass'):
#         attrs = dict(opts)
#         proto = Instruction(insdata.bits)

#         parse_props(attrs, iclass)
#         parse_boxes(proto, iclass.findall('regdiagram/box'))

#         for encoding in iclass.findall('encoding'):
#             props = dict(attrs)
#             instr = Instruction(proto)
#             lexer = TokenStream.parse(encoding.attrib['name'], encoding.findall('asmtemplate/*'))

#             parse_props(props, encoding)
#             parse_boxes(instr, encoding.findall('box'))

#             print('-------- %s --------' % lexer.name)
#             print('Mnemonic :', props['mnemonic'])
#             print('Syntax   :', ' '.join(map(repr, lexer)))
#             import pprint
#             print('Fields   :', end = ' ')
#             pprint.pprint(fields.get(lexer.name, {}), compact = True, sort_dicts = True)
#             print('Encoding :')
#             print(instr)
#             print()
