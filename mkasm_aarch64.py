#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import itertools

from typing import cast
from typing import Literal
from typing import Iterator
from typing import NamedTuple

from enum import Enum
from functools import cached_property
from collections import OrderedDict

from xml.etree import ElementTree
from xml.etree.ElementTree import Element

class CodeGen:
    def __init__(self):
        self.buf = []
        self.level = 0

    @property
    def src(self) -> str:
        return '\n'.join(self.buf)

    def line(self, src: str = ''):
        self.buf.append(' ' * (self.level * 4) + src)

    def dedent(self):
        self.level -= 1

    def indent(self):
        self.level += 1

def status(*args):
    sys.stdout.write('\x1b[#F\x1b[K')
    print(*args)

print()
status('* Preparing ...')

### ---------- Advanced SIMD Registers ---------- ###

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()
cc.line('import (')
cc.indent()
cc.line('`fmt`')
cc.line()
cc.line('`github.com/chenzhuoyu/iasm/asm`')
cc.line('`github.com/chenzhuoyu/iasm/internal/tag`')
cc.dedent()
cc.line(')')
cc.line()
cc.line('// SIMDVector represents a SIMD vector.')
cc.line('type SIMDVector interface {')
cc.indent()
cc.line('fmt.Stringer')
cc.line('Arrangement() SIMDVectorArrangement')
cc.dedent()
cc.line('}')
cc.line()
cc.line('// SIMDRegister represents an Advanced SIMD hardware register.')
cc.line('type SIMDRegister interface {')
cc.indent()
cc.line('asm.Register')
cc.line('ItemWidth() uint8')
cc.dedent()
cc.line('}')
cc.line()

cc.line('// SIMDVectorArrangement represents the data arrangement of a V register.')
cc.line('type SIMDVectorArrangement uint8')
cc.line()

cc.line('const (')
cc.indent()
cc.line('Vec8B  SIMDVectorArrangement = 0b000')
cc.line('Vec16B SIMDVectorArrangement = 0b001')
cc.line('Vec4H  SIMDVectorArrangement = 0b010')
cc.line('Vec8H  SIMDVectorArrangement = 0b011')
cc.line('Vec2S  SIMDVectorArrangement = 0b100')
cc.line('Vec4S  SIMDVectorArrangement = 0b101')
cc.line('Vec1D  SIMDVectorArrangement = 0b110')
cc.line('Vec2D  SIMDVectorArrangement = 0b111')
cc.dedent()
cc.line(')')
cc.line()

cc.line('// SIMDVectorArrangements maps the arrangement name to the actual value.')
cc.line('var SIMDVectorArrangements = map[string]SIMDVectorArrangement {')
cc.indent()
cc.line('"8b"  : Vec8B,')
cc.line('"16b" : Vec16B,')
cc.line('"4h"  : Vec4H,')
cc.line('"8h"  : Vec8H,')
cc.line('"2s"  : Vec2S,')
cc.line('"4s"  : Vec4S,')
cc.line('"1d"  : Vec1D,')
cc.line('"2d"  : Vec2D,')
cc.dedent()
cc.line('}')
cc.line()

cc.line('func (self SIMDVectorArrangement) String() string {')
cc.indent()
cc.line('switch self {')
cc.indent()
cc.line('case Vec8B  : return "8b"')
cc.line('case Vec16B : return "16b"')
cc.line('case Vec4H  : return "4h"')
cc.line('case Vec8H  : return "8h"')
cc.line('case Vec2S  : return "2s"')
cc.line('case Vec4S  : return "4s"')
cc.line('case Vec1D  : return "1d"')
cc.line('case Vec2D  : return "2d"')
cc.line('default     : panic("aarch64: invalid SIMD vector arrangement")')
cc.dedent()
cc.line('}')
cc.dedent()
cc.line('}')
cc.line()

cc.line('// SIMDVector1 represents an unarranged SIMD vector with a single register.')
cc.line('type SIMDVector1 [1]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector2 represents an unarranged SIMD vector with two registers that share the the same arrangement.')
cc.line('type SIMDVector2 [2]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector3 represents an unarranged SIMD vector with three registers that share the the same arrangement.')
cc.line('type SIMDVector3 [3]SIMDRegister128v')
cc.line()
cc.line('// SIMDVector4 represents an unarranged SIMD vector with four registers that share the the same arrangement.')
cc.line('type SIMDVector4 [4]SIMDRegister128v')
cc.line()

for n in range(1, 5):
    ax = ', '.join('v%d' % i for i in range(n)).ljust(14)
    cc.line('func Vec%d(%s SIMDRegister128v) SIMDVector%d { return SIMDVector%d { %s } }' % (n, ax, n, n, ax))
else:
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%d) As(v SIMDVectorArrangement) SIMDVector%dr { return SIMDVector%dr { self, v } }' % (n, n, n))
else:
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%d) String() string {' % n)
    cc.indent()

    cc.line('return fmt.Sprintf("{ %s }", %s)' % (
        ', '.join(['%s'] * n),
        ', '.join('self[%d]' % i for i in range(n)))
    )

    cc.dedent()
    cc.line('}')
    cc.line()

cc.line('type (')
cc.indent()

for n in range(1, 5):
    cc.line('SIMDVector%dr struct { V SIMDVector%d; A SIMDVectorArrangement }' % (n, n))

cc.dedent()
cc.line(')')
cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%dr) String() string {' % n)
    cc.indent()

    cc.line('return fmt.Sprintf("{ %s }.%%s", %s, self.A)' % (
        ', '.join(['%s'] * n),
        ', '.join('self.V[%d]' % i for i in range(n)))
    )

    cc.dedent()
    cc.line('}')
    cc.line()

for n in range(1, 5):
    cc.line('func (self SIMDVector%dr) Arrangement() SIMDVectorArrangement { return self.A }' % n)

cc.line()
cc.line('type (')
cc.indent()

for i in range(5):
    cc.line('SIMDRegister%-3d  uint8' % (8 << i))

cc.line('SIMDRegister128v uint8')
cc.line('SIMDRegister128r uint8')
cc.dedent()
cc.line(')')
cc.line()

for i in range(5):
    cc.line('func (SIMDRegister%-4s  Sealed(tag.Tag) {}' % ('%d)' % (8 << i)))

cc.line('func (SIMDRegister128r) Sealed(tag.Tag) {}')
cc.line()

for i in range(5):
    cc.line('func (SIMDRegister%-4s  ItemWidth() uint8 { return %d }' % ('%d)' % (8 << i), 8 << i))

cc.line('func (SIMDRegister128r) ItemWidth() uint8 { return 128 }')
cc.line()

for i in range(5):
    cc.line('func (self SIMDRegister%-4s  ID() uint8 { return uint8(self) }' % ('%d)' % (8 << i)))

cc.line('func (self SIMDRegister128r) ID() uint8 { return uint8(self) }')
cc.line()

REG_PREFIX_TAB = [
    'B',
    'H',
    'S',
    'D',
    'Q',
]

for i in range(5):
    cc.line('func (self SIMDRegister%-4s  String() string { return fmt.Sprintf("%c%%d", self.ID()) }' % (
        '%d)' % (8 << i),
        REG_PREFIX_TAB[i].lower(),
    ))

cc.line('func (self SIMDRegister128v) String() string { return fmt.Sprintf("v%d", self) }')
cc.line('func (self SIMDRegister128r) String() string { return fmt.Sprintf("v%d.%s", self.ID(), self.Arrangement()) }')
cc.line()

cc.line('func (self SIMDRegister128v) As(v SIMDVectorArrangement) SIMDRegister128r {')
cc.indent()
cc.line('if self &^ 0b11111 != 0 {')
cc.indent()
cc.line('panic("aarch64: invalid unarranged vector register")')
cc.dedent()
cc.line('} else {')
cc.indent()
cc.line('return SIMDRegister128r(uint8(v) << 5 | uint8(self))')
cc.dedent()
cc.line('}')
cc.dedent()
cc.line('}')
cc.line()

cc.line('func (self SIMDRegister128r) Arrangement() SIMDVectorArrangement {')
cc.indent()
cc.line('return SIMDVectorArrangement(self >> 5)')
cc.dedent()
cc.line('}')
cc.line()

for i in range(5):
    cc.line('const (')
    cc.indent()
    cc.line('%s0 SIMDRegister%d = iota' % (REG_PREFIX_TAB[i], 8 << i))

    for j in range(1, 32):
        cc.line('%s%d' % (REG_PREFIX_TAB[i], j))

    cc.dedent()
    cc.line(')')
    cc.line()

cc.line('const (')
cc.indent()
cc.line('V0 SIMDRegister128v = iota')

for j in range(1, 32):
    cc.line('V%d' % j)

cc.dedent()
cc.line(')')
cc.line()

with open('arch/aarch64/registers_advsimd.go', 'w') as fp:
    fp.write('\n'.join(cc.buf))

### ---------- Instruction Encoding Classes ---------- ###

class Account:
    name: str
    desc: str

    def __init__(self, name: str, desc: str):
        self.name = name
        self.desc = desc

    def __repr__(self) -> str:
        return '%s %s' % (self.name, self.desc)

class Definition:
    name: str
    desc: str
    bits: dict[str, set[str]]

    def __init__(self, name: str, desc: str, bits: dict[str, set[str]]):
        self.name = name
        self.desc = desc
        self.bits = bits

    def __repr__(self) -> str:
        return '%s %s [%s]' % (self.name, self.desc, ' '.join(
            '%s=%s%s%s' % (
                key,
                '' if len(vals) == 1 else '{',
                ','.join(sorted(vals)),
                '' if len(vals) == 1 else '}'
            ) for key, vals in self.bits.items()
        ))

class Instruction:
    bits: list[int | None]
    refs: dict[str, tuple[int, int]]

    def __init__(self, other: 'Instruction | None' = None):
        if other is None:
            self.refs = {}
            self.bits = [None] * 32
        else:
            self.bits = other.bits[:]
            self.refs = dict(other.refs)

    def __repr__(self) -> str:
        char = 0
        mlen = 0
        refs = []
        bits = ['x' if v is None else str(v) for v in self.bits]

        for v in self.refs:
            mlen = max(mlen, len(v))

        bits.extend(' ' * mlen)
        bits.extend('  ')

        for p, n in self.refs.values():
            char += 1
            bits[p:p + n] = [
                '\x1b[3%dm%s\x1b[0m' % (char % 5 + 1, 'x' if v is None else v)
                for v in self.bits[p:p + n]
            ]

        vals = list(self.refs.items())
        vals.sort(key = lambda x: x[1], reverse = True)

        for i, (v, (p, n)) in enumerate(vals):
            line = list(v[::-1].rjust(mlen + 34))
            line[p + n // 2] = '┘'
            line[p + n // 2 + 1:33] = '─' * (32 - p - n // 2)

            for i in range(len(refs)):
                refs[i][p + n // 2] = '│'
            else:
                refs.append(line)

        return '\n'.join([
            ''.join(bits[::-1]),
            *(''.join(v[::-1]) for v in refs),
        ])

    def update(self, boxes: list[Element]):
        for box in boxes:
            hibit = int(box.attrib['hibit'])
            width = int(box.attrib.get('width', 1))

            if box.attrib.get('usename') == '1':
                self.refs[box.attrib['name']] = (hibit - width + 1, width)
                continue

            for i, item in enumerate(box.findall('c')):
                assert item.text in {'0', '1'}, 'invalid cell value: ' + repr(item.text)
                self.bits[hibit - i] = int(item.text)

class EncodingTabEntry(NamedTuple):
    name: str
    desc: str
    form: str
    file: str
    func: str
    bits: Instruction

    def __repr__(self) -> str:
        return '\n'.join([
            'Encoding %s {' % self.name,
            '    ' + self.desc,
            '    form = ' + self.form,
            '    file = ' + self.file,
            '    func = ' + self.func,
            *('    ' + v for v in repr(self.bits).splitlines()),
            '}',
        ])

class InstructionTabEntry(NamedTuple):
    name: str
    desc: str
    data: Element
    base: Instruction

    def __repr__(self) -> str:
        return '\n'.join([
            'Instruction %s {' % self.name,
            '    ' + self.desc,
            *('    ' + v for v in repr(self.base).splitlines()),
            '}',
        ])

def parse_bit(bit: str) -> int | None:
    match bit:
        case '0': return 0
        case '1': return 1
        case 'x': return None
        case _  : raise AssertionError('invalid bit value: ' + repr(bit))

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()

enctab = dict[str, EncodingTabEntry]()
instab = dict[str, InstructionTabEntry]()

isadocs = ElementTree.parse(os.path.join(sys.argv[1], 'onebigfile.xml')).getroot()
encindex = isadocs.find('.//encodingindex')
assert encindex is not None, 'invalid encoding index file'

for iclass in sorted(encindex.findall('iclass_sect'), key = lambda x: x.attrib['id']):
    name = iclass.attrib['id']
    desc = iclass.attrib['title']
    itab = iclass.find('instructiontable')

    # TODO: support SVE instructions sometime in the future
    if name.startswith('sve_'):
        continue

    assert itab is not None, 'missing instruction table for ' + name
    assert itab.attrib['iclass'] == name, 'wrong instruction table iclass for ' + name
    status('* Instruction Class:', name)

    bits = Instruction()
    bits.update(iclass.findall('regdiagram/box'))

    cond = set()
    req = bits.bits[:]
    args = sorted(bits.refs.items(), key = lambda x: x[1], reverse = True)

    for dc in iclass.findall('decode_constraints/decode_constraint'):
        cond.add((
            dc.attrib['name'],
            dc.attrib['op'],
            dc.attrib['val'],
        ))

    for p, n in bits.refs.values():
        req[p:p + n] = [0] * n

    instab[name] = InstructionTabEntry(
        name = name,
        desc = desc,
        data = itab,
        base = bits,
    )

    cc.line('// %s: %s' % (name, desc))
    cc.line('func %s(%s uint32) uint32 {' % (name, ', '.join(v for v, _ in args)))
    cc.indent()

    for th, (_, n) in args:
        cc.line('if %s &^ 0b%s != 0 {' % (th, '1' * n))
        cc.indent()
        cc.line('panic("%s: invalid %s")' % (name, th))
        cc.dedent()
        cc.line('}')

    for key, op, val in sorted(cond):
        assert op == '!=', 'decode constraint is not implemented: %s %s %s' % (key, op, val)
        cc.line('if %s == 0b%s {' % (key, val))
        cc.indent()
        cc.line('panic("%s: decode constraint is not satisfied: %s %s %s")' % (name, key, op, val))
        cc.dedent()
        cc.line('}')

    assert None not in req, 'unset bit in %s: %r' % (name, req)
    cc.line('ret := uint32(0x%08x)' % int(''.join(map(str, req))[::-1], 2))

    for th, (p, _) in args:
        if p == 0:
            cc.line('ret |= ' + th)
        else:
            cc.line('ret |= %s << %d' % (th, p))

    cc.line('return ret;')
    cc.dedent()
    cc.line('}')
    cc.line()

with open('arch/aarch64/encodings.go', 'w') as fp:
    fp.write('\n'.join(cc.buf))

for name, entry in sorted(instab.items(), key = lambda v: v[0]):
    keys = []
    itab = entry.data

    for th in itab.findall('thead/tr[@id="heading2"]/th[@class="bitfields"]'):
        assert th.text, 'missing field name for ' + name
        keys.append(th.text)

    for th in itab.findall('tbody/tr[@class="instructiontable"]'):
        if th.attrib.get('undef') != '1':
            encname   = th.attrib['encname']
            iformfile = th.attrib['iformfile']
            iformname = th.find('td[@class="iformname"]')
            bitfields = th.findall('td[@class="bitfield"]')

            # TODO: remove this
            # if encname != 'LDR_B_ldst_regoff':
            if not (
                iformfile.startswith('ldr_') or
                iformfile.startswith('add_')
            ):
                continue

            assert iformfile, 'missing iform files for ' + name
            assert iformname is not None, 'missing iform names for ' + name
            assert len(bitfields) == len(keys), 'mismatched bitfields for %s.%s' % (name, encname)

            desc = iformname.text
            form = iformname.attrib['iformid']
            assert desc and form, 'missing form or description for %s.%s' % (name, encname)

            bits = []
            instr = Instruction(entry.base)

            for field in bitfields:
                if not field.text or field.text.startswith('!='):
                    bits.append(None)
                else:
                    bits.append(list(map(parse_bit, field.text[::-1])))

            for key, req in zip(keys, bits):
                if req is not None:
                    p, n = instr.refs[key]
                    assert len(req) == n, 'mismatched bits for %s.%s.%s' % (name, encname, key)
                    instr.bits[p:p + n] = req

            enc = EncodingTabEntry(
                name = encname,
                desc = desc,
                form = form,
                file = iformfile,
                func = name,
                bits = instr,
            )

            assert encname not in enctab, 'duplicated encoding name %s.%s' % (name, encname)
            status('* Encoding Table Entry: %s.%s' % (name, encname))
            enctab[encname] = enc

### ---------- Instruction Assembly Template ---------- ###

class Sop(Enum):
    LSL  = 'lsl'
    LSR  = 'lsr'
    ASR  = 'asr'
    ROR  = 'ror'
    MSL  = 'msl'

class Xop(Enum):
    UXTB = 'uxtb'
    UXTH = 'uxth'
    UXTW = 'uxtw'
    UXTX = 'uxtx'
    SXTB = 'sxtb'
    SXTH = 'sxth'
    SXTW = 'sxtw'
    SXTX = 'sxtx'

class Sym(Enum):
    CSYNC  = 'CSYNC'
    PRFOP  = 'prfop'
    OPTION = 'option'
    SYSREG = 'systemreg'

class Tag(str):
    @cached_property
    def name(self) -> str:
        return self + ''

    def __str__(self) -> str:
        return '=' + self

    def __repr__(self) -> str:
        return 'Tag(%s)' + super().__repr__()

class Imm(str):
    @cached_property
    def name(self) -> str:
        return self + ''

    def __str__(self) -> str:
        return '#' + self

    def __repr__(self) -> str:
        return 'Imm(%s)' % super().__repr__()

class Lit:
    ty  : type
    val : object

    def __init__(self, v: object):
        if type(v) not in {int, float}:
            raise TypeError('invalid literal valu: ' + repr(v))
        else:
            self.ty, self.val = type(v), v

    def __str__(self) -> str:
        return '#%s' % self.val

    def __repr__(self) -> str:
        return 'Lit(%s: %s)' % (self.val, self.ty)

class Reg(NamedTuple):
    name: str
    altr: str | None = None
    size: str | None = None
    mode: str | Tag | None = None
    vidx: Imm | Lit | None = None

    def __str__(self) -> str:
        if self.size is not None:
            assert self.altr is None
            assert self.mode is None
            assert self.vidx is None
            return '%s[%s]' % (self.size, self.name)
        elif self.mode is not None and self.vidx is not None:
            assert self.altr is None
            return '%s.%s[%s]' % (self.name, self.mode, self.vidx)
        elif self.mode is not None:
            assert self.altr is None
            return '%s.%s' % (self.name, self.mode)
        elif self.altr is not None:
            assert self.vidx is None
            return '(%s|%s)' % (self.name, self.altr)
        else:
            return self.name

class Vec(NamedTuple):
    mode: str | Tag
    regs: list[str]
    vidx: Imm | Lit | None = None

    def __str__(self) -> str:
        return '{ %s }.%s%s' % (
            ', '.join(self.regs),
            self.mode,
            '' if self.vidx is None else '[%s]' % self.vidx
        )

class Mod(NamedTuple):
    mod: str | Sop | Xop
    imm: tuple[Imm | Lit, bool] | None = None

    def name(self) -> str:
        if isinstance(self.mod, str):
            return self.mod
        else:
            return self.mod.name

    def __str__(self) -> str:
        if self.imm is None:
            return self.name()
        elif not self.imm[1]:
            return '%s %s' % (self.name(), self.imm[0])
        else:
            return '%s {%s}' % (self.name(), self.imm[0])

class Mem(NamedTuple):
    base   : Reg
    offs   : tuple[Imm | Reg | Lit, bool] | None = None
    index  : Literal['pre', 'post'] | None       = None
    extend : tuple[Mod, bool] | None             = None

    def __str__(self) -> str:
        ret = []
        ret.append('[')
        ret.append(self.base)

        if self.offs and self.index != 'post':
            v, o = self.offs
            ret.append('%s, %s%s' % ('{' if o else '', str(v), '}' if o else ''))

        if self.extend:
            v, o = self.extend
            ret.append('%s, %s%s' % ('{' if o else '', str(v), '}' if o else ''))

        match self.index:
            case 'pre':
                assert self.offs, 'missing index for pre index'
                ret.append(']!')

            case 'post':
                assert self.offs, 'missing index for post index'
                v, o = self.offs
                ret.append(']%s+%s%s' % ('{' if o else '', str(v), '}' if o else ''))

            case v:
                ret.append(']')
                assert v is None

        return ''.join(
            str(v)
            for v in ret
        )

class Seq(NamedTuple):
    req: list[Reg | Vec | Mem | Mod | Imm | Lit | Sym]
    opt: Reg | Vec | Mem | Mod | Imm | Lit | Sym | None = None

    def __str__(self) -> str:
        return ''.join([
            *('%s%s' % (', ' if i else '', str(v)) for i, v in enumerate(self.req)),
            f'{{, {self.opt}}}' if self.opt else ''
        ])

class Instr(NamedTuple):
    mnemonic: str
    operands: Seq
    modifier: str | None

    def __str__(self) -> str:
        return ''.join([
            self.mnemonic,
            '{%s}' % self.modifier if self.modifier else '',
            ' ' if self.operands.req or self.operands.opt is not None else '',
            str(self.operands)
        ])

class Token(NamedTuple):
    name: str
    text: str

    def __repr__(self) -> str:
        return '\x1b[31m{%s}\x1b[0m' % self.name

    @classmethod
    def parse(cls, item: Element) -> 'Token':
        return cls(
            text = item.text or '',
            name = item.attrib['link'],
        )

class AsmTemplate:
    pos: int
    buf: list[str | Token]

    sops = { v.name for v in Sop }
    xops = { v.name for v in Xop }

    shifts  = { 'shift' }
    extends = { 'extend', 'extend_1' }

    amounts = {
        'amount',
        'amount_1',
        'amount_2',
        'amount_3',
        'amount_4',
        'shift',
        'shift_1',
        'shift_2',
        'shift_3',
    }

    registers = {
        'd',
        'm',
        'n',
        't',
    }

    immediates = {
        'imm',
        'imm_1',
        'imm_2',
        'imm_3',
    }

    predefined = {
        'CSYNC': (
            Sym.CSYNC,
            'CSYNC option',
            []
        ),
        'prfop': (
            Sym.PRFOP,
            'prefetch option',
            ['|', '#', 'imm5']
        ),
        'option': (
            Sym.OPTION,
            'barrier option',
            ['|', '#', 'imm']
        ),
        'systemreg': (
            Sym.SYSREG,
            'system register',
            ['|', 'S', 'op0', '_', 'op1', '_', 'cn', '_', 'cm', '_', 'op2']
        ),
    }

    for v in Sym:
        assert v.value in predefined

    def __init__(self, tok: list[str | Token]):
        self.pos = 0
        self.buf = tok

    @property
    def eof(self) -> bool:
        return self.pos >= len(self.buf)

    @property
    def tok(self) -> str | Token:
        if self.eof:
            raise SyntaxError('unexpected EOF')
        else:
            return self.buf[self.pos]

    def next(self) -> str | Token:
        ret = self.tok
        self.pos += 1
        return ret

    def must(self, tok: str):
        if self.next() != tok:
            raise SyntaxError('"%s" expected' % tok)

    def skip(self, tok: str) -> bool:
        if self.eof or self.buf[self.pos] != tok:
            return False
        else:
            self.pos += 1
            return True

    def dsym(self, name: str) -> Sym:
        tok = []
        sym, msg, mat = self.predefined[name]

        for _ in mat:
            v = self.next()
            tok.append(v.name if isinstance(v, Token) else v)

        if tok != mat:
            raise SyntaxError('invalid %s: %r' % (msg, name))
        else:
            return sym

    def value(self) -> Reg | Vec | Mem | Mod | Imm | Lit | Sym:
        match self.next():
            case '#':
                match self.next():
                    case '0.0'                                   : return Lit(0.0)
                    case v if isinstance(v, str) and v.isdigit() : return Lit(int(v))
                    case v if isinstance(v, Token)               : return Imm(v.name)
                    case v                                       : raise SyntaxError('integer or token expected')

            case '(':
                reg = self.next()
                tab = self.predefined

                if not isinstance(reg, Token):
                    raise SyntaxError('register token expected')

                if reg.name in tab:
                    ret = self.dsym(reg.name)
                    self.must(')')
                    return ret

                self.must('|')
                tok = self.next()

                if not isinstance(tok, Token):
                    raise SyntaxError('register token expected')

                ret = Reg(reg.name, altr = tok.name)
                self.must(')')
                return ret

            case '[':
                buf = self.vlist()
                self.must(']')

                if not buf.req:
                    raise SyntaxError('invalid memory operand')

                idx = 'pre' if self.skip('!') else None
                args = [(v, bool(False)) for v in buf.req]

                if buf.opt is not None:
                    args.append((buf.opt, True))

                exts = None
                offs = None
                base = args[0][0]

                if not isinstance(base, Reg):
                    raise SyntaxError('memory base must be a register')

                if len(args) >= 2:
                    if not isinstance(args[1][0], (Reg, Imm, Lit)):
                        raise SyntaxError('memory offset must be a register or an immediate value')
                    else:
                        offs = (args[1][0], args[1][1])

                if len(args) >= 3:
                    if not isinstance(args[2][0], Mod):
                        raise SyntaxError('memory offset extension must be an extension')
                    else:
                        exts = (args[2][0], args[2][1])

                if len(args) >= 4:
                    raise SyntaxError('too many argumnets for memory operand')

                return Mem(
                    base   = base,
                    offs   = offs,
                    index  = idx,
                    extend = exts,
                )

            case '{{':
                regs = []
                mode = None
                vidx = None

                while True:
                    reg = self.next()
                    self.must('.')

                    if not isinstance(reg, Token):
                        raise SyntaxError('invalid vector element')

                    tok = self.next()
                    tag = Tag(tok) if isinstance(tok, str) else tok.name

                    if mode != tag and mode is not None:
                        raise SyntaxError('mode confliction within vector')

                    mode = tag
                    regs.append(reg.name)

                    match self.next():
                        case ','  : pass
                        case '}}' : break
                        case _    : raise SyntaxError('"," or "}" expected')

                if self.skip('['):
                    vidx = self.next()
                    vidx = Imm(vidx.name) if isinstance(vidx, Token) else Lit(int(vidx))
                    self.must(']')

                return Vec(
                    mode = mode,
                    regs = regs,
                    vidx = vidx,
                )

            case v if isinstance(v, str) and v in self.predefined:
                return self.dsym(v)

            case v if isinstance(v, Token) and v.name in self.immediates:
                return Imm(v.name)

            case v if isinstance(v, Token) and v.name in self.predefined:
                return self.dsym(v.name)

            case v if isinstance(v, Token) and v.name not in self.shifts and v.name not in self.extends:
                mode = None
                size = None
                vidx = None
                name = v.name

                if not self.eof:
                    if self.skip('.'):
                        mode = self.next()
                        mode = Tag(mode) if isinstance(mode, str) else mode.name

                        if self.skip('['):
                            vidx = self.next()
                            vidx = Imm(vidx.name) if isinstance(vidx, Token) else Lit(int(vidx))
                            self.must(']')

                    elif isinstance(self.tok, Token) and self.tok.name in self.registers:
                        size = v.name
                        name = self.tok.name
                        self.next()

                return Reg(
                    name = name,
                    mode = mode,
                    size = size,
                    vidx = vidx,
                )

            case v:
                opt = False
                mod = v.name if isinstance(v, Token) else v

                if isinstance(v, str):
                    if mod not in self.sops and mod not in self.xops:
                        raise SyntaxError('unexpected token: ' + repr(v))
                else:
                    if mod not in self.shifts and mod not in self.extends:
                        raise SyntaxError('unexpected token: ' + repr(v))

                if self.tok == '{':
                    opt = True
                    self.next()

                if self.tok == '#':
                    imm = self.value()
                elif isinstance(self.tok, Token):
                    imm = Imm(cast(Token, self.next()).name)
                else:
                    imm = None

                if opt and self.next() != '}':
                    raise SyntaxError('"}" expected')

                if imm is not None and not isinstance(imm, Lit):
                    if not isinstance(imm, Imm) or not imm in self.amounts:
                        raise SyntaxError('invalid extension immediate')

                if mod in self.sops:
                    mod = Sop(mod.lower())
                elif mod in self.xops:
                    mod = Xop(mod.lower())

                if imm is None:
                    return Mod(mod)
                else:
                    return Mod(mod, (imm, opt))

    def vlist(self) -> Seq:
        req = []
        opt = None

        if not self.eof and self.tok != '{':
            val = self.value()
            req.append(val)

            while self.skip(','):
                val = self.value()
                mem = req[-1] if req else None

                if not isinstance(mem, Mem):
                    req.append(val)
                elif not isinstance(val, (Reg, Imm, Lit)):
                    req.append(val)
                elif mem.offs is not None or mem.index is not None:
                    req.append(val)
                else:
                    req[-1] = Mem(mem.base, (val, False), 'post', mem.extend)

        if self.skip('{'):
            if req:
                self.must(',')

            opt = self.value()
            self.must('}')

        return Seq(
            req = req,
            opt = opt,
        )

    def instr(self) -> Instr:
        mods = None
        args = Seq([])
        name = self.next()

        if not isinstance(name, str):
            raise SyntaxError('mnemonic expected')

        if not self.eof:
            match self.tok:
                case '.' if name == 'B':
                    self.next()
                    cond = self.next()

                    if not isinstance(cond, Token):
                        raise SyntaxError('branch condition expected')
                    else:
                        mods = cond.name

                case v if isinstance(v, Token) and v.name == '2':
                    mods = '2'
                    self.next()

                case v if isinstance(v, Token) and v.name == 'bt' and name == 'BFMLAL':
                    mods = 'bt'
                    self.next()

        if not self.eof:
            args = self.vlist()

        if not self.eof:
            raise SyntaxError('junk after instruction: ' + str(self.next()))

        return Instr(
            mnemonic = name,
            operands = args,
            modifier = mods,
        )

    class Lexer:
        buf   : str
        sbuf  : str
        items : list[Element]

        def __init__(self, items: list[Element]):
            self.buf   = ''
            self.sbuf  = ''
            self.items = items

        def __iter__(self) -> Iterator[str | Token]:
            for item in self.items:
                match item.tag:
                    case 'a':
                        yield from self._parse_text()
                        yield Token.parse(item)
                        self.buf = ''

                    case 'text':
                        if item.text:
                            self.buf += item.text

                    case _:
                        raise AssertionError('unexpected tag in assembly template: ' + repr(item.tag))

            yield from self._parse_text()
            self.buf = ''

        def _parse_dots(self) -> Iterator[str]:
            if self.sbuf:
                if self.sbuf == '.' or self.sbuf[-1] != '.':
                    yield self.sbuf
                else:
                    yield self.sbuf[:-1]
                    yield self.sbuf[-1]

        def _parse_text(self) -> Iterator[str]:
            for i, ch in enumerate(self.buf):
                if ch.isalnum() or ch == '_' or (self.sbuf and ch == '.'):
                    self.sbuf += ch
                    continue

                yield from self._parse_dots()
                self.sbuf = ''

                if not ch.isspace():
                    if ch == '}' and i != 0 and self.buf[i - 1].isspace():
                        yield '}}'
                    elif ch == '{' and i != len(self.buf) - 1 and self.buf[i + 1].isspace():
                        yield '{{'
                    else:
                        yield ch

            yield from self._parse_dots()
            self.sbuf = ''

    @classmethod
    def parse(cls, items: list[Element]) -> Instr:
        return cls(list(cls.Lexer(items))).instr()

class InstrForm(NamedTuple):
    text   : str
    inst   : Instr
    bits   : Instruction
    opts   : dict[str, str]
    args   : list[str | int]
    enctab : EncodingTabEntry
    fields : dict[str, Account | Definition]

def permu_bits(bit: str) -> str:
    match bit:
        case '0': return '0'
        case '1': return '1'
        case 'x': return '01'
        case _  : raise AssertionError('invalid bit value: ' + repr(bit))

def parse_props(out: dict[str, str], p: Element):
    for v in p.findall('docvars/docvar'):
        out[v.attrib['key']] = v.attrib['value']

def parse_boxes(ins: Instruction, boxes: list[Element]):
    for box in boxes:
        boxes = box.findall('c')
        hibit = int(box.attrib['hibit'])

        for i, item in enumerate(boxes):
            if item.text == '0':
                assert ins.bits[hibit - i] != 1, 'bit confiction: 0'
                ins.bits[hibit - i] = 0
            elif item.text == '1':
                assert ins.bits[hibit - i] != 0, 'bit confiction: 1'
                ins.bits[hibit - i] = 1
            else:
                assert item.text in {None, '', 'x', 'z', 'N', 'Z'}, \
                    'invalid cell value: ' + repr(item.text)

def parse_symdef(defs: Element) -> dict[str, set[str]]:
    rets = {}
    tabs = defs.findall('.//tgroup')
    rows = defs.findall('.//tbody/row')
    dest = defs.attrib['encodedin']

    if len(tabs) != 1:
        raise AssertionError('expect exactly 1 table: encodedin="%s"' % dest)

    for row in rows:
        bits = []
        syms = row.find('entry[@class="symbol"]')

        for bv in row.findall('entry[@class="bitfield"]'):
            if not bv.text:
                raise AssertionError('missing symbol or bitfield: encodedin="%s"' % dest)
            else:
                bits.append(bv.text)

        if not bits or syms is None or not syms.text:
            raise AssertionError('missing symbol or bitfield: encodedin="%s"' % dest)

        for sym in map(str.strip, syms.text.split('|')):
            prod = itertools.product(*map(permu_bits, ''.join(bits)))
            rets.setdefault(sym, set()).update(''.join(v) for v in prod)

    if not rets:
        raise AssertionError('missing definitions: encodedin="%s"' % dest)
    else:
        return rets

maxargs = 0
formtab = dict[str, list[InstrForm]]()
fieldtab = dict[str, dict[str, Account | Definition]]()

for expl in isadocs.findall('.//explanation'):
    symbol = expl.find('symbol')
    symacc = expl.find('account')
    symdef = expl.find('definition')

    if symbol is None or (symacc is None) is (symdef is None):
        raise AssertionError('invalid explanation')

    desc = symbol.text or ''
    name = symbol.attrib['link']
    status('* Field Explanation:', name)

    if symacc is not None:
        assert symdef is None
        defs = Account(symacc.attrib['encodedin'], desc)
    else:
        assert isinstance(symdef, Element)
        defs = Definition(symdef.attrib['encodedin'], desc, parse_symdef(symdef))

    for enc in expl.attrib['enclist'].split(','):
        tab = fieldtab.setdefault(enc.strip(), {})
        tab[name] = defs

for encdata in sorted(enctab.values(), key = lambda x: x.name):
    node = isadocs.find('.//iclass/encoding[@name="%s"]' % encdata.name)
    assert node is not None, 'encoding %s does not exists' % repr(encdata.name)

    tokens = node.findall('asmtemplate/*')
    assert tokens, 'encoding %s does not have an assembly syntax' % repr(encdata.name)

    text = ''.join(v.text or '' for v in tokens)
    status('* Assembly Template:', text)

    args = []
    opts = {}
    bits = Instruction(encdata.bits)
    inst = AsmTemplate.parse(tokens)

    parse_props(opts, node)
    parse_boxes(bits, node.findall('box'))
    assert inst.mnemonic == opts['mnemonic']

    if inst.operands.opt is None:
        maxargs = max(maxargs, len(inst.operands.req))
    else:
        maxargs = max(maxargs, len(inst.operands.req) + 1)

    req = list(bits.refs.items())
    req.sort(key = lambda x: x[1], reverse = True)

    for v, (p, n) in req:
        if None in bits.bits[p:p + n]:
            args.append(v)
        else:
            args.append(int(''.join(map(str, bits.bits[p:p + n])), 2))

    formtab.setdefault(inst.mnemonic, []).append(InstrForm(
        text   = text,
        inst   = inst,
        bits   = bits,
        opts   = opts,
        args   = args,
        enctab = encdata,
        fields = fieldtab.get(encdata.name, {})
    ))

### ---------- Per-instruction Encoding ---------- ###

class Or(list['And | Or | str']):
    def __init__(self, *terms: 'And | Or | str'):
        super().__init__(terms)

    def __str__(self) -> str:
        return ' || '.join(str(v) for v in self)

class And(list['And | Or | str']):
    def __init__(self, *terms: 'And | Or | str'):
        super().__init__(terms)

    def __str__(self) -> str:
        if len(self) == 1 and isinstance(self[0], Or):
            return str(self[0])
        else:
            return ' && '.join('(%s)' % str(v) if isinstance(v, Or) else str(v) for v in self)

IMM_CHECKS = {
    'imm9'  : 'isImm9(%s)',
    'imm12' : 'isImm12(%s)',
}

REG_CHECKS = {
    'bt'     : 'isBr(%s)',
    'dt'     : 'isDr(%s)',
    'ht'     : 'isHr(%s)',
    'qt'     : 'isQr(%s)',
    'st'     : 'isSr(%s)',
    'vd'     : 'isVr(%s)',
    'vm'     : 'isVr(%s)',
    'vn'     : 'isVr(%s)',
    'wd'     : 'isWr(%s)',
    'wd_wsp' : 'isWrOrWSP(%s)',
    'wm'     : 'isWr(%s)',
    'wn'     : 'isWr(%s)',
    'wn_wsp' : 'isWrOrWSP(%s)',
    'ws'     : 'isWr(%s)',
    'wt'     : 'isWr(%s)',
    'xd'     : 'isXr(%s)',
    'xd_sp'  : 'isXrOrSP(%s)',
    'xm'     : 'isXr(%s)',
    'xn'     : 'isXr(%s)',
    'xn_sp'  : 'isXrOrSP(%s)',
    'xs'     : 'isXr(%s)',
    'xt'     : 'isXr(%s)',
}

REG_CHECKS_MERGED = {
    'isWr(%s) || isXr(%s)' : 'isWrOrXr(%s)',
    'isXr(%s) || isSP(%s)' : 'isXrOrSP(%s)',
    'isWr(%s) || isWSP(%s)': 'isWrOrWSP(%s)',
}

COMBREG_CHECKS = {
    'd': 'isWrOrXr(%s)',
    'm': 'isWrOrXr(%s)',
    'n': 'isWrOrXr(%s)',
}

FIXEDVEC_CHECKS = {
    'd': 'isAdvSIMD(%s)',
    'm': 'isAdvSIMD(%s)',
    'n': 'isAdvSIMD(%s)',
}

SIGNED_IMM = {
    'simm',
    'pimm',
    'pimm_1',
    'pimm_2',
    'pimm_3',
    'pimm_4',
}

UNSIGNED_IMM = {
    'uimm',
}

def match_operands(form: InstrForm, argc: int) -> Iterator['And | Or | str']:
    dynvec = {}
    fixedvec = {}
    # TODO: remove this
    print('------- match operand -------')
    print(form.inst)

    for i, val in enumerate(form.inst.operands.req):
        if i < argc:
            name = 'v%d' % i
        else:
            name = 'vv[%d]' % (i - argc)

        if isinstance(val, Reg):
            if val.size is not None:
                if val.size == 'r':
                    yield COMBREG_CHECKS[val.name] % name
                else:
                    yield FIXEDVEC_CHECKS[val.name] % name
                    fixedvec.setdefault(val.size, []).append(name)

            elif val.mode is not None and val.vidx is not None:
                # TODO: this
                print('%s.%s[%s]' % (val.name, val.mode, val.vidx))
                raise NotImplementedError('indexed vector')

            elif val.mode is not None:
                yield 'isVr(%s)' % name
                dynvec.setdefault(val.mode, []).append(name)

            elif val.altr is not None:
                c1 = REG_CHECKS[val.name]
                c2 = REG_CHECKS[val.altr]
                v1 = REG_CHECKS_MERGED.get('%s || %s' % (c1, c2))
                v2 = REG_CHECKS_MERGED.get('%s || %s' % (c2, c1))

                if v1 is not None:
                    yield v1 % name
                elif v2 is not None:
                    yield v2 % name
                else:
                    yield Or(c1 % name, c2 % name)

            elif val.name == 'label':
                yield 'isLabel(%s)' % name

            else:
                yield REG_CHECKS[val.name] % name

        elif isinstance(val, Vec):
            # TODO: handle vector
            print(val)
            raise NotImplementedError('vec operand')

        elif isinstance(val, Mem):
            yield 'isMem(%s)' % name
            yield REG_CHECKS[val.base.name] % ('membase(%s)' % name)

            if val.offs is None:
                yield 'memindex(%s) == nil' % name
                yield 'memoffset(%s) == 0' % name

            else:
                off = val.offs[0]
                opt = val.offs[1]

                if isinstance(off, Imm):
                    if off in SIGNED_IMM:
                        yield 'memindex(%s) == nil' % name
                    elif off in UNSIGNED_IMM:
                        yield from ['memindex(%s) == nil' % name, 'memoffset(%s) >= 0' % name]
                    else:
                        raise RuntimeError('invalid offset type ' + repr(off))

                elif isinstance(off, Reg):
                    key = 'memindex(%s)' % name
                    yield 'memoffset(%s) == 0' % name

                    if off.size is not None:
                        raise RuntimeError('invalid offset register: vector')

                    if off.mode is not None:
                        raise RuntimeError('invalid offset register: dyn or indexed vector')

                    if not opt:
                        if off.altr is None:
                            yield REG_CHECKS[off.name] % key

                        else:
                            c1 = REG_CHECKS[off.name]
                            c2 = REG_CHECKS[off.altr]
                            v1 = REG_CHECKS_MERGED.get('%s || %s' % (c1, c2))
                            v2 = REG_CHECKS_MERGED.get('%s || %s' % (c2, c1))

                            if v1 is not None:
                                yield v1 % key
                            elif v2 is not None:
                                yield v2 % key
                            else:
                                yield Or(c1 % key, c2 % key)

                else:
                    if off.ty is not int:
                        raise RuntimeError('invalid literal type for offsets')
                    elif not opt:
                        yield from ['memindex(%s) == nil' % name, 'memoffset(%s) == %d' % (name, off.val)]
                    else:
                        yield from ['memindex(%s) == nil' % name, Or('memoffset(%s) == 0' % name, 'memoffset(%s) == %d' % (name, off.val))]

            if val.extend is None:
                match val.index:
                    case None   : yield 'memext(%s) == nil' % name
                    case 'pre'  : yield 'memext(%s) == PreIndex' % name
                    case 'post' : yield 'memext(%s) == PostIndex' % name
                    case _      : raise RuntimeError('invalid memory index')

            else:
                ext = val.extend[0]
                opx = val.extend[1]

                if val.index is not None:
                    raise RuntimeError('extension conflits with indexing')

                if not opx:
                    if isinstance(ext.mod, Sop):
                        yield 'isMemMod(%s, %s(0))' % (name, ext.mod.name)
                    elif isinstance(ext.mod, Xop):
                        yield 'isMemMod(%s, %s(0))' % (name, ext.mod.name)
                    elif ext.mod in AsmTemplate.shifts:
                        yield 'memmod(%s) != nil' % name
                    elif ext.mod in AsmTemplate.extends:
                        yield 'memmod(%s) != nil' % name
                    else:
                        raise RuntimeError('invalid extension')

                    if ext.imm is None:
                        yield 'memamount(%s) == 0' % name

                    else:
                        imm = ext.imm[0]
                        opm = ext.imm[1]

                        if isinstance(imm, Lit):
                            if imm.ty is not int:
                                raise RuntimeError('invalid literal type for amounts')
                            elif not opm or imm.val == 0:
                                yield 'memamount(%s) == %d' % (name, imm.val)
                            else:
                                yield Or('memamount(%s) == 0' % name, 'memamount(%s) == %d' % (name, imm.val))

        elif isinstance(val, Mod):
            # TODO: handle extensions
            print(val)
            raise NotImplementedError('mod operand')

        elif isinstance(val, Imm):
            yield IMM_CHECKS[form.fields[val].name] % name

        elif isinstance(val, Lit):
            if val.ty is not int:
                raise RuntimeError('invalid literal type for operands')
            else:
                yield '%s == %d' % (name, val.val)

        elif isinstance(val, Sym):
            # TODO: handle extensions
            print(val)
            raise NotImplementedError('sym operand')

        else:
            raise RuntimeError('invalid operand type')

    yield from (
        'isSameSize(%s, %s)' % (v[i], v[i + 1])
        for v in dynvec.values()
        for i in range(len(v) - 1)
    )

    yield from (
        'isSameType(%s, %s)' % (v[i], v[i + 1])
        for v in fixedvec.values()
        for i in range(len(v) - 1)
    )

IMM_ENCODER = {
    'imm12' : 'asImm12',
}

def encode_operand(
    form : InstrForm,
    name : str,
    val  : Reg | Vec | Mem | Mod | Imm | Lit | Sym,
    vals : dict[str, str],
    opts : dict[str, str],
):
    if isinstance(val, Reg):
        if val.mode is not None and val.vidx is not None:
            # TODO: this
            print('%s.%s[%s]' % (val.name, val.mode, val.vidx))
            raise NotImplementedError('indexed vector')

        elif val.mode is not None:
            vals[val.name] = 'uint32(%s.(asm.Register).ID())' % name
            vals[val.mode] = 'uint32(%s.(SIMDRegister128r).Arrangement())' % name

        elif val.name == 'label':
            vals[val.name] = name + '.(*asm.Label)'

        else:
            vals[val.name] = 'uint32(%s.(asm.Register).ID())' % name

    elif isinstance(val, Vec):
        # TODO: handle vector
        print(val)
        raise NotImplementedError('vec operand')

    elif isinstance(val, Mem):
        if val.base.mode is not None or val.base.vidx is not None:
            raise RuntimeError('vector base is not supported')
        else:
            vals[val.base.name] = 'uint32(membase(%s).ID())' % name

        if val.offs is not None:
            off = val.offs[0]
            opt = val.offs[1]

            if isinstance(off, Imm):
                vals[off.name] = 'uint32(memoffset(%s))' % name

            elif isinstance(off, Reg):
                if opt:
                    raise RuntimeError('optional offset register is not supported')
                elif off.size is not None:
                    raise RuntimeError('invalid offset register: vector')
                elif off.mode is not None:
                    raise RuntimeError('invalid offset register: dyn or indexed vector')
                elif off.altr is not None:
                    vals[off.altr] = 'uint32(memindex(%s).ID())' % name
                else:
                    vals[off.name] = 'uint32(memindex(%s).ID())' % name

        if val.extend is not None:
            ext = val.extend[0]
            opx = val.extend[1]

            if val.index is not None:
                raise RuntimeError('extension conflits with indexing')

            if opx and not isinstance(ext.mod, (Sop, Xop)):
                opts[ext.mod] = 'memmod(%s) != nil' % name

            if ext.mod in AsmTemplate.shifts:
                vals[ext.mod] = 'uint32(memmod(%s).(ShiftType).ShiftType())' % name
            elif ext.mod in AsmTemplate.extends:
                vals[ext.mod] = 'uint32(memmod(%s).(Extension).Extension())' % name

            if ext.imm is not None and isinstance(ext.imm[0], Imm):
                args = ext.imm[0].name
                vals[args] = 'uint32(memmod(%s).Amount())' % name

                if opx:
                    opts[args] = 'memmod(%s) != nil' % name

    elif isinstance(val, Mod):
        # TODO: this
        print(val)
        raise NotImplementedError('mod operand')

    elif isinstance(val, Imm):
        vals[val.name] = '%s(%s)' % (IMM_ENCODER[form.fields[val].name], name)

    elif isinstance(val, Lit):
        # TODO: this
        print(val)
        raise NotImplementedError('lit operand')

    elif isinstance(val, Sym):
        # TODO: this
        print(val)
        raise NotImplementedError('sym operand')

    else:
        raise RuntimeError('invalid operand type')

cc = CodeGen()
cc.line('// Code generated by "mkasm_aarch64.py", DO NOT EDIT.')
cc.line()
cc.line('package aarch64')
cc.line()
cc.line('import (')
cc.indent()
cc.line('`github.com/chenzhuoyu/iasm/asm`')
cc.dedent()
cc.line(')')
cc.line()
cc.line('const (')
cc.indent()
cc.line('_N_args = %d' % maxargs)
cc.dedent()
cc.line(')')
cc.line()

for mnemonic, forms in sorted(formtab.items(), key = lambda x: x[0]):
    nops = set()
    status('* Instruction:', mnemonic)

    if len(forms) == 1:
        cc.line('// %s instruction have a single form:' % mnemonic)
        cc.line('//')
    else:
        cc.line('// %s instruction have a %s forms:' % (mnemonic, len(forms)))
        cc.line('//')

    for form in forms:
        nop = len(form.inst.operands.req)
        nops.add(nop)
        cc.line('//   * %s' % form.text)

        if form.inst.operands.opt is not None:
            nops.add(nop + 1)

    cc.line('//')
    nfix = min(nops)
    base = ['v%d' % i for i in range(nfix)]

    if nfix == max(nops):
        if not nfix:
            cc.line('func (self *Program) %s() *Instruction {' % mnemonic)
            cc.indent()
            cc.line('p := self.alloc("%s", 0, Operands {})' % mnemonic)
        else:
            cc.line('func (self *Program) %s(%s interface{}) *Instruction {' % (mnemonic, ', '.join(base)))
            cc.indent()
            cc.line('p := self.alloc("%s", %d, Operands { %s })' % (mnemonic, nfix, ', '.join(base)))

    else:
        if not nfix:
            cc.line('func (self *Program) %s(vv ...interface{}) *Instruction {' % mnemonic)
        else:
            cc.line('func (self *Program) %s(%s interface{}, vv ...interface{}) *Instruction {' % (mnemonic, ', '.join(base)))

        cc.indent()
        cc.line('var p *Instruction')
        cc.line('switch len(vv) {')
        cc.indent()

        for argc in sorted(nops):
            if not argc:
                assert nfix == 0
                cc.line('case 0  : p = self.alloc("%s", 0, Operands {})' % mnemonic)
            else:
                args = base[:] + ['vv[%d]' % i for i in range(argc - nfix)]
                cc.line('case %d  : p = self.alloc("%s", %d, Operands { %s })' % (argc - nfix, mnemonic, argc, ', '.join(args)))

        cc.line('default : panic("instruction %s takes %s operands")' % (mnemonic, ' or '.join(map(str, sorted(nops)))))
        cc.dedent()
        cc.line('}')

    for form in forms:
        cc.line('// ' + form.text)
        cc.line('if %s {' % And(*match_operands(form, nfix)))
        cc.indent()

        fmap = {}
        args = []
        decl = set()

        for key, fv in form.fields.items():
            nb = 0
            fn = fv.name.split(':')

            if len(fn) == 1:
                fmap[fv.name] = (key, key)
                continue

            for x in fn:
                _, n = form.bits.refs[x]
                nb += n

            for x in fn:
                _, n = form.bits.refs[x]
                nb -= n

                if nb == 0:
                    fmap[x] = (key, '%s & 0b%s' % (key, '1' * n))
                else:
                    fmap[x] = (key, '(%s >> %d) & 0b%s' % (key, nb, '1' * n))

        for v in form.args:
            if not isinstance(v, str):
                args.append(str(v))
            else:
                var, arg = fmap[v]
                decl.add(var)

                if arg != 'label':
                    args.append(arg)
                else:
                    args.append('uint32(label.RelativeTo(pc))')

        vals = OrderedDict()
        opts = OrderedDict()
        encode_now = True

        for i, val in enumerate(form.inst.operands.req):
            if i < nfix:
                encode_operand(form, 'v%d' % i, val, vals, opts)
            else:
                encode_operand(form, 'vv[%d]' % (i - nfix), val, vals, opts)

        for var in sorted(decl):
            if var in opts:
                if var != 'label':
                    cc.line('var %s uint32' % var)
                else:
                    cc.line('var %s *asm.Label' % var)

        for k, v in vals.items():
            if k not in opts:
                cc.line('%s := %s' % (k, v))
            else:
                cc.line('if %s {' % opts[k])
                cc.indent()
                cc.line('%s = %s' % (k, v))
                cc.dedent()
                cc.line('}')

        # if form.inst.operands.opt is not None:
        #     # TODO: this
        #     print(form)
        #     raise NotImplementedError('opt operand')

        for op in form.inst.operands.req:
            if op == Reg('label'):
                encode_now = False
                break

        if form.inst.operands.opt == Reg('label'):
            encode_now = False

        if encode_now:
            cc.line('p.setins(%s(%s))' % (form.enctab.func, ', '.join(args)))
        else:
            cc.line('p.setenc(func(pc uintptr) uint32 { return %s(%s) })' % (form.enctab.func, ', '.join(args)))

        cc.dedent()
        cc.line('}')

    cc.line('if !p.isvalid {')
    cc.indent()
    cc.line('panic("aarch64: invalid combination of operands for %s")' % mnemonic)
    cc.dedent()
    cc.line('}')
    cc.line('return p')
    cc.dedent()
    cc.line('}')
    cc.line()

with open('arch/aarch64/instructions.go', 'w') as fp:
    fp.write('\n'.join(cc.buf))
